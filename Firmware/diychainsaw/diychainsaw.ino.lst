
C:\Users\Pavel\AppData\Local\Temp\arduino_build_756894/diychainsaw.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	53 c0       	rjmp	.+166    	; 0xa8 <__ctors_end>
   2:	77 c0       	rjmp	.+238    	; 0xf2 <__bad_interrupt>
   4:	76 c0       	rjmp	.+236    	; 0xf2 <__bad_interrupt>
   6:	75 c0       	rjmp	.+234    	; 0xf2 <__bad_interrupt>
   8:	74 c0       	rjmp	.+232    	; 0xf2 <__bad_interrupt>
   a:	40 c2       	rjmp	.+1152   	; 0x48c <__vector_5>
   c:	72 c0       	rjmp	.+228    	; 0xf2 <__bad_interrupt>
   e:	71 c0       	rjmp	.+226    	; 0xf2 <__bad_interrupt>
  10:	70 c0       	rjmp	.+224    	; 0xf2 <__bad_interrupt>
  12:	6f c0       	rjmp	.+222    	; 0xf2 <__bad_interrupt>
  14:	6e c0       	rjmp	.+220    	; 0xf2 <__bad_interrupt>
  16:	6d c0       	rjmp	.+218    	; 0xf2 <__bad_interrupt>
  18:	6c c0       	rjmp	.+216    	; 0xf2 <__bad_interrupt>
  1a:	6b c0       	rjmp	.+214    	; 0xf2 <__bad_interrupt>
  1c:	6a c0       	rjmp	.+212    	; 0xf2 <__bad_interrupt>

0000001e <__trampolines_end>:
__trampolines_start():
  1e:	c8 a1       	ldd	r28, Y+32	; 0x20
  20:	a8 1f       	adc	r26, r24
  22:	da 02       	muls	r29, r26
  24:	8d 14       	cp	r8, r13

00000026 <bat0>:
  26:	fe ff 03 fb fb fb fb fb fb fb fb fb 03 fb fb fb     ................
  36:	fb fb fb fb fb fb 03 fb fb fb fb fb fb fb fb fb     ................
  46:	ff ff 00 ff ff ff ff ff ff ff ff ff 00 ff ff ff     ................
  56:	ff ff ff ff ff ff 00 ff ff ff ff ff ff ff ff ff     ................
  66:	ff ff 00 ff ff ff ff ff ff ff ff ff 00 ff ff ff     ................
  76:	ff ff ff ff ff ff 00 ff ff ff ff ff ff ff ff ff     ................
  86:	7f ff c0 df df df df df df df df df c0 df df df     ................
  96:	df df df df df df c0 df df df df df df df df df     ................

000000a6 <__ctors_start>:
__ctors_start():
  a6:	09 03       	fmul	r16, r17

000000a8 <__ctors_end>:
__dtors_end():
  a8:	11 24       	eor	r1, r1
  aa:	1f be       	out	0x3f, r1	; 63
  ac:	cf e5       	ldi	r28, 0x5F	; 95
  ae:	d2 e0       	ldi	r29, 0x02	; 2
  b0:	de bf       	out	0x3e, r29	; 62
  b2:	cd bf       	out	0x3d, r28	; 61

000000b4 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  b4:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  b6:	aa e6       	ldi	r26, 0x6A	; 106
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  b8:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  ba:	01 c0       	rjmp	.+2      	; 0xbe <.do_clear_bss_start>

000000bc <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  bc:	1d 92       	st	X+, r1

000000be <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  be:	a6 39       	cpi	r26, 0x96	; 150
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  c0:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  c2:	e1 f7       	brne	.-8      	; 0xbc <.do_clear_bss_loop>

000000c4 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  c4:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  c6:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  c8:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  ca:	ea e6       	ldi	r30, 0x6A	; 106
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  cc:	f6 e0       	ldi	r31, 0x06	; 6
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  ce:	02 c0       	rjmp	.+4      	; 0xd4 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  d0:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  d2:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  d4:	aa 36       	cpi	r26, 0x6A	; 106
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  d6:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  d8:	d9 f7       	brne	.-10     	; 0xd0 <__do_copy_data+0xc>

000000da <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  da:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  dc:	c4 e5       	ldi	r28, 0x54	; 84
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  de:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  e0:	03 c0       	rjmp	.+6      	; 0xe8 <__do_global_ctors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  e2:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  e4:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  e6:	b9 d2       	rcall	.+1394   	; 0x65a <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  e8:	c3 35       	cpi	r28, 0x53	; 83
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  ea:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  ec:	d1 f7       	brne	.-12     	; 0xe2 <__do_global_ctors+0x8>
  ee:	18 d2       	rcall	.+1072   	; 0x520 <main>
  f0:	ba c2       	rjmp	.+1396   	; 0x666 <_exit>

000000f2 <__bad_interrupt>:
__vector_1():
  f2:	86 cf       	rjmp	.-244    	; 0x0 <__vectors>

000000f4 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:34

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  f4:	cf 92       	push	r12
  f6:	df 92       	push	r13
  f8:	ef 92       	push	r14
  fa:	ff 92       	push	r15
  fc:	0f 93       	push	r16
  fe:	1f 93       	push	r17
 100:	cf 93       	push	r28
 102:	df 93       	push	r29
 104:	6c 01       	movw	r12, r24
 106:	eb 01       	movw	r28, r22
 108:	7b 01       	movw	r14, r22
 10a:	e4 0e       	add	r14, r20
 10c:	f5 1e       	adc	r15, r21
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:35
  size_t n = 0;
 10e:	10 e0       	ldi	r17, 0x00	; 0
 110:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:36
  while (size--) {
 112:	ce 15       	cp	r28, r14
 114:	df 05       	cpc	r29, r15
 116:	61 f0       	breq	.+24     	; 0x130 <Print::write(unsigned char const*, unsigned int)+0x3c>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:37
    n += write(*buffer++);
 118:	69 91       	ld	r22, Y+
 11a:	d6 01       	movw	r26, r12
 11c:	ed 91       	ld	r30, X+
 11e:	fc 91       	ld	r31, X
 120:	01 90       	ld	r0, Z+
 122:	f0 81       	ld	r31, Z
 124:	e0 2d       	mov	r30, r0
 126:	c6 01       	movw	r24, r12
 128:	09 95       	icall
 12a:	08 0f       	add	r16, r24
 12c:	19 1f       	adc	r17, r25
 12e:	f1 cf       	rjmp	.-30     	; 0x112 <Print::write(unsigned char const*, unsigned int)+0x1e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:40
  }
  return n;
}
 130:	c8 01       	movw	r24, r16
 132:	df 91       	pop	r29
 134:	cf 91       	pop	r28
 136:	1f 91       	pop	r17
 138:	0f 91       	pop	r16
 13a:	ff 90       	pop	r15
 13c:	ef 90       	pop	r14
 13e:	df 90       	pop	r13
 140:	cf 90       	pop	r12
 142:	08 95       	ret

00000144 <micros>:
micros():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:187
}

unsigned long micros()
{
  unsigned long m;
  uint8_t oldSREG = SREG, t;
 144:	3f b7       	in	r19, 0x3f	; 63
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:189

  cli();
 146:	f8 94       	cli
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:190
  m = millis_timer_overflow_count;
 148:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <millis_timer_overflow_count>
 14c:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <millis_timer_overflow_count+0x1>
 150:	a0 91 8c 00 	lds	r26, 0x008C	; 0x80008c <millis_timer_overflow_count+0x2>
 154:	b0 91 8d 00 	lds	r27, 0x008D	; 0x80008d <millis_timer_overflow_count+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:192
#if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
  t = TCNT0;
 158:	22 b7       	in	r18, 0x32	; 50
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:207

#if defined(TIFR0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR0 & _BV(TOV0)) && (t < 255))
    m++;
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR & _BV(TOV0)) && (t < 255))
 15a:	08 b6       	in	r0, 0x38	; 56
 15c:	01 fe       	sbrs	r0, 1
 15e:	05 c0       	rjmp	.+10     	; 0x16a <micros+0x26>
 160:	2f 3f       	cpi	r18, 0xFF	; 255
 162:	19 f0       	breq	.+6      	; 0x16a <micros+0x26>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:208
    m++;
 164:	01 96       	adiw	r24, 0x01	; 1
 166:	a1 1d       	adc	r26, r1
 168:	b1 1d       	adc	r27, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:217
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 1)
  if ((TIFR & _BV(TOV1)) && (t < 255))
    m++;
#endif

  SREG = oldSREG;
 16a:	3f bf       	out	0x3f, r19	; 63
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:224

#if F_CPU < 1000000L
  return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
#else
#if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 ) // Can we just do it the naive way? If so great!
  return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
 16c:	ba 2f       	mov	r27, r26
 16e:	a9 2f       	mov	r26, r25
 170:	98 2f       	mov	r25, r24
 172:	88 27       	eor	r24, r24
 174:	bc 01       	movw	r22, r24
 176:	cd 01       	movw	r24, r26
 178:	62 0f       	add	r22, r18
 17a:	71 1d       	adc	r23, r1
 17c:	81 1d       	adc	r24, r1
 17e:	91 1d       	adc	r25, r1
 180:	43 e0       	ldi	r20, 0x03	; 3
 182:	66 0f       	add	r22, r22
 184:	77 1f       	adc	r23, r23
 186:	88 1f       	adc	r24, r24
 188:	99 1f       	adc	r25, r25
 18a:	4a 95       	dec	r20
 18c:	d1 f7       	brne	.-12     	; 0x182 <micros+0x3e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:267
  //the high part gets divided by cCPuS then multiplied by the prescaler. Then take the low 8 bits plus the high part modulo-cCPuS to correct for the division, then multiply that by the prescaler value first before dividing by cCPuS, and finally add the two together.
  //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
  return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
#endif
#endif
}
 18e:	08 95       	ret

00000190 <ssd1306_send_stop()>:
ssd1306_send_stop():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:69
static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
}

static void ssd1306_send_stop(void) {
	wireEndTransmissionFn();
 190:	e0 91 7f 00 	lds	r30, 0x007F	; 0x80007f <wireEndTransmissionFn>
 194:	f0 91 80 00 	lds	r31, 0x0080	; 0x800080 <wireEndTransmissionFn+0x1>
 198:	09 94       	ijmp

0000019a <ssd1306_send_byte(unsigned char)>:
ssd1306_send_byte():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:65
static void ssd1306_send_start(uint8_t ssd1306_i2c_address) {
	wireBeginTransmissionFn(ssd1306_i2c_address);
}

static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
 19a:	e0 91 7d 00 	lds	r30, 0x007D	; 0x80007d <wireWriteFn>
 19e:	f0 91 7e 00 	lds	r31, 0x007E	; 0x80007e <wireWriteFn+0x1>
 1a2:	09 94       	ijmp

000001a4 <ssd1306_send_data_start()>:
ssd1306_send_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:61
static void ssd1306_begin(void) {
	wireBeginFn();
}

static void ssd1306_send_start(uint8_t ssd1306_i2c_address) {
	wireBeginTransmissionFn(ssd1306_i2c_address);
 1a4:	e0 91 81 00 	lds	r30, 0x0081	; 0x800081 <wireBeginTransmissionFn>
 1a8:	f0 91 82 00 	lds	r31, 0x0082	; 0x800082 <wireBeginTransmissionFn+0x1>
 1ac:	80 91 83 00 	lds	r24, 0x0083	; 0x800083 <i2c_address>
 1b0:	09 95       	icall
ssd1306_send_data_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:79
	ssd1306_send_byte(SSD1306_COMMAND);
}

static void ssd1306_send_data_start(void) {
	ssd1306_send_start(i2c_address);
	ssd1306_send_byte(SSD1306_DATA);
 1b2:	80 e4       	ldi	r24, 0x40	; 64
 1b4:	f2 cf       	rjmp	.-28     	; 0x19a <ssd1306_send_byte(unsigned char)>

000001b6 <ssd1306_send_data_byte(unsigned char)>:
ssd1306_send_data_byte():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:90
		ssd1306_send_command_start();
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_data_byte(uint8_t byte) {
 1b6:	cf 93       	push	r28
 1b8:	c8 2f       	mov	r28, r24
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:91
	if (ssd1306_send_byte(byte) == 0) {
 1ba:	ef df       	rcall	.-34     	; 0x19a <ssd1306_send_byte(unsigned char)>
 1bc:	81 11       	cpse	r24, r1
 1be:	05 c0       	rjmp	.+10     	; 0x1ca <ssd1306_send_data_byte(unsigned char)+0x14>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:92
		ssd1306_send_stop();
 1c0:	e7 df       	rcall	.-50     	; 0x190 <ssd1306_send_stop()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:93
		ssd1306_send_data_start();
 1c2:	f0 df       	rcall	.-32     	; 0x1a4 <ssd1306_send_data_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:94
		ssd1306_send_byte(byte);
 1c4:	8c 2f       	mov	r24, r28
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:96
	}
}
 1c6:	cf 91       	pop	r28
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:94

static void ssd1306_send_data_byte(uint8_t byte) {
	if (ssd1306_send_byte(byte) == 0) {
		ssd1306_send_stop();
		ssd1306_send_data_start();
		ssd1306_send_byte(byte);
 1c8:	e8 cf       	rjmp	.-48     	; 0x19a <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:96
	}
}
 1ca:	cf 91       	pop	r28
 1cc:	08 95       	ret

000001ce <ssd1306_send_command_start()>:
ssd1306_send_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:61
static void ssd1306_begin(void) {
	wireBeginFn();
}

static void ssd1306_send_start(uint8_t ssd1306_i2c_address) {
	wireBeginTransmissionFn(ssd1306_i2c_address);
 1ce:	e0 91 81 00 	lds	r30, 0x0081	; 0x800081 <wireBeginTransmissionFn>
 1d2:	f0 91 82 00 	lds	r31, 0x0082	; 0x800082 <wireBeginTransmissionFn+0x1>
 1d6:	80 91 83 00 	lds	r24, 0x0083	; 0x800083 <i2c_address>
 1da:	09 95       	icall
ssd1306_send_command_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:74
	wireEndTransmissionFn();
}

static void ssd1306_send_command_start(void) {
	ssd1306_send_start(i2c_address);
	ssd1306_send_byte(SSD1306_COMMAND);
 1dc:	80 e0       	ldi	r24, 0x00	; 0
 1de:	dd cf       	rjmp	.-70     	; 0x19a <ssd1306_send_byte(unsigned char)>

000001e0 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.11]>:
setCursor():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:168

void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
 1e0:	1f 93       	push	r17
 1e2:	cf 93       	push	r28
 1e4:	df 93       	push	r29
 1e6:	c8 2f       	mov	r28, r24
 1e8:	16 2f       	mov	r17, r22
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:169
	ssd1306_send_command3(renderingFrame | (y & 0x07), 0x10 | ((x & 0xf0) >> 4), x & 0x0f);
 1ea:	d6 2f       	mov	r29, r22
 1ec:	d7 70       	andi	r29, 0x07	; 7
 1ee:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <renderingFrame>
 1f2:	d8 2b       	or	r29, r24
ssd1306_send_command3():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:112
	ssd1306_send_byte(command2);
	ssd1306_send_stop();
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
 1f4:	ec df       	rcall	.-40     	; 0x1ce <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:113
	ssd1306_send_byte(command1);
 1f6:	8d 2f       	mov	r24, r29
 1f8:	d0 df       	rcall	.-96     	; 0x19a <ssd1306_send_byte(unsigned char)>
setCursor():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:169
void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | (y & 0x07), 0x10 | ((x & 0xf0) >> 4), x & 0x0f);
 1fa:	8c 2f       	mov	r24, r28
 1fc:	82 95       	swap	r24
 1fe:	8f 70       	andi	r24, 0x0F	; 15
ssd1306_send_command3():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:114
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
	ssd1306_send_byte(command1);
	ssd1306_send_byte(command2);
 200:	80 61       	ori	r24, 0x10	; 16
 202:	cb df       	rcall	.-106    	; 0x19a <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:115
	ssd1306_send_byte(command3);
 204:	8c 2f       	mov	r24, r28
 206:	8f 70       	andi	r24, 0x0F	; 15
 208:	c8 df       	rcall	.-112    	; 0x19a <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:116
	ssd1306_send_stop();
 20a:	c2 df       	rcall	.-124    	; 0x190 <ssd1306_send_stop()>
setCursor():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:170
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | (y & 0x07), 0x10 | ((x & 0xf0) >> 4), x & 0x0f);
	oledX = x;
 20c:	c0 93 95 00 	sts	0x0095, r28	; 0x800095 <oledX>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:171
	oledY = y;
 210:	10 93 94 00 	sts	0x0094, r17	; 0x800094 <oledY>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:172
}
 214:	df 91       	pop	r29
 216:	cf 91       	pop	r28
 218:	1f 91       	pop	r17
 21a:	08 95       	ret

0000021c <SSD1306Device::fill(unsigned char) [clone .constprop.8]>:
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:178

void SSD1306Device::clear(void) {
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
 21c:	1f 93       	push	r17
 21e:	cf 93       	push	r28
 220:	df 93       	push	r29
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:179
	for (uint8_t m = 0; m < SSD1306_PAGES; m++) {
 222:	c0 e0       	ldi	r28, 0x00	; 0
fillToEOL():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:261
void SSD1306Device::clearToEOL(void) {
	fillToEOL(0x00);
}

void SSD1306Device::fillToEOL(uint8_t fill) {
	fillLength(fill, 128 - oledX);
 224:	10 e8       	ldi	r17, 0x80	; 128
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:180
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < SSD1306_PAGES; m++) {
		setCursor(0, m);
 226:	6c 2f       	mov	r22, r28
 228:	80 e0       	ldi	r24, 0x00	; 0
 22a:	da df       	rcall	.-76     	; 0x1e0 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.11]>
fillToEOL():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:261
void SSD1306Device::clearToEOL(void) {
	fillToEOL(0x00);
}

void SSD1306Device::fillToEOL(uint8_t fill) {
	fillLength(fill, 128 - oledX);
 22c:	80 91 95 00 	lds	r24, 0x0095	; 0x800095 <oledX>
 230:	d1 2f       	mov	r29, r17
 232:	d8 1b       	sub	r29, r24
fillLength():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:265
}

void SSD1306Device::fillLength(uint8_t fill, uint8_t length) {
	oledX += length;
 234:	10 93 95 00 	sts	0x0095, r17	; 0x800095 <oledX>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:266
	ssd1306_send_data_start();
 238:	b5 df       	rcall	.-150    	; 0x1a4 <ssd1306_send_data_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:269
	do
	{
		ssd1306_send_data_byte(fill);
 23a:	80 e0       	ldi	r24, 0x00	; 0
 23c:	bc df       	rcall	.-136    	; 0x1b6 <ssd1306_send_data_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:271
	}
	while (--length);
 23e:	d1 50       	subi	r29, 0x01	; 1
 240:	e1 f7       	brne	.-8      	; 0x23a <SSD1306Device::fill(unsigned char) [clone .constprop.8]+0x1e>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:272
	ssd1306_send_stop();
 242:	a6 df       	rcall	.-180    	; 0x190 <ssd1306_send_stop()>
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:179
void SSD1306Device::clear(void) {
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < SSD1306_PAGES; m++) {
 244:	cf 5f       	subi	r28, 0xFF	; 255
 246:	c4 30       	cpi	r28, 0x04	; 4
 248:	71 f7       	brne	.-36     	; 0x226 <SSD1306Device::fill(unsigned char) [clone .constprop.8]+0xa>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:183
		setCursor(0, m);
		fillToEOL(fill);
	}
	setCursor(0, 0);
 24a:	60 e0       	ldi	r22, 0x00	; 0
 24c:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:184
}
 24e:	df 91       	pop	r29
 250:	cf 91       	pop	r28
 252:	1f 91       	pop	r17
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:183
void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < SSD1306_PAGES; m++) {
		setCursor(0, m);
		fillToEOL(fill);
	}
	setCursor(0, 0);
 254:	c5 cf       	rjmp	.-118    	; 0x1e0 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.11]>

00000256 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.0]>:
bitmap():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:243
	}
	while (--line);
	return 1;
}

void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
 256:	af 92       	push	r10
 258:	bf 92       	push	r11
 25a:	df 92       	push	r13
 25c:	ef 92       	push	r14
 25e:	ff 92       	push	r15
 260:	0f 93       	push	r16
 262:	1f 93       	push	r17
 264:	cf 93       	push	r28
 266:	df 93       	push	r29
 268:	08 2f       	mov	r16, r24
 26a:	cf e1       	ldi	r28, 0x1F	; 31
 26c:	c8 1b       	sub	r28, r24
 26e:	d0 e0       	ldi	r29, 0x00	; 0
 270:	21 96       	adiw	r28, 0x01	; 1
 272:	86 e2       	ldi	r24, 0x26	; 38
 274:	e8 2e       	mov	r14, r24
 276:	80 e0       	ldi	r24, 0x00	; 0
 278:	f8 2e       	mov	r15, r24
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:245
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y1; y++) {
 27a:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:246
		setCursor(x0,y);
 27c:	61 2f       	mov	r22, r17
 27e:	80 2f       	mov	r24, r16
 280:	af df       	rcall	.-162    	; 0x1e0 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.11]>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:247
		ssd1306_send_data_start();
 282:	90 df       	rcall	.-224    	; 0x1a4 <ssd1306_send_data_start()>
 284:	57 01       	movw	r10, r14
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:248
		for (uint8_t x = x0; x < x1; x++) {
 286:	d0 2e       	mov	r13, r16
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:249
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
 288:	f5 01       	movw	r30, r10
 28a:	84 91       	lpm	r24, Z
 28c:	94 df       	rcall	.-216    	; 0x1b6 <ssd1306_send_data_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:248
void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y1; y++) {
		setCursor(x0,y);
		ssd1306_send_data_start();
		for (uint8_t x = x0; x < x1; x++) {
 28e:	d3 94       	inc	r13
 290:	ff ef       	ldi	r31, 0xFF	; 255
 292:	af 1a       	sub	r10, r31
 294:	bf 0a       	sbc	r11, r31
 296:	80 e2       	ldi	r24, 0x20	; 32
 298:	d8 12       	cpse	r13, r24
 29a:	f6 cf       	rjmp	.-20     	; 0x288 <__stack+0x29>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:251
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
		}
		ssd1306_send_stop();
 29c:	79 df       	rcall	.-270    	; 0x190 <ssd1306_send_stop()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:245
	return 1;
}

void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y1; y++) {
 29e:	1f 5f       	subi	r17, 0xFF	; 255
 2a0:	ec 0e       	add	r14, r28
 2a2:	fd 1e       	adc	r15, r29
 2a4:	14 30       	cpi	r17, 0x04	; 4
 2a6:	51 f7       	brne	.-44     	; 0x27c <__stack+0x1d>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:253
		for (uint8_t x = x0; x < x1; x++) {
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
		}
		ssd1306_send_stop();
	}
	setCursor(0, 0);
 2a8:	60 e0       	ldi	r22, 0x00	; 0
 2aa:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:254
}
 2ac:	df 91       	pop	r29
 2ae:	cf 91       	pop	r28
 2b0:	1f 91       	pop	r17
 2b2:	0f 91       	pop	r16
 2b4:	ff 90       	pop	r15
 2b6:	ef 90       	pop	r14
 2b8:	df 90       	pop	r13
 2ba:	bf 90       	pop	r11
 2bc:	af 90       	pop	r10
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:253
		for (uint8_t x = x0; x < x1; x++) {
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
		}
		ssd1306_send_stop();
	}
	setCursor(0, 0);
 2be:	90 cf       	rjmp	.-224    	; 0x1e0 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.11]>

000002c0 <SSD1306Device::newLine(unsigned char)>:
newLine():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:187
	}
	setCursor(0, 0);
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
 2c0:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <oledY>
 2c4:	86 0f       	add	r24, r22
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:188
	if (oledY > SSD1306_PAGES - fontHeight) {
 2c6:	24 e0       	ldi	r18, 0x04	; 4
 2c8:	30 e0       	ldi	r19, 0x00	; 0
 2ca:	26 1b       	sub	r18, r22
 2cc:	31 09       	sbc	r19, r1
 2ce:	82 17       	cp	r24, r18
 2d0:	13 06       	cpc	r1, r19
 2d2:	09 f0       	breq	.+2      	; 0x2d6 <SSD1306Device::newLine(unsigned char)+0x16>
 2d4:	34 f4       	brge	.+12     	; 0x2e2 <SSD1306Device::newLine(unsigned char)+0x22>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:189
		oledY = SSD1306_PAGES - fontHeight;
 2d6:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <oledY>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:191
	}
	setCursor(0, oledY);
 2da:	60 91 94 00 	lds	r22, 0x0094	; 0x800094 <oledY>
 2de:	80 e0       	ldi	r24, 0x00	; 0
 2e0:	7f cf       	rjmp	.-258    	; 0x1e0 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.11]>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:189
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
	if (oledY > SSD1306_PAGES - fontHeight) {
		oledY = SSD1306_PAGES - fontHeight;
 2e2:	84 e0       	ldi	r24, 0x04	; 4
 2e4:	86 1b       	sub	r24, r22
 2e6:	f7 cf       	rjmp	.-18     	; 0x2d6 <SSD1306Device::newLine(unsigned char)+0x16>

000002e8 <SSD1306Device::write(unsigned char)>:
write():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:241
			}
		}
	}
	while (--line);
	return 1;
}
 2e8:	81 e0       	ldi	r24, 0x01	; 1
 2ea:	90 e0       	ldi	r25, 0x00	; 0
 2ec:	08 95       	ret

000002ee <tinywirem_write(unsigned char)>:
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:53
  USI_BufIdx = 0; 
  USI_Buf[USI_BufIdx] = (slaveAddr<<TWI_ADR_BITS) | USI_SEND; 
}

size_t USI_TWI::write(uint8_t data){ // buffers up data to send
  if (USI_BufIdx >= USI_BUF_SIZE-1) return 0;       // dont blow out the buffer
 2ee:	e0 91 7c 00 	lds	r30, 0x007C	; 0x80007c <USI_TWI::USI_BufIdx>
 2f2:	e1 31       	cpi	r30, 0x11	; 17
 2f4:	48 f4       	brcc	.+18     	; 0x308 <tinywirem_write(unsigned char)+0x1a>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:54
  USI_BufIdx++;                                   // inc for next byte in buffer
 2f6:	ef 5f       	subi	r30, 0xFF	; 255
 2f8:	e0 93 7c 00 	sts	0x007C, r30	; 0x80007c <USI_TWI::USI_BufIdx>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:55
  USI_Buf[USI_BufIdx] = data;
 2fc:	f0 e0       	ldi	r31, 0x00	; 0
 2fe:	e6 59       	subi	r30, 0x96	; 150
 300:	ff 4f       	sbci	r31, 0xFF	; 255
 302:	80 83       	st	Z, r24
tinywirem_write():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:56
  return 1;
 304:	81 e0       	ldi	r24, 0x01	; 1
 306:	08 95       	ret
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:53
  USI_BufIdx = 0; 
  USI_Buf[USI_BufIdx] = (slaveAddr<<TWI_ADR_BITS) | USI_SEND; 
}

size_t USI_TWI::write(uint8_t data){ // buffers up data to send
  if (USI_BufIdx >= USI_BUF_SIZE-1) return 0;       // dont blow out the buffer
 308:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:23
	TinyWireM.beginTransmission(i2c_address);
}

static bool tinywirem_write(uint8_t byte) {
	return TinyWireM.write(byte);
}
 30a:	08 95       	ret

0000030c <tinywirem_beginTransmission(unsigned char)>:
beginTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:48
void USI_TWI::begin(){ // initialize I2C lib
  USI_TWI_Master_Initialise();          
}

void USI_TWI::beginTransmission(uint8_t slaveAddr){ // setup address & write bit
  USI_BufIdx = 0; 
 30c:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <USI_TWI::USI_BufIdx>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:49
  USI_Buf[USI_BufIdx] = (slaveAddr<<TWI_ADR_BITS) | USI_SEND; 
 310:	88 0f       	add	r24, r24
 312:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__data_end>
tinywirem_beginTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:19
	TinyWireM.begin();
}

static void tinywirem_beginTransmission(uint8_t i2c_address) {
	TinyWireM.beginTransmission(i2c_address);
}
 316:	08 95       	ret

00000318 <tinywirem_begin()>:
USI_TWI_Master_Initialise():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:48
/*---------------------------------------------------------------
 USI TWI single master initialization function
---------------------------------------------------------------*/
void USI_TWI_Master_Initialise( void )
{
  PORT_USI |= (1<<PIN_USI_SDA);           // Enable pullup on SDA, to set high as released state.
 318:	c0 9a       	sbi	0x18, 0	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:49
  PORT_USI |= (1<<PIN_USI_SCL);           // Enable pullup on SCL, to set high as released state.
 31a:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:51
  
  DDR_USI  |= (1<<PIN_USI_SCL);           // Enable SCL as output.
 31c:	ba 9a       	sbi	0x17, 2	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:52
  DDR_USI  |= (1<<PIN_USI_SDA);           // Enable SDA as output.
 31e:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:54
  
  USIDR    =  0xFF;                       // Preload dataregister with "released level" data.
 320:	8f ef       	ldi	r24, 0xFF	; 255
 322:	8f b9       	out	0x0f, r24	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:55
  USICR    =  (0<<USISIE)|(0<<USIOIE)|                            // Disable Interrupts.
 324:	8a e2       	ldi	r24, 0x2A	; 42
 326:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:59
              (1<<USIWM1)|(0<<USIWM0)|                            // Set USI in Two-wire mode.
              (1<<USICS1)|(0<<USICS0)|(1<<USICLK)|                // Software stobe as counter clock source
              (0<<USITC);
  USISR   =   (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)|      // Clear flags,
 328:	80 ef       	ldi	r24, 0xF0	; 240
 32a:	8e b9       	out	0x0e, r24	; 14
tinywirem_begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:15

#include <TinyWireM.h>  // Version with buffer bugfix: https://github.com/adafruit/TinyWireM

static void tinywirem_begin(void) {
	TinyWireM.begin();
}
 32c:	08 95       	ret

0000032e <USI_TWI_Master_Start()>:
USI_TWI_Master_Start():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:291
 Function for generating a TWI Start Condition. 
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Start( void )
{
/* Release SCL to ensure that (repeated) Start can be performed */
  PORT_USI |= (1<<PIN_USI_SCL);                     // Release SCL.
 32e:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:292
  while( !(PORT_USI & (1<<PIN_USI_SCL)) );          // Verify that SCL becomes high.
 330:	c2 9b       	sbis	0x18, 2	; 24
 332:	fe cf       	rjmp	.-4      	; 0x330 <USI_TWI_Master_Start()+0x2>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 334:	8d e0       	ldi	r24, 0x0D	; 13
 336:	8a 95       	dec	r24
 338:	f1 f7       	brne	.-4      	; 0x336 <USI_TWI_Master_Start()+0x8>
 33a:	00 00       	nop
USI_TWI_Master_Start():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:296
  _delay_us(T2_TWI);

/* Generate Start Condition */
  PORT_USI &= ~(1<<PIN_USI_SDA);                    // Force SDA LOW.
 33c:	c0 98       	cbi	0x18, 0	; 24
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 33e:	8a e0       	ldi	r24, 0x0A	; 10
 340:	8a 95       	dec	r24
 342:	f1 f7       	brne	.-4      	; 0x340 <USI_TWI_Master_Start()+0x12>
 344:	00 c0       	rjmp	.+0      	; 0x346 <USI_TWI_Master_Start()+0x18>
USI_TWI_Master_Start():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:298
	_delay_us(T4_TWI);                         
  PORT_USI &= ~(1<<PIN_USI_SCL);                    // Pull SCL LOW.
 346:	c2 98       	cbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:299
  PORT_USI |= (1<<PIN_USI_SDA);                     // Release SDA.
 348:	c0 9a       	sbi	0x18, 0	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:302

#ifdef SIGNAL_VERIFY
  if( !(USISR & (1<<USISIF)) )
 34a:	77 99       	sbic	0x0e, 7	; 14
 34c:	05 c0       	rjmp	.+10     	; 0x358 <USI_TWI_Master_Start()+0x2a>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:304
  {
    USI_TWI_state.errorState = USI_TWI_MISSING_START_CON;  
 34e:	83 e0       	ldi	r24, 0x03	; 3
 350:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:305
    return (FALSE);
 354:	80 e0       	ldi	r24, 0x00	; 0
 356:	08 95       	ret
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:308
  }
#endif
  return (TRUE);
 358:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:309
}
 35a:	08 95       	ret

0000035c <USI_TWI_Master_Transfer(unsigned char)>:
USI_TWI_Master_Transfer():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:263
 Data to be sent has to be placed into the USIDR prior to calling
 this function. Data read, will be return'ed from the function.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Transfer( unsigned char temp )
{
  USISR = temp;                                     // Set USISR according to temp.
 35c:	8e b9       	out	0x0e, r24	; 14
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:272
           (1<<USICS1)|(0<<USICS0)|(1<<USICLK)|     // Software clock strobe as source.
           (1<<USITC);                              // Toggle Clock Port.
  do
  { 
	_delay_us(T2_TWI);
    USICR = temp;                          // Generate positve SCL edge.
 35e:	8b e2       	ldi	r24, 0x2B	; 43
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 360:	9d e0       	ldi	r25, 0x0D	; 13
 362:	9a 95       	dec	r25
 364:	f1 f7       	brne	.-4      	; 0x362 <USI_TWI_Master_Transfer(unsigned char)+0x6>
 366:	00 00       	nop
USI_TWI_Master_Transfer():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:272
 368:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:273
    while( !(PIN_USI & (1<<PIN_USI_SCL)) );// Wait for SCL to go high.
 36a:	b2 9b       	sbis	0x16, 2	; 22
 36c:	fe cf       	rjmp	.-4      	; 0x36a <USI_TWI_Master_Transfer(unsigned char)+0xe>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 36e:	9a e0       	ldi	r25, 0x0A	; 10
 370:	9a 95       	dec	r25
 372:	f1 f7       	brne	.-4      	; 0x370 <USI_TWI_Master_Transfer(unsigned char)+0x14>
 374:	00 c0       	rjmp	.+0      	; 0x376 <USI_TWI_Master_Transfer(unsigned char)+0x1a>
USI_TWI_Master_Transfer():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:275
	_delay_us(T4_TWI);
    USICR = temp;                          // Generate negative SCL edge.
 376:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:276
  }while( !(USISR & (1<<USIOIF)) );        // Check for transfer complete.
 378:	76 9b       	sbis	0x0e, 6	; 14
 37a:	f2 cf       	rjmp	.-28     	; 0x360 <USI_TWI_Master_Transfer(unsigned char)+0x4>
_delay_us():
 37c:	8d e0       	ldi	r24, 0x0D	; 13
 37e:	8a 95       	dec	r24
 380:	f1 f7       	brne	.-4      	; 0x37e <USI_TWI_Master_Transfer(unsigned char)+0x22>
 382:	00 00       	nop
USI_TWI_Master_Transfer():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:279
  
	_delay_us(T2_TWI);
  temp  = USIDR;                           // Read out data.
 384:	8f b1       	in	r24, 0x0f	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:280
  USIDR = 0xFF;                            // Release SDA.
 386:	9f ef       	ldi	r25, 0xFF	; 255
 388:	9f b9       	out	0x0f, r25	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:281
  DDR_USI |= (1<<PIN_USI_SDA);             // Enable SDA as output.
 38a:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:284

  return temp;                             // Return the data from the USIDR
}
 38c:	08 95       	ret

0000038e <tinywirem_endTransmission()>:
tinywirem_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:25

static bool tinywirem_write(uint8_t byte) {
	return TinyWireM.write(byte);
}

static void tinywirem_endTransmission(void) {
 38e:	cf 92       	push	r12
 390:	df 92       	push	r13
 392:	ef 92       	push	r14
 394:	ff 92       	push	r15
 396:	0f 93       	push	r16
 398:	1f 93       	push	r17
 39a:	cf 93       	push	r28
 39c:	df 93       	push	r29
endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:66
}

uint8_t USI_TWI::endTransmission(uint8_t stop){ // actually sends the buffer
  bool xferOK = false;
  uint8_t errorCode = 0;
  xferOK = USI_TWI_Start_Read_Write(USI_Buf,USI_BufIdx+1); // core func that does the work
 39e:	00 91 7c 00 	lds	r16, 0x007C	; 0x80007c <USI_TWI::USI_BufIdx>
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:140
	unsigned char savedMsgSize; 

//This clear must be done before calling this function so that memReadMode can be specified.
//  USI_TWI_state.errorState = 0;				// Clears all mode bits also

  USI_TWI_state.addressMode = TRUE;			// Always true for first byte
 3a2:	81 e0       	ldi	r24, 0x01	; 1
 3a4:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:173
    USI_TWI_state.errorState = USI_TWI_UE_DATA_COL;
    return (FALSE);
  }
#endif

  if ( !(*msg & (1<<TWI_READ_BIT)) )                // The LSB in the address byte determines if is a masterRead or masterWrite operation.
 3a8:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <__data_end>
 3ac:	80 fd       	sbrc	r24, 0
 3ae:	03 c0       	rjmp	.+6      	; 0x3b6 <tinywirem_endTransmission()+0x28>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:175
  {
    USI_TWI_state.masterWriteDataMode = TRUE;
 3b0:	83 e0       	ldi	r24, 0x03	; 3
 3b2:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:184
//	{
		savedMsg = msg;
		savedMsgSize = msgSize;
//	}

	if ( !USI_TWI_Master_Start( ))
 3b6:	bb df       	rcall	.-138    	; 0x32e <USI_TWI_Master_Start()>
 3b8:	88 23       	and	r24, r24
 3ba:	11 f1       	breq	.+68     	; 0x400 <__LOCK_REGION_LENGTH__>
endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:66
 3bc:	0f 5f       	subi	r16, 0xFF	; 255
 3be:	10 2f       	mov	r17, r16
 3c0:	ca e6       	ldi	r28, 0x6A	; 106
 3c2:	d0 e0       	ldi	r29, 0x00	; 0
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:240
      *(msg++)  = USI_TWI_Master_Transfer( tempUSISR_8bit );

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if( msgSize == 1)                            // If transmission of last byte was performed.
      {
        USIDR = 0xFF;                              // Load NACK to confirm End Of Transmission.
 3c4:	dd 24       	eor	r13, r13
 3c6:	da 94       	dec	r13
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:216
	  if ((!USI_TWI_state.addressMode) && USI_TWI_state.memReadMode)// means memory start address has been written
	  {
		msg = savedMsg;					// start at slave address again
		*(msg) |= (TRUE<<TWI_READ_BIT);  // set the Read Bit on Slave address
		USI_TWI_state.errorState = 0;
		USI_TWI_state.addressMode = TRUE;	// Now set up for the Read cycle
 3c8:	cc 24       	eor	r12, r12
 3ca:	c3 94       	inc	r12
 3cc:	7e 01       	movw	r14, r28
 3ce:	8f ef       	ldi	r24, 0xFF	; 255
 3d0:	e8 1a       	sub	r14, r24
 3d2:	f8 0a       	sbc	r15, r24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:193

/*Write address and Read/Write data */
  do
  {
    /* If masterWrite cycle (or inital address tranmission)*/
    if (USI_TWI_state.addressMode || USI_TWI_state.masterWriteDataMode)
 3d4:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <USI_TWI_state>
 3d8:	83 70       	andi	r24, 0x03	; 3
 3da:	09 f4       	brne	.+2      	; 0x3de <tinywirem_endTransmission()+0x50>
 3dc:	47 c0       	rjmp	.+142    	; 0x46c <__LOCK_REGION_LENGTH__+0x6c>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:196
    {
      /* Write a byte */
      PORT_USI &= ~(1<<PIN_USI_SCL);                // Pull SCL LOW.
 3de:	c2 98       	cbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:197
      USIDR     = *(msg++);                        // Setup data.
 3e0:	88 81       	ld	r24, Y
 3e2:	8f b9       	out	0x0f, r24	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:198
      USI_TWI_Master_Transfer( tempUSISR_8bit );    // Send 8 bits on bus.
 3e4:	80 ef       	ldi	r24, 0xF0	; 240
 3e6:	ba df       	rcall	.-140    	; 0x35c <USI_TWI_Master_Transfer(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:201
      
      /* Clock and verify (N)ACK from slave */
      DDR_USI  &= ~(1<<PIN_USI_SDA);                // Enable SDA as input.
 3e8:	b8 98       	cbi	0x17, 0	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:202
      if( USI_TWI_Master_Transfer( tempUSISR_1bit ) & (1<<TWI_NACK_BIT) ) 
 3ea:	8e ef       	ldi	r24, 0xFE	; 254
 3ec:	b7 df       	rcall	.-146    	; 0x35c <USI_TWI_Master_Transfer(unsigned char)>
 3ee:	90 91 84 00 	lds	r25, 0x0084	; 0x800084 <USI_TWI_state>
 3f2:	80 ff       	sbrs	r24, 0
 3f4:	10 c0       	rjmp	.+32     	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:205
      {
        if ( USI_TWI_state.addressMode )
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 3f6:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:204
      
      /* Clock and verify (N)ACK from slave */
      DDR_USI  &= ~(1<<PIN_USI_SDA);                // Enable SDA as input.
      if( USI_TWI_Master_Transfer( tempUSISR_1bit ) & (1<<TWI_NACK_BIT) ) 
      {
        if ( USI_TWI_state.addressMode )
 3f8:	90 ff       	sbrs	r25, 0
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:207
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
 3fa:	82 e0       	ldi	r24, 0x02	; 2
 3fc:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:67
  USI_BufIdx = 0;
 400:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <USI_TWI::USI_BufIdx>
tinywirem_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:27
	TinyWireM.endTransmission();
}
 404:	df 91       	pop	r29
 406:	cf 91       	pop	r28
 408:	1f 91       	pop	r17
 40a:	0f 91       	pop	r16
 40c:	ff 90       	pop	r15
 40e:	ef 90       	pop	r14
 410:	df 90       	pop	r13
 412:	cf 90       	pop	r12
 414:	08 95       	ret
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:211
        return (FALSE);
      }
	  
	  if ((!USI_TWI_state.addressMode) && USI_TWI_state.memReadMode)// means memory start address has been written
 416:	89 2f       	mov	r24, r25
 418:	85 70       	andi	r24, 0x05	; 5
 41a:	84 30       	cpi	r24, 0x04	; 4
 41c:	61 f4       	brne	.+24     	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:214
	  {
		msg = savedMsg;					// start at slave address again
		*(msg) |= (TRUE<<TWI_READ_BIT);  // set the Read Bit on Slave address
 41e:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <__data_end>
 422:	81 60       	ori	r24, 0x01	; 1
 424:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__data_end>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:216
		USI_TWI_state.errorState = 0;
		USI_TWI_state.addressMode = TRUE;	// Now set up for the Read cycle
 428:	c0 92 84 00 	sts	0x0084, r12	; 0x800084 <USI_TWI_state>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:219
		msgSize = savedMsgSize;				// Set byte count correctly
		// NOte that the length should be Slave adrs byte + # bytes to read + 1 (gets decremented below)
		if ( !USI_TWI_Master_Start( ))
 42c:	80 df       	rcall	.-256    	; 0x32e <USI_TWI_Master_Start()>
 42e:	81 11       	cpse	r24, r1
 430:	29 c0       	rjmp	.+82     	; 0x484 <__LOCK_REGION_LENGTH__+0x84>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:221
		{
			USI_TWI_state.errorState = USI_TWI_BAD_MEM_READ;
 432:	8a e0       	ldi	r24, 0x0A	; 10
 434:	e3 cf       	rjmp	.-58     	; 0x3fc <tinywirem_endTransmission()+0x6e>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:227
			return (FALSE);                           // Send a START condition on the TWI bus.
		}
	  }
	  else
	  {
		USI_TWI_state.addressMode = FALSE;            // Only perform address transmission once.
 436:	9e 7f       	andi	r25, 0xFE	; 254
 438:	90 93 84 00 	sts	0x0084, r25	; 0x800084 <USI_TWI_state>
tinywirem_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:235
    /* Else masterRead cycle*/
    else
    {
      /* Read a data byte */
      DDR_USI   &= ~(1<<PIN_USI_SDA);               // Enable SDA as input.
      *(msg++)  = USI_TWI_Master_Transfer( tempUSISR_8bit );
 43c:	e7 01       	movw	r28, r14
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:248
      {
        USIDR = 0x00;                              // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer( tempUSISR_1bit );   // Generate ACK/NACK.
    }
  }while( --msgSize) ;                             // Until all data sent/received.
 43e:	11 50       	subi	r17, 0x01	; 1
 440:	29 f6       	brne	.-118    	; 0x3cc <tinywirem_endTransmission()+0x3e>
endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:67
 442:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <USI_TWI::USI_BufIdx>
USI_TWI_Master_Stop():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:316
 Function for generating a TWI Stop Condition. Used to release 
 the TWI bus.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Stop( void )
{
  PORT_USI &= ~(1<<PIN_USI_SDA);           // Pull SDA low.
 446:	c0 98       	cbi	0x18, 0	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:317
  PORT_USI |= (1<<PIN_USI_SCL);            // Release SCL.
 448:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:318
  while( !(PIN_USI & (1<<PIN_USI_SCL)) );  // Wait for SCL to go high.  
 44a:	b2 9b       	sbis	0x16, 2	; 22
 44c:	fe cf       	rjmp	.-4      	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 44e:	8a e0       	ldi	r24, 0x0A	; 10
 450:	8a 95       	dec	r24
 452:	f1 f7       	brne	.-4      	; 0x450 <__LOCK_REGION_LENGTH__+0x50>
 454:	00 c0       	rjmp	.+0      	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
USI_TWI_Master_Stop():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:320
	_delay_us(T4_TWI);
  PORT_USI |= (1<<PIN_USI_SDA);            // Release SDA.
 456:	c0 9a       	sbi	0x18, 0	; 24
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 458:	8d e0       	ldi	r24, 0x0D	; 13
 45a:	8a 95       	dec	r24
 45c:	f1 f7       	brne	.-4      	; 0x45a <__LOCK_REGION_LENGTH__+0x5a>
 45e:	00 00       	nop
USI_TWI_Master_Stop():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:324
	_delay_us(T2_TWI);
  
#ifdef SIGNAL_VERIFY
  if( !(USISR & (1<<USIPF)) )
 460:	75 99       	sbic	0x0e, 5	; 14
 462:	d0 cf       	rjmp	.-96     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:326
  {
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;    
 464:	84 e0       	ldi	r24, 0x04	; 4
 466:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
 46a:	cc cf       	rjmp	.-104    	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:234
    }
    /* Else masterRead cycle*/
    else
    {
      /* Read a data byte */
      DDR_USI   &= ~(1<<PIN_USI_SDA);               // Enable SDA as input.
 46c:	b8 98       	cbi	0x17, 0	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:235
      *(msg++)  = USI_TWI_Master_Transfer( tempUSISR_8bit );
 46e:	80 ef       	ldi	r24, 0xF0	; 240
 470:	75 df       	rcall	.-278    	; 0x35c <USI_TWI_Master_Transfer(unsigned char)>
 472:	88 83       	st	Y, r24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:238

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if( msgSize == 1)                            // If transmission of last byte was performed.
 474:	11 30       	cpi	r17, 0x01	; 1
 476:	21 f4       	brne	.+8      	; 0x480 <__LOCK_REGION_LENGTH__+0x80>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:240
      {
        USIDR = 0xFF;                              // Load NACK to confirm End Of Transmission.
 478:	df b8       	out	0x0f, r13	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:246
      }
      else
      {
        USIDR = 0x00;                              // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer( tempUSISR_1bit );   // Generate ACK/NACK.
 47a:	8e ef       	ldi	r24, 0xFE	; 254
 47c:	6f df       	rcall	.-290    	; 0x35c <USI_TWI_Master_Transfer(unsigned char)>
 47e:	de cf       	rjmp	.-68     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:244
      {
        USIDR = 0xFF;                              // Load NACK to confirm End Of Transmission.
      }
      else
      {
        USIDR = 0x00;                              // Load ACK. Set data register bit 7 (output for SDA) low.
 480:	1f b8       	out	0x0f, r1	; 15
 482:	fb cf       	rjmp	.-10     	; 0x47a <__LOCK_REGION_LENGTH__+0x7a>
tinywirem_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:217
	  {
		msg = savedMsg;					// start at slave address again
		*(msg) |= (TRUE<<TWI_READ_BIT);  // set the Read Bit on Slave address
		USI_TWI_state.errorState = 0;
		USI_TWI_state.addressMode = TRUE;	// Now set up for the Read cycle
		msgSize = savedMsgSize;				// Set byte count correctly
 484:	10 2f       	mov	r17, r16
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:213
        return (FALSE);
      }
	  
	  if ((!USI_TWI_state.addressMode) && USI_TWI_state.memReadMode)// means memory start address has been written
	  {
		msg = savedMsg;					// start at slave address again
 486:	ca e6       	ldi	r28, 0x6A	; 106
 488:	d0 e0       	ldi	r29, 0x00	; 0
 48a:	d9 cf       	rjmp	.-78     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>

0000048c <__vector_5>:
__vector_5():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:130
#else

#error Millis() timer not defined!

#endif
{
 48c:	1f 92       	push	r1
 48e:	0f 92       	push	r0
 490:	0f b6       	in	r0, 0x3f	; 63
 492:	0f 92       	push	r0
 494:	11 24       	eor	r1, r1
 496:	2f 93       	push	r18
 498:	3f 93       	push	r19
 49a:	8f 93       	push	r24
 49c:	9f 93       	push	r25
 49e:	af 93       	push	r26
 4a0:	bf 93       	push	r27
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:133
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
 4a2:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <millis_timer_millis>
 4a6:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <millis_timer_millis+0x1>
 4aa:	a0 91 88 00 	lds	r26, 0x0088	; 0x800088 <millis_timer_millis+0x2>
 4ae:	b0 91 89 00 	lds	r27, 0x0089	; 0x800089 <millis_timer_millis+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:134
  unsigned char f = millis_timer_fract;
 4b2:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <millis_timer_fract>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:146
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
 4b6:	26 e0       	ldi	r18, 0x06	; 6
 4b8:	23 0f       	add	r18, r19
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:148

  if (f >= FRACT_MAX)
 4ba:	2d 37       	cpi	r18, 0x7D	; 125
 4bc:	68 f1       	brcs	.+90     	; 0x518 <__vector_5+0x8c>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:150
  {
    f -= FRACT_MAX;
 4be:	29 e8       	ldi	r18, 0x89	; 137
 4c0:	23 0f       	add	r18, r19
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:152
  m += 1;
    m += MILLIS_INC;
 4c2:	03 96       	adiw	r24, 0x03	; 3
 4c4:	a1 1d       	adc	r26, r1
 4c6:	b1 1d       	adc	r27, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:159
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
 4c8:	20 93 85 00 	sts	0x0085, r18	; 0x800085 <millis_timer_fract>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:160
  millis_timer_millis = m;
 4cc:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <millis_timer_millis>
 4d0:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <millis_timer_millis+0x1>
 4d4:	a0 93 88 00 	sts	0x0088, r26	; 0x800088 <millis_timer_millis+0x2>
 4d8:	b0 93 89 00 	sts	0x0089, r27	; 0x800089 <millis_timer_millis+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:161
  millis_timer_overflow_count++;
 4dc:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <millis_timer_overflow_count>
 4e0:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <millis_timer_overflow_count+0x1>
 4e4:	a0 91 8c 00 	lds	r26, 0x008C	; 0x80008c <millis_timer_overflow_count+0x2>
 4e8:	b0 91 8d 00 	lds	r27, 0x008D	; 0x80008d <millis_timer_overflow_count+0x3>
 4ec:	01 96       	adiw	r24, 0x01	; 1
 4ee:	a1 1d       	adc	r26, r1
 4f0:	b1 1d       	adc	r27, r1
 4f2:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <millis_timer_overflow_count>
 4f6:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <millis_timer_overflow_count+0x1>
 4fa:	a0 93 8c 00 	sts	0x008C, r26	; 0x80008c <millis_timer_overflow_count+0x2>
 4fe:	b0 93 8d 00 	sts	0x008D, r27	; 0x80008d <millis_timer_overflow_count+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:168

//MICROSECONDS_PER_MILLIS_OVERFLOW=2048
//MILLIS_INC=2
//FRACT_INC=6
//FRACT_MAX=125
}
 502:	bf 91       	pop	r27
 504:	af 91       	pop	r26
 506:	9f 91       	pop	r25
 508:	8f 91       	pop	r24
 50a:	3f 91       	pop	r19
 50c:	2f 91       	pop	r18
 50e:	0f 90       	pop	r0
 510:	0f be       	out	0x3f, r0	; 63
 512:	0f 90       	pop	r0
 514:	1f 90       	pop	r1
 516:	18 95       	reti
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:156
  m += 1;
    m += MILLIS_INC;
  }
  else
  {
    m += MILLIS_INC;
 518:	02 96       	adiw	r24, 0x02	; 2
 51a:	a1 1d       	adc	r26, r1
 51c:	b1 1d       	adc	r27, r1
 51e:	d4 cf       	rjmp	.-88     	; 0x4c8 <__vector_5+0x3c>

00000520 <main>:
main():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/main.cpp:6
#include <Arduino.h>

int main(void)
{
  #ifdef TUNED_OSCCAL_VALUE
  OSCCAL = TUNED_OSCCAL_VALUE; //set the oscillator calibration value based on the pins_arduino.h file. If this is not set, it will be optimised away
 520:	81 b7       	in	r24, 0x31	; 49
 522:	81 bf       	out	0x31, r24	; 49
init():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:802
  #endif
  #endif

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0) && defined(WGM01)
  sbi(TCCR0A, WGM01);
 524:	8a b5       	in	r24, 0x2a	; 42
 526:	82 60       	ori	r24, 0x02	; 2
 528:	8a bd       	out	0x2a, r24	; 42
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:803
  sbi(TCCR0A, WGM00);
 52a:	8a b5       	in	r24, 0x2a	; 42
 52c:	81 60       	ori	r24, 0x01	; 1
 52e:	8a bd       	out	0x2a, r24	; 42
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:826
  #endif

  // Millis timer is always processor clock divided by MillisTimer_Prescale_Value (64)
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
   #ifdef TCCR0B
    TCCR0B = (TCCR0B & ~((1<<CS02)|(1<<CS01)|(1<<CS00))) | (MillisTimer_Prescale_Index << CS00);
 530:	83 b7       	in	r24, 0x33	; 51
 532:	88 7f       	andi	r24, 0xF8	; 248
 534:	83 60       	ori	r24, 0x03	; 3
 536:	83 bf       	out	0x33, r24	; 51
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:838
  TCCR1B = (TCCR1B & ~((1<<CS13)|(1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #elif (TIMER_TO_USE_FOR_MILLIS == 1)
  TCCR1B = (TCCR1B & ~((1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #endif
  // this needs to be called before setup() or some functions won't work there
  sei();
 538:	78 94       	sei
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:842

  // Enable the overlow interrupt (this is the basic system tic-toc for millis)
  #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  sbi(TIMSK, TOIE0);
 53a:	89 b7       	in	r24, 0x39	; 57
 53c:	82 60       	ori	r24, 0x02	; 2
 53e:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:504
  TCCR0B |= (ToneTimer_Prescale_Index << CS00);
  #elif defined(__AVR_ATtiny43__)
  TCCR1A = 3; //WGM 10=1, WGM11=1
  TCCR1B = 3; //prescaler of 64
  #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1)
  TCCR1 &= ~((1<<CS13) | (1<<CS12) | (1<<CS11) | (1<<CS10)); //stop the clock to configure
 540:	80 b7       	in	r24, 0x30	; 48
 542:	80 7f       	andi	r24, 0xF0	; 240
 544:	80 bf       	out	0x30, r24	; 48
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:506
  // Use the Tone Timer for fast PWM as phase correct not supported by this timer
  sbi(TCCR1, CTC1);
 546:	80 b7       	in	r24, 0x30	; 48
 548:	80 68       	ori	r24, 0x80	; 128
 54a:	80 bf       	out	0x30, r24	; 48
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:508
  //#if !defined(__AVR_ATtiny85__)
  sbi(TCCR1, PWM1A); //for the tiny 85, Timer0 is used instead.
 54c:	80 b7       	in	r24, 0x30	; 48
 54e:	80 64       	ori	r24, 0x40	; 64
 550:	80 bf       	out	0x30, r24	; 48
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:510
  //#endif
  sbi(GTCCR, PWM1B);
 552:	8c b5       	in	r24, 0x2c	; 44
 554:	80 64       	ori	r24, 0x40	; 64
 556:	8c bd       	out	0x2c, r24	; 44
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:511
  OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
 558:	8f ef       	ldi	r24, 0xFF	; 255
 55a:	8d bd       	out	0x2d, r24	; 45
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:512
  TCCR1 |= (ToneTimer_Prescale_Index << CS10);
 55c:	80 b7       	in	r24, 0x30	; 48
 55e:	87 60       	ori	r24, 0x07	; 7
 560:	80 bf       	out	0x30, r24	; 48
init():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:862

  // Initialize the ADC
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
  #if defined(ADCSRA)
    // set a2d prescale factor
  ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 562:	86 b1       	in	r24, 0x06	; 6
 564:	88 77       	andi	r24, 0x78	; 120
 566:	86 68       	ori	r24, 0x86	; 134
 568:	86 b9       	out	0x06, r24	; 6
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:864
    // enable a2d conversions
    sbi(ADCSRA, ADEN);
 56a:	37 9a       	sbi	0x06, 7	; 6
ssd1306_begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:57
static void (*wireBeginTransmissionFn)(uint8_t i2c_address);
static bool (*wireWriteFn)(uint8_t byte);
static void (*wireEndTransmissionFn)(void);

static void ssd1306_begin(void) {
	wireBeginFn();
 56c:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <wireBeginFn>
 570:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <wireBeginFn+0x1>
 574:	09 95       	icall
begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:157
}

void SSD1306Device::begin(uint8_t init_sequence_length, const uint8_t init_sequence []) {
	ssd1306_begin();

	ssd1306_send_command_start();
 576:	2b de       	rcall	.-938    	; 0x1ce <ssd1306_send_command_start()>
 578:	ce e1       	ldi	r28, 0x1E	; 30
 57a:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:159
	for (uint8_t i = 0; i < init_sequence_length; i++) {
		ssd1306_send_command_byte(pgm_read_byte(&init_sequence[i]));
 57c:	fe 01       	movw	r30, r28
 57e:	f4 90       	lpm	r15, Z
ssd1306_send_command_byte():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:83
	ssd1306_send_start(i2c_address);
	ssd1306_send_byte(SSD1306_DATA);
}

static void ssd1306_send_command_byte(uint8_t byte) {
	if (ssd1306_send_byte(byte) == 0) {
 580:	8f 2d       	mov	r24, r15
 582:	0b de       	rcall	.-1002   	; 0x19a <ssd1306_send_byte(unsigned char)>
 584:	81 11       	cpse	r24, r1
 586:	04 c0       	rjmp	.+8      	; 0x590 <main+0x70>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:84
		ssd1306_send_stop();
 588:	03 de       	rcall	.-1018   	; 0x190 <ssd1306_send_stop()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:85
		ssd1306_send_command_start();
 58a:	21 de       	rcall	.-958    	; 0x1ce <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:86
		ssd1306_send_byte(byte);
 58c:	8f 2d       	mov	r24, r15
 58e:	05 de       	rcall	.-1014   	; 0x19a <ssd1306_send_byte(unsigned char)>
 590:	21 96       	adiw	r28, 0x01	; 1
begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:158

void SSD1306Device::begin(uint8_t init_sequence_length, const uint8_t init_sequence []) {
	ssd1306_begin();

	ssd1306_send_command_start();
	for (uint8_t i = 0; i < init_sequence_length; i++) {
 592:	f0 e0       	ldi	r31, 0x00	; 0
 594:	c6 32       	cpi	r28, 0x26	; 38
 596:	df 07       	cpc	r29, r31
 598:	89 f7       	brne	.-30     	; 0x57c <main+0x5c>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:161
		ssd1306_send_command_byte(pgm_read_byte(&init_sequence[i]));
	}
	ssd1306_send_stop();
 59a:	fa dd       	rcall	.-1036   	; 0x190 <ssd1306_send_stop()>
clear():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:175
	oledX = x;
	oledY = y;
}

void SSD1306Device::clear(void) {
	fill(0x00);
 59c:	3f de       	rcall	.-898    	; 0x21c <SSD1306Device::fill(unsigned char) [clone .constprop.8]>
ssd1306_send_command():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:99
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_command(uint8_t command) {
	ssd1306_send_command_start();
 59e:	17 de       	rcall	.-978    	; 0x1ce <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:100
	ssd1306_send_byte(command);
 5a0:	8f ea       	ldi	r24, 0xAF	; 175
 5a2:	fb dd       	rcall	.-1034   	; 0x19a <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:101
	ssd1306_send_stop();
 5a4:	f5 dd       	rcall	.-1046   	; 0x190 <ssd1306_send_stop()>
switchDisplayFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:294
void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
}

void SSD1306Device::switchDisplayFrame(void) {
	drawingFrame ^= 0x20;
 5a6:	10 e2       	ldi	r17, 0x20	; 32
switchRenderFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:290
}

// Double Buffering Commands

void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
 5a8:	04 e0       	ldi	r16, 0x04	; 4
clear():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:175
	oledX = x;
	oledY = y;
}

void SSD1306Device::clear(void) {
	fill(0x00);
 5aa:	38 de       	rcall	.-912    	; 0x21c <SSD1306Device::fill(unsigned char) [clone .constprop.8]>
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:22
}


void loop() {  
  oled.clear();
  oled.bitmap(0,0,32,4,bat0);
 5ac:	80 e0       	ldi	r24, 0x00	; 0
 5ae:	53 de       	rcall	.-858    	; 0x256 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.0]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:23
  oled.bitmap(8,0,32,4,bat0);
 5b0:	88 e0       	ldi	r24, 0x08	; 8
 5b2:	51 de       	rcall	.-862    	; 0x256 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.0]>
switchDisplayFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:294
void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
}

void SSD1306Device::switchDisplayFrame(void) {
	drawingFrame ^= 0x20;
 5b4:	c0 91 60 00 	lds	r28, 0x0060	; 0x800060 <__data_start>
 5b8:	c1 27       	eor	r28, r17
 5ba:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__data_start>
ssd1306_send_command():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:99
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_command(uint8_t command) {
	ssd1306_send_command_start();
 5be:	07 de       	rcall	.-1010   	; 0x1ce <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:100
	ssd1306_send_byte(command);
 5c0:	8c 2f       	mov	r24, r28
 5c2:	eb dd       	rcall	.-1066   	; 0x19a <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:101
	ssd1306_send_stop();
 5c4:	e5 dd       	rcall	.-1078   	; 0x190 <ssd1306_send_stop()>
switchRenderFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:290
}

// Double Buffering Commands

void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
 5c6:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <renderingFrame>
 5ca:	80 27       	eor	r24, r16
 5cc:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <renderingFrame>
delay():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:279
void yield(void) __attribute__ ((weak, alias("__empty")));

void delay(unsigned long ms)
{
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();
 5d0:	b9 dd       	rcall	.-1166   	; 0x144 <micros>
 5d2:	eb 01       	movw	r28, r22
 5d4:	88 ee       	ldi	r24, 0xE8	; 232
 5d6:	c8 2e       	mov	r12, r24
 5d8:	83 e0       	ldi	r24, 0x03	; 3
 5da:	d8 2e       	mov	r13, r24
 5dc:	e1 2c       	mov	r14, r1
 5de:	f1 2c       	mov	r15, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:283

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
 5e0:	b1 dd       	rcall	.-1182   	; 0x144 <micros>
 5e2:	6c 1b       	sub	r22, r28
 5e4:	7d 0b       	sbc	r23, r29
 5e6:	68 3e       	cpi	r22, 0xE8	; 232
 5e8:	73 40       	sbci	r23, 0x03	; 3
 5ea:	68 f0       	brcs	.+26     	; 0x606 <main+0xe6>
 5ec:	c1 14       	cp	r12, r1
 5ee:	d1 04       	cpc	r13, r1
 5f0:	e1 04       	cpc	r14, r1
 5f2:	f1 04       	cpc	r15, r1
 5f4:	d1 f2       	breq	.-76     	; 0x5aa <main+0x8a>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:284
      ms--;
 5f6:	81 e0       	ldi	r24, 0x01	; 1
 5f8:	c8 1a       	sub	r12, r24
 5fa:	d1 08       	sbc	r13, r1
 5fc:	e1 08       	sbc	r14, r1
 5fe:	f1 08       	sbc	r15, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:285
      start += 1000;
 600:	c8 51       	subi	r28, 0x18	; 24
 602:	dc 4f       	sbci	r29, 0xFC	; 252
 604:	ed cf       	rjmp	.-38     	; 0x5e0 <main+0xc0>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:281
void delay(unsigned long ms)
{
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
 606:	c1 14       	cp	r12, r1
 608:	d1 04       	cpc	r13, r1
 60a:	e1 04       	cpc	r14, r1
 60c:	f1 04       	cpc	r15, r1
 60e:	41 f7       	brne	.-48     	; 0x5e0 <main+0xc0>
 610:	cc cf       	rjmp	.-104    	; 0x5aa <main+0x8a>

00000612 <_GLOBAL__sub_I_oled>:
_ZN5PrintC2Ev():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.h:75
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 612:	e0 e9       	ldi	r30, 0x90	; 144
 614:	f0 e0       	ldi	r31, 0x00	; 0
 616:	13 82       	std	Z+3, r1	; 0x03
 618:	12 82       	std	Z+2, r1	; 0x02
__base_ctor ():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:142
	ssd1306_send_byte(command6);
	ssd1306_send_byte(command7);
	ssd1306_send_stop();
}

SSD1306Device::SSD1306Device(uint8_t ssd1306_i2c_address, void (*wireBeginFunc)(void), void (*wireBeginTransmissionFunc)(uint8_t ssd1306_i2c_address), bool (*wireWriteFunc)(uint8_t byte), void (*wireEndTransmissionFunc)(void)) {
 61a:	86 e6       	ldi	r24, 0x66	; 102
 61c:	90 e0       	ldi	r25, 0x00	; 0
 61e:	91 83       	std	Z+1, r25	; 0x01
 620:	80 83       	st	Z, r24
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:143
	i2c_address = ssd1306_i2c_address;
 622:	8c e3       	ldi	r24, 0x3C	; 60
 624:	80 93 83 00 	sts	0x0083, r24	; 0x800083 <i2c_address>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:144
	wireBeginFn = wireBeginFunc;
 628:	8c e8       	ldi	r24, 0x8C	; 140
 62a:	91 e0       	ldi	r25, 0x01	; 1
 62c:	90 93 8f 00 	sts	0x008F, r25	; 0x80008f <wireBeginFn+0x1>
 630:	80 93 8e 00 	sts	0x008E, r24	; 0x80008e <wireBeginFn>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:145
	wireBeginTransmissionFn = wireBeginTransmissionFunc;
 634:	86 e8       	ldi	r24, 0x86	; 134
 636:	91 e0       	ldi	r25, 0x01	; 1
 638:	90 93 82 00 	sts	0x0082, r25	; 0x800082 <wireBeginTransmissionFn+0x1>
 63c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <wireBeginTransmissionFn>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:146
	wireWriteFn = wireWriteFunc;
 640:	87 e7       	ldi	r24, 0x77	; 119
 642:	91 e0       	ldi	r25, 0x01	; 1
 644:	90 93 7e 00 	sts	0x007E, r25	; 0x80007e <wireWriteFn+0x1>
 648:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <wireWriteFn>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:147
	wireEndTransmissionFn = wireEndTransmissionFunc;
 64c:	87 ec       	ldi	r24, 0xC7	; 199
 64e:	91 e0       	ldi	r25, 0x01	; 1
 650:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <wireEndTransmissionFn+0x1>
 654:	80 93 7f 00 	sts	0x007F, r24	; 0x80007f <wireEndTransmissionFn>
_GLOBAL__sub_I_oled():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:26
  oled.switchFrame();
  delay(1000);
}
 658:	08 95       	ret

0000065a <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 65a:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 65c:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 65e:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 660:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 662:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 664:	09 94       	ijmp

00000666 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 666:	f8 94       	cli

00000668 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 668:	ff cf       	rjmp	.-2      	; 0x668 <__stop_program>
