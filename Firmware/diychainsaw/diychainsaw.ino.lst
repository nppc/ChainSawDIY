
C:\Users\Pavel\AppData\Local\Temp\arduino_build_313691/diychainsaw.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	fd c0       	rjmp	.+506    	; 0x1fc <__ctors_end>
   2:	21 c1       	rjmp	.+578    	; 0x246 <__bad_interrupt>
   4:	20 c1       	rjmp	.+576    	; 0x246 <__bad_interrupt>
   6:	eb c3       	rjmp	.+2006   	; 0x7de <__vector_3>
   8:	1e c1       	rjmp	.+572    	; 0x246 <__bad_interrupt>
   a:	94 c3       	rjmp	.+1832   	; 0x734 <__vector_5>
   c:	1c c1       	rjmp	.+568    	; 0x246 <__bad_interrupt>
   e:	1b c1       	rjmp	.+566    	; 0x246 <__bad_interrupt>
  10:	1a c1       	rjmp	.+564    	; 0x246 <__bad_interrupt>
  12:	da c3       	rjmp	.+1972   	; 0x7c8 <__vector_9>
  14:	18 c1       	rjmp	.+560    	; 0x246 <__bad_interrupt>
  16:	17 c1       	rjmp	.+558    	; 0x246 <__bad_interrupt>
  18:	16 c1       	rjmp	.+556    	; 0x246 <__bad_interrupt>
  1a:	15 c1       	rjmp	.+554    	; 0x246 <__bad_interrupt>
  1c:	14 c1       	rjmp	.+552    	; 0x246 <__bad_interrupt>

0000001e <__trampolines_end>:
__trampolines_start():
  1e:	ff fe       	.word	0xfeff	; ????
  20:	00 00       	nop
  22:	00 00       	nop
  24:	00 ff       	sbrs	r16, 0
  26:	ff fe       	.word	0xfeff	; ????
  28:	fe fe       	.word	0xfefe	; ????
  2a:	fe fc       	.word	0xfcfe	; ????
  2c:	ff ff       	.word	0xffff	; ????
  2e:	7f 7f       	andi	r23, 0xFF	; 255
  30:	7f 7f       	andi	r23, 0xFF	; 255
  32:	3f ff       	.word	0xff3f	; ????
  34:	7f 00       	.word	0x007f	; ????
  36:	00 00       	nop
	...

0000003a <bat0>:
  3a:	03 03 03 03 03 03 03 03 03 03 00 00 00 00 00 00     ................
	...
  56:	00 00 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0                 ............

00000062 <bat1>:
  62:	fb fb fb fb fb fb fb fb fb 03 ff ff ff ff ff ff     ................
  72:	ff ff ff 00 ff ff ff ff ff ff ff ff ff 00 df df     ................
  82:	df df df df df df df c0                             ........

0000008a <batBot1>:
  8a:	fe ff 03 fb fb fb fb fb fb fb fb fb 03 ff ff 00     ................
  9a:	ff ff ff ff ff ff ff ff ff 00 ff ff 00 ff ff ff     ................
  aa:	ff ff ff ff ff ff 00 7f ff c0 df df df df df df     ................
  ba:	df df df c0                                         ....

000000be <batBot0>:
  be:	fe ff 03 03 03 03 03 03 03 03 03 03 03 ff ff 00     ................
	...
  d6:	00 00 ff ff 00 00 00 00 00 00 00 00 00 00 00 7f     ................
  e6:	ff c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0                 ............

000000f2 <ssd1306_init_sequence>:
  f2:	c8 a1 a8 1f da 02 8d 14                             ........

000000fa <stateOK>:
  fa:	fc fe 07 03 03 03 03 03 03 03 03 03 83 c3 e3 83     ................
 10a:	03 03 03 03 03 03 03 03 03 03 03 03 03 07 fe fc     ................
 11a:	ff ff 00 00 00 00 04 0e 1e 3e 3f 7f 77 e3 e3 c1     .........>?.w...
 12a:	80 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff     ................
 13a:	ff ff 00 00 00 00 00 00 00 00 00 00 00 00 01 01     ................
 14a:	03 07 0f 0e 1c 38 70 c0 80 00 00 00 00 00 ff ff     .....8p.........
 15a:	3f 7f e0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0     ?...............
 16a:	c0 c0 c0 c0 c0 c0 c0 c0 c1 c5 c4 c0 c0 e0 7f 3f     ...............?

0000017a <stateDANGER>:
 17a:	00 00 80 c0 f0 f0 f8 fc fc 7e 3e 3f 1f 1f 1f 1f     .........~>?....
 18a:	1f 1f 1f 1f 3f be fe fc fc f8 f0 f0 c0 80 00 00     ....?...........
 19a:	f8 fe ff ff ff 0f 03 01 00 00 00 00 00 80 c0 e0     ................
 1aa:	f0 f8 fc fe 7f 3f 1f 0f 07 03 0f ff ff ff fe f8     .....?..........
 1ba:	1f 7f ff ff ff f0 c0 e0 f0 f8 fc fe 7f 3f 1f 0f     .............?..
 1ca:	07 03 01 00 00 00 00 00 80 c0 f0 ff ff ff 7f 1f     ................
 1da:	00 00 01 03 0f 0f 1f 3f 3f 7f 7d fc f8 f8 f8 f8     .......??.}.....
 1ea:	f8 f8 f8 f8 fc 7c 7e 3f 3f 1f 0f 0f 03 01 00 00     .....|~??.......

000001fa <__ctors_start>:
__ctors_start():
 1fa:	5a 05       	cpc	r21, r10

000001fc <__ctors_end>:
__dtors_end():
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf e5       	ldi	r28, 0x5F	; 95
 202:	d2 e0       	ldi	r29, 0x02	; 2
 204:	de bf       	out	0x3e, r29	; 62
 206:	cd bf       	out	0x3d, r28	; 61

00000208 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
 208:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
 20a:	aa e6       	ldi	r26, 0x6A	; 106
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
 20c:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
 20e:	01 c0       	rjmp	.+2      	; 0x212 <.do_clear_bss_start>

00000210 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
 210:	1d 92       	st	X+, r1

00000212 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
 212:	a8 39       	cpi	r26, 0x98	; 152
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
 214:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
 216:	e1 f7       	brne	.-8      	; 0x210 <.do_clear_bss_loop>

00000218 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
 218:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
 21a:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
 21c:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
 21e:	ee e1       	ldi	r30, 0x1E	; 30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
 220:	fb e0       	ldi	r31, 0x0B	; 11
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
 222:	02 c0       	rjmp	.+4      	; 0x228 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
 224:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
 226:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
 228:	aa 36       	cpi	r26, 0x6A	; 106
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
 22a:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
 22c:	d9 f7       	brne	.-10     	; 0x224 <__do_copy_data+0xc>

0000022e <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
 22e:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
 230:	ce ef       	ldi	r28, 0xFE	; 254
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
 232:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
 234:	03 c0       	rjmp	.+6      	; 0x23c <__do_global_ctors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
 236:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
 238:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
 23a:	69 d4       	rcall	.+2258   	; 0xb0e <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
 23c:	cd 3f       	cpi	r28, 0xFD	; 253
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
 23e:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
 240:	d1 f7       	brne	.-12     	; 0x236 <__do_global_ctors+0x8>
 242:	d8 d2       	rcall	.+1456   	; 0x7f4 <main>
 244:	6a c4       	rjmp	.+2260   	; 0xb1a <_exit>

00000246 <__bad_interrupt>:
__vector_1():
 246:	dc ce       	rjmp	.-584    	; 0x0 <__vectors>

00000248 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:34

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 248:	cf 92       	push	r12
 24a:	df 92       	push	r13
 24c:	ef 92       	push	r14
 24e:	ff 92       	push	r15
 250:	0f 93       	push	r16
 252:	1f 93       	push	r17
 254:	cf 93       	push	r28
 256:	df 93       	push	r29
 258:	6c 01       	movw	r12, r24
 25a:	eb 01       	movw	r28, r22
 25c:	7b 01       	movw	r14, r22
 25e:	e4 0e       	add	r14, r20
 260:	f5 1e       	adc	r15, r21
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:35
  size_t n = 0;
 262:	10 e0       	ldi	r17, 0x00	; 0
 264:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:36
  while (size--) {
 266:	ce 15       	cp	r28, r14
 268:	df 05       	cpc	r29, r15
 26a:	61 f0       	breq	.+24     	; 0x284 <__stack+0x25>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:37
    n += write(*buffer++);
 26c:	69 91       	ld	r22, Y+
 26e:	d6 01       	movw	r26, r12
 270:	ed 91       	ld	r30, X+
 272:	fc 91       	ld	r31, X
 274:	01 90       	ld	r0, Z+
 276:	f0 81       	ld	r31, Z
 278:	e0 2d       	mov	r30, r0
 27a:	c6 01       	movw	r24, r12
 27c:	09 95       	icall
 27e:	08 0f       	add	r16, r24
 280:	19 1f       	adc	r17, r25
 282:	f1 cf       	rjmp	.-30     	; 0x266 <__stack+0x7>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.cpp:40
  }
  return n;
}
 284:	c8 01       	movw	r24, r16
 286:	df 91       	pop	r29
 288:	cf 91       	pop	r28
 28a:	1f 91       	pop	r17
 28c:	0f 91       	pop	r16
 28e:	ff 90       	pop	r15
 290:	ef 90       	pop	r14
 292:	df 90       	pop	r13
 294:	cf 90       	pop	r12
 296:	08 95       	ret

00000298 <micros>:
micros():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:187
}

unsigned long micros()
{
  unsigned long m;
  uint8_t oldSREG = SREG, t;
 298:	3f b7       	in	r19, 0x3f	; 63
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:189

  cli();
 29a:	f8 94       	cli
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:190
  m = millis_timer_overflow_count;
 29c:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <millis_timer_overflow_count>
 2a0:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <millis_timer_overflow_count+0x1>
 2a4:	a0 91 8c 00 	lds	r26, 0x008C	; 0x80008c <millis_timer_overflow_count+0x2>
 2a8:	b0 91 8d 00 	lds	r27, 0x008D	; 0x80008d <millis_timer_overflow_count+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:192
#if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
  t = TCNT0;
 2ac:	22 b7       	in	r18, 0x32	; 50
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:207

#if defined(TIFR0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR0 & _BV(TOV0)) && (t < 255))
    m++;
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR & _BV(TOV0)) && (t < 255))
 2ae:	08 b6       	in	r0, 0x38	; 56
 2b0:	01 fe       	sbrs	r0, 1
 2b2:	05 c0       	rjmp	.+10     	; 0x2be <micros+0x26>
 2b4:	2f 3f       	cpi	r18, 0xFF	; 255
 2b6:	19 f0       	breq	.+6      	; 0x2be <micros+0x26>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:208
    m++;
 2b8:	01 96       	adiw	r24, 0x01	; 1
 2ba:	a1 1d       	adc	r26, r1
 2bc:	b1 1d       	adc	r27, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:217
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 1)
  if ((TIFR & _BV(TOV1)) && (t < 255))
    m++;
#endif

  SREG = oldSREG;
 2be:	3f bf       	out	0x3f, r19	; 63
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:224

#if F_CPU < 1000000L
  return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
#else
#if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 ) // Can we just do it the naive way? If so great!
  return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
 2c0:	ba 2f       	mov	r27, r26
 2c2:	a9 2f       	mov	r26, r25
 2c4:	98 2f       	mov	r25, r24
 2c6:	88 27       	eor	r24, r24
 2c8:	bc 01       	movw	r22, r24
 2ca:	cd 01       	movw	r24, r26
 2cc:	62 0f       	add	r22, r18
 2ce:	71 1d       	adc	r23, r1
 2d0:	81 1d       	adc	r24, r1
 2d2:	91 1d       	adc	r25, r1
 2d4:	43 e0       	ldi	r20, 0x03	; 3
 2d6:	66 0f       	add	r22, r22
 2d8:	77 1f       	adc	r23, r23
 2da:	88 1f       	adc	r24, r24
 2dc:	99 1f       	adc	r25, r25
 2de:	4a 95       	dec	r20
 2e0:	d1 f7       	brne	.-12     	; 0x2d6 <micros+0x3e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:267
  //the high part gets divided by cCPuS then multiplied by the prescaler. Then take the low 8 bits plus the high part modulo-cCPuS to correct for the division, then multiply that by the prescaler value first before dividing by cCPuS, and finally add the two together.
  //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
  return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
#endif
#endif
}
 2e2:	08 95       	ret

000002e4 <delay>:
delay():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:277
  // Empty
}
void yield(void) __attribute__ ((weak, alias("__empty")));

void delay(unsigned long ms)
{
 2e4:	cf 92       	push	r12
 2e6:	df 92       	push	r13
 2e8:	ef 92       	push	r14
 2ea:	ff 92       	push	r15
 2ec:	cf 93       	push	r28
 2ee:	df 93       	push	r29
 2f0:	6b 01       	movw	r12, r22
 2f2:	7c 01       	movw	r14, r24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:279
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();
 2f4:	d1 df       	rcall	.-94     	; 0x298 <micros>
 2f6:	eb 01       	movw	r28, r22
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:283

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
 2f8:	cf df       	rcall	.-98     	; 0x298 <micros>
 2fa:	6c 1b       	sub	r22, r28
 2fc:	7d 0b       	sbc	r23, r29
 2fe:	68 3e       	cpi	r22, 0xE8	; 232
 300:	73 40       	sbci	r23, 0x03	; 3
 302:	a0 f0       	brcs	.+40     	; 0x32c <delay+0x48>
 304:	c1 14       	cp	r12, r1
 306:	d1 04       	cpc	r13, r1
 308:	e1 04       	cpc	r14, r1
 30a:	f1 04       	cpc	r15, r1
 30c:	39 f4       	brne	.+14     	; 0x31c <delay+0x38>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:293
  #else
  uint32_t start = millis();
  while((millis() - start) < ms)  /* NOP */yield();
  return;
  #endif
}
 30e:	df 91       	pop	r29
 310:	cf 91       	pop	r28
 312:	ff 90       	pop	r15
 314:	ef 90       	pop	r14
 316:	df 90       	pop	r13
 318:	cf 90       	pop	r12
 31a:	08 95       	ret
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:284
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
      ms--;
 31c:	81 e0       	ldi	r24, 0x01	; 1
 31e:	c8 1a       	sub	r12, r24
 320:	d1 08       	sbc	r13, r1
 322:	e1 08       	sbc	r14, r1
 324:	f1 08       	sbc	r15, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:285
      start += 1000;
 326:	c8 51       	subi	r28, 0x18	; 24
 328:	dc 4f       	sbci	r29, 0xFC	; 252
 32a:	e6 cf       	rjmp	.-52     	; 0x2f8 <delay+0x14>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:281
void delay(unsigned long ms)
{
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
 32c:	c1 14       	cp	r12, r1
 32e:	d1 04       	cpc	r13, r1
 330:	e1 04       	cpc	r14, r1
 332:	f1 04       	cpc	r15, r1
 334:	09 f7       	brne	.-62     	; 0x2f8 <delay+0x14>
 336:	eb cf       	rjmp	.-42     	; 0x30e <delay+0x2a>

00000338 <ssd1306_send_stop()>:
ssd1306_send_stop():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:69
static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
}

static void ssd1306_send_stop(void) {
	wireEndTransmissionFn();
 338:	e0 91 7f 00 	lds	r30, 0x007F	; 0x80007f <wireEndTransmissionFn>
 33c:	f0 91 80 00 	lds	r31, 0x0080	; 0x800080 <wireEndTransmissionFn+0x1>
 340:	09 94       	ijmp

00000342 <ssd1306_send_byte(unsigned char)>:
ssd1306_send_byte():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:65
static void ssd1306_send_start(uint8_t ssd1306_i2c_address) {
	wireBeginTransmissionFn(ssd1306_i2c_address);
}

static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
 342:	e0 91 7d 00 	lds	r30, 0x007D	; 0x80007d <wireWriteFn>
 346:	f0 91 7e 00 	lds	r31, 0x007E	; 0x80007e <wireWriteFn+0x1>
 34a:	09 94       	ijmp

0000034c <ssd1306_send_data_start()>:
ssd1306_send_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:61
static void ssd1306_begin(void) {
	wireBeginFn();
}

static void ssd1306_send_start(uint8_t ssd1306_i2c_address) {
	wireBeginTransmissionFn(ssd1306_i2c_address);
 34c:	e0 91 81 00 	lds	r30, 0x0081	; 0x800081 <wireBeginTransmissionFn>
 350:	f0 91 82 00 	lds	r31, 0x0082	; 0x800082 <wireBeginTransmissionFn+0x1>
 354:	80 91 83 00 	lds	r24, 0x0083	; 0x800083 <i2c_address>
 358:	09 95       	icall
ssd1306_send_data_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:79
	ssd1306_send_byte(SSD1306_COMMAND);
}

static void ssd1306_send_data_start(void) {
	ssd1306_send_start(i2c_address);
	ssd1306_send_byte(SSD1306_DATA);
 35a:	80 e4       	ldi	r24, 0x40	; 64
 35c:	f2 cf       	rjmp	.-28     	; 0x342 <ssd1306_send_byte(unsigned char)>

0000035e <ssd1306_send_data_byte(unsigned char)>:
ssd1306_send_data_byte():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:90
		ssd1306_send_command_start();
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_data_byte(uint8_t byte) {
 35e:	cf 93       	push	r28
 360:	c8 2f       	mov	r28, r24
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:91
	if (ssd1306_send_byte(byte) == 0) {
 362:	ef df       	rcall	.-34     	; 0x342 <ssd1306_send_byte(unsigned char)>
 364:	81 11       	cpse	r24, r1
 366:	05 c0       	rjmp	.+10     	; 0x372 <ssd1306_send_data_byte(unsigned char)+0x14>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:92
		ssd1306_send_stop();
 368:	e7 df       	rcall	.-50     	; 0x338 <ssd1306_send_stop()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:93
		ssd1306_send_data_start();
 36a:	f0 df       	rcall	.-32     	; 0x34c <ssd1306_send_data_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:94
		ssd1306_send_byte(byte);
 36c:	8c 2f       	mov	r24, r28
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:96
	}
}
 36e:	cf 91       	pop	r28
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:94

static void ssd1306_send_data_byte(uint8_t byte) {
	if (ssd1306_send_byte(byte) == 0) {
		ssd1306_send_stop();
		ssd1306_send_data_start();
		ssd1306_send_byte(byte);
 370:	e8 cf       	rjmp	.-48     	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:96
	}
}
 372:	cf 91       	pop	r28
 374:	08 95       	ret

00000376 <ssd1306_send_command_start()>:
ssd1306_send_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:61
static void ssd1306_begin(void) {
	wireBeginFn();
}

static void ssd1306_send_start(uint8_t ssd1306_i2c_address) {
	wireBeginTransmissionFn(ssd1306_i2c_address);
 376:	e0 91 81 00 	lds	r30, 0x0081	; 0x800081 <wireBeginTransmissionFn>
 37a:	f0 91 82 00 	lds	r31, 0x0082	; 0x800082 <wireBeginTransmissionFn+0x1>
 37e:	80 91 83 00 	lds	r24, 0x0083	; 0x800083 <i2c_address>
 382:	09 95       	icall
ssd1306_send_command_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:74
	wireEndTransmissionFn();
}

static void ssd1306_send_command_start(void) {
	ssd1306_send_start(i2c_address);
	ssd1306_send_byte(SSD1306_COMMAND);
 384:	80 e0       	ldi	r24, 0x00	; 0
 386:	dd cf       	rjmp	.-70     	; 0x342 <ssd1306_send_byte(unsigned char)>

00000388 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.12]>:
setCursor():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:168

void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
 388:	1f 93       	push	r17
 38a:	cf 93       	push	r28
 38c:	df 93       	push	r29
 38e:	c8 2f       	mov	r28, r24
 390:	16 2f       	mov	r17, r22
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:169
	ssd1306_send_command3(renderingFrame | (y & 0x07), 0x10 | ((x & 0xf0) >> 4), x & 0x0f);
 392:	d6 2f       	mov	r29, r22
 394:	d7 70       	andi	r29, 0x07	; 7
 396:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <renderingFrame>
 39a:	d8 2b       	or	r29, r24
ssd1306_send_command3():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:112
	ssd1306_send_byte(command2);
	ssd1306_send_stop();
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
 39c:	ec df       	rcall	.-40     	; 0x376 <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:113
	ssd1306_send_byte(command1);
 39e:	8d 2f       	mov	r24, r29
 3a0:	d0 df       	rcall	.-96     	; 0x342 <ssd1306_send_byte(unsigned char)>
setCursor():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:169
void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | (y & 0x07), 0x10 | ((x & 0xf0) >> 4), x & 0x0f);
 3a2:	8c 2f       	mov	r24, r28
 3a4:	82 95       	swap	r24
 3a6:	8f 70       	andi	r24, 0x0F	; 15
ssd1306_send_command3():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:114
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
	ssd1306_send_byte(command1);
	ssd1306_send_byte(command2);
 3a8:	80 61       	ori	r24, 0x10	; 16
 3aa:	cb df       	rcall	.-106    	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:115
	ssd1306_send_byte(command3);
 3ac:	8c 2f       	mov	r24, r28
 3ae:	8f 70       	andi	r24, 0x0F	; 15
 3b0:	c8 df       	rcall	.-112    	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:116
	ssd1306_send_stop();
 3b2:	c2 df       	rcall	.-124    	; 0x338 <ssd1306_send_stop()>
setCursor():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:170
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | (y & 0x07), 0x10 | ((x & 0xf0) >> 4), x & 0x0f);
	oledX = x;
 3b4:	c0 93 97 00 	sts	0x0097, r28	; 0x800097 <oledX>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:171
	oledY = y;
 3b8:	10 93 96 00 	sts	0x0096, r17	; 0x800096 <oledY>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:172
}
 3bc:	df 91       	pop	r29
 3be:	cf 91       	pop	r28
 3c0:	1f 91       	pop	r17
 3c2:	08 95       	ret

000003c4 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]>:
bitmap():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:257
	}
	setCursor(0, 0);
}
*/

void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
 3c4:	af 92       	push	r10
 3c6:	bf 92       	push	r11
 3c8:	cf 92       	push	r12
 3ca:	df 92       	push	r13
 3cc:	ff 92       	push	r15
 3ce:	0f 93       	push	r16
 3d0:	1f 93       	push	r17
 3d2:	cf 93       	push	r28
 3d4:	df 93       	push	r29
 3d6:	d8 2f       	mov	r29, r24
 3d8:	6a 01       	movw	r12, r20
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:258
	uint16_t j = 0;
 3da:	10 e0       	ldi	r17, 0x00	; 0
 3dc:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:259
 	for (uint8_t y = y0; y < y0 + y1; y++) {
 3de:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:262
		setCursor(x0,y);
		ssd1306_send_data_start();
		for (uint8_t x = x0; x < x0 + x1; x++) {
 3e0:	86 0f       	add	r24, r22
 3e2:	99 27       	eor	r25, r25
 3e4:	99 1f       	adc	r25, r25
 3e6:	5c 01       	movw	r10, r24
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:260
*/

void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y0 + y1; y++) {
		setCursor(x0,y);
 3e8:	6c 2f       	mov	r22, r28
 3ea:	8d 2f       	mov	r24, r29
 3ec:	cd df       	rcall	.-102    	; 0x388 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.12]>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:261
		ssd1306_send_data_start();
 3ee:	ae df       	rcall	.-164    	; 0x34c <ssd1306_send_data_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:262
		for (uint8_t x = x0; x < x0 + x1; x++) {
 3f0:	fd 2e       	mov	r15, r29
 3f2:	fa 14       	cp	r15, r10
 3f4:	1b 04       	cpc	r1, r11
 3f6:	4c f4       	brge	.+18     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:263
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
 3f8:	f6 01       	movw	r30, r12
 3fa:	e0 0f       	add	r30, r16
 3fc:	f1 1f       	adc	r31, r17
 3fe:	84 91       	lpm	r24, Z
 400:	ae df       	rcall	.-164    	; 0x35e <ssd1306_send_data_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:262
void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y0 + y1; y++) {
		setCursor(x0,y);
		ssd1306_send_data_start();
		for (uint8_t x = x0; x < x0 + x1; x++) {
 402:	f3 94       	inc	r15
 404:	0f 5f       	subi	r16, 0xFF	; 255
 406:	1f 4f       	sbci	r17, 0xFF	; 255
 408:	f4 cf       	rjmp	.-24     	; 0x3f2 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]+0x2e>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:265
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
		}
		ssd1306_send_stop();
 40a:	96 df       	rcall	.-212    	; 0x338 <ssd1306_send_stop()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:259
}
*/

void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y0 + y1; y++) {
 40c:	cf 5f       	subi	r28, 0xFF	; 255
 40e:	c4 30       	cpi	r28, 0x04	; 4
 410:	59 f7       	brne	.-42     	; 0x3e8 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]+0x24>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:267
		for (uint8_t x = x0; x < x0 + x1; x++) {
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
		}
		ssd1306_send_stop();
	}
	setCursor(0, 0);
 412:	60 e0       	ldi	r22, 0x00	; 0
 414:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:268
}
 416:	df 91       	pop	r29
 418:	cf 91       	pop	r28
 41a:	1f 91       	pop	r17
 41c:	0f 91       	pop	r16
 41e:	ff 90       	pop	r15
 420:	df 90       	pop	r13
 422:	cf 90       	pop	r12
 424:	bf 90       	pop	r11
 426:	af 90       	pop	r10
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:267
		for (uint8_t x = x0; x < x0 + x1; x++) {
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
		}
		ssd1306_send_stop();
	}
	setCursor(0, 0);
 428:	af cf       	rjmp	.-162    	; 0x388 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.12]>

0000042a <SSD1306Device::fill(unsigned char) [clone .constprop.4]>:
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:178

void SSD1306Device::clear(void) {
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
 42a:	1f 93       	push	r17
 42c:	cf 93       	push	r28
 42e:	df 93       	push	r29
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:179
	for (uint8_t m = 0; m < SSD1306_PAGES; m++) {
 430:	c0 e0       	ldi	r28, 0x00	; 0
fillToEOL():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:275
void SSD1306Device::clearToEOL(void) {
	fillToEOL(0x00);
}

void SSD1306Device::fillToEOL(uint8_t fill) {
	fillLength(fill, 128 - oledX);
 432:	10 e8       	ldi	r17, 0x80	; 128
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:180
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < SSD1306_PAGES; m++) {
		setCursor(0, m);
 434:	6c 2f       	mov	r22, r28
 436:	80 e0       	ldi	r24, 0x00	; 0
 438:	a7 df       	rcall	.-178    	; 0x388 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.12]>
fillToEOL():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:275
void SSD1306Device::clearToEOL(void) {
	fillToEOL(0x00);
}

void SSD1306Device::fillToEOL(uint8_t fill) {
	fillLength(fill, 128 - oledX);
 43a:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <oledX>
 43e:	d1 2f       	mov	r29, r17
 440:	d8 1b       	sub	r29, r24
fillLength():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:279
}

void SSD1306Device::fillLength(uint8_t fill, uint8_t length) {
	oledX += length;
 442:	10 93 97 00 	sts	0x0097, r17	; 0x800097 <oledX>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:280
	ssd1306_send_data_start();
 446:	82 df       	rcall	.-252    	; 0x34c <ssd1306_send_data_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:283
	do
	{
		ssd1306_send_data_byte(fill);
 448:	80 e0       	ldi	r24, 0x00	; 0
 44a:	89 df       	rcall	.-238    	; 0x35e <ssd1306_send_data_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:285
	}
	while (--length);
 44c:	d1 50       	subi	r29, 0x01	; 1
 44e:	e1 f7       	brne	.-8      	; 0x448 <SSD1306Device::fill(unsigned char) [clone .constprop.4]+0x1e>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:286
	ssd1306_send_stop();
 450:	73 df       	rcall	.-282    	; 0x338 <ssd1306_send_stop()>
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:179
void SSD1306Device::clear(void) {
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < SSD1306_PAGES; m++) {
 452:	cf 5f       	subi	r28, 0xFF	; 255
 454:	c4 30       	cpi	r28, 0x04	; 4
 456:	71 f7       	brne	.-36     	; 0x434 <SSD1306Device::fill(unsigned char) [clone .constprop.4]+0xa>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:183
		setCursor(0, m);
		fillToEOL(fill);
	}
	setCursor(0, 0);
 458:	60 e0       	ldi	r22, 0x00	; 0
 45a:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:184
}
 45c:	df 91       	pop	r29
 45e:	cf 91       	pop	r28
 460:	1f 91       	pop	r17
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:183
void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < SSD1306_PAGES; m++) {
		setCursor(0, m);
		fillToEOL(fill);
	}
	setCursor(0, 0);
 462:	92 cf       	rjmp	.-220    	; 0x388 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.12]>

00000464 <SSD1306Device::newLine(unsigned char)>:
newLine():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:187
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
 464:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <oledY>
 468:	86 0f       	add	r24, r22
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:188
	if (oledY > SSD1306_PAGES - fontHeight) {
 46a:	24 e0       	ldi	r18, 0x04	; 4
 46c:	30 e0       	ldi	r19, 0x00	; 0
 46e:	26 1b       	sub	r18, r22
 470:	31 09       	sbc	r19, r1
 472:	82 17       	cp	r24, r18
 474:	13 06       	cpc	r1, r19
 476:	09 f0       	breq	.+2      	; 0x47a <SSD1306Device::newLine(unsigned char)+0x16>
 478:	34 f4       	brge	.+12     	; 0x486 <SSD1306Device::newLine(unsigned char)+0x22>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:189
		oledY = SSD1306_PAGES - fontHeight;
 47a:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <oledY>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:191
	}
	setCursor(0, oledY);
 47e:	60 91 96 00 	lds	r22, 0x0096	; 0x800096 <oledY>
 482:	80 e0       	ldi	r24, 0x00	; 0
 484:	81 cf       	rjmp	.-254    	; 0x388 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.12]>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:189
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
	if (oledY > SSD1306_PAGES - fontHeight) {
		oledY = SSD1306_PAGES - fontHeight;
 486:	84 e0       	ldi	r24, 0x04	; 4
 488:	86 1b       	sub	r24, r22
 48a:	f7 cf       	rjmp	.-18     	; 0x47a <SSD1306Device::newLine(unsigned char)+0x16>

0000048c <SSD1306Device::write(unsigned char)>:
write():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:241
			}
		}
	}
	while (--line);
	return 1;
}
 48c:	81 e0       	ldi	r24, 0x01	; 1
 48e:	90 e0       	ldi	r25, 0x00	; 0
 490:	08 95       	ret

00000492 <SSD1306Device::switchFrame() [clone .constprop.6]>:
switchFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:312
void SSD1306Device::switchDisplayFrame(void) {
	drawingFrame ^= 0x20;
	ssd1306_send_command(drawingFrame);
}

void SSD1306Device::switchFrame(void) {
 492:	cf 93       	push	r28
switchDisplayFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:308
void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
}

void SSD1306Device::switchDisplayFrame(void) {
	drawingFrame ^= 0x20;
 494:	c0 91 60 00 	lds	r28, 0x0060	; 0x800060 <__data_start>
 498:	80 e2       	ldi	r24, 0x20	; 32
 49a:	c8 27       	eor	r28, r24
 49c:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__data_start>
ssd1306_send_command():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:99
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_command(uint8_t command) {
	ssd1306_send_command_start();
 4a0:	6a df       	rcall	.-300    	; 0x376 <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:100
	ssd1306_send_byte(command);
 4a2:	8c 2f       	mov	r24, r28
 4a4:	4e df       	rcall	.-356    	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:101
	ssd1306_send_stop();
 4a6:	48 df       	rcall	.-368    	; 0x338 <ssd1306_send_stop()>
switchRenderFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:304
}

// Double Buffering Commands

void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
 4a8:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <renderingFrame>
 4ac:	94 e0       	ldi	r25, 0x04	; 4
 4ae:	89 27       	eor	r24, r25
 4b0:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <renderingFrame>
switchFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:315
}

void SSD1306Device::switchFrame(void) {
	switchDisplayFrame();
	switchRenderFrame();
}
 4b4:	cf 91       	pop	r28
 4b6:	08 95       	ret

000004b8 <stopMotor()>:
stopMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:250
  return LOW;
}

void stopMotor(){
    // make sure that motor is off
    run_state=0;
 4b8:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <run_state>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:252
    // stop timer
	cli();
 4bc:	f8 94       	cli
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:253
    TCCR1 = 0;
 4be:	10 be       	out	0x30, r1	; 48
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:254
	sei();
 4c0:	78 94       	sei
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:255
    bitClear(PORTB,3);
 4c2:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:256
	delay(5);
 4c4:	65 e0       	ldi	r22, 0x05	; 5
 4c6:	70 e0       	ldi	r23, 0x00	; 0
 4c8:	80 e0       	ldi	r24, 0x00	; 0
 4ca:	90 e0       	ldi	r25, 0x00	; 0
 4cc:	0b df       	rcall	.-490    	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:257
    bitClear(PORTB,3);  
 4ce:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:258
}
 4d0:	08 95       	ret

000004d2 <readADC()>:
readADC():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:202
  bitSet(PORTB, 3);
  //tmrval = TCNT1;
}

uint16_t readADC(void){
	while (bit_is_set(ADCSRA,ADSC)); // wait for any previous conversion
 4d2:	36 99       	sbic	0x06, 6	; 6
 4d4:	fe cf       	rjmp	.-4      	; 0x4d2 <readADC()>
 4d6:	20 e2       	ldi	r18, 0x20	; 32
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:203
	uint16_t res32=0;
 4d8:	90 e0       	ldi	r25, 0x00	; 0
 4da:	80 e0       	ldi	r24, 0x00	; 0
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:205
	for(uint8_t i=0;i<32;i++){
	  ADCSRA |= (1 << ADSC); // start new conversion
 4dc:	36 9a       	sbi	0x06, 6	; 6
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:206
	  while (bit_is_set(ADCSRA,ADSC)); // wait for current conversion to complete
 4de:	36 99       	sbic	0x06, 6	; 6
 4e0:	fe cf       	rjmp	.-4      	; 0x4de <readADC()+0xc>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:207
	  uint8_t low  = ADCL; // must read ADCL first
 4e2:	34 b1       	in	r19, 0x04	; 4
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:208
	  uint8_t high = ADCH;
 4e4:	45 b1       	in	r20, 0x05	; 5
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:209
    res32+=(uint16_t)((high<<8) | low);
 4e6:	54 2f       	mov	r21, r20
 4e8:	43 2f       	mov	r20, r19
 4ea:	84 0f       	add	r24, r20
 4ec:	95 1f       	adc	r25, r21
 4ee:	21 50       	subi	r18, 0x01	; 1
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:204
}

uint16_t readADC(void){
	while (bit_is_set(ADCSRA,ADSC)); // wait for any previous conversion
	uint16_t res32=0;
	for(uint8_t i=0;i<32;i++){
 4f0:	a9 f7       	brne	.-22     	; 0x4dc <readADC()+0xa>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:212
	  uint8_t low  = ADCL; // must read ADCL first
	  uint8_t high = ADCH;
    res32+=(uint16_t)((high<<8) | low);
	}
	  return res32 /32;
}
 4f2:	25 e0       	ldi	r18, 0x05	; 5
 4f4:	96 95       	lsr	r25
 4f6:	87 95       	ror	r24
 4f8:	2a 95       	dec	r18
 4fa:	e1 f7       	brne	.-8      	; 0x4f4 <readADC()+0x22>
 4fc:	08 95       	ret

000004fe <disableWatchdog()>:
wdt_disable():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\avr/wdt.h:510
				"out __SREG__,__tmp_reg__"   "\n\t"
				: [TEMPREG] "=d" (temp_reg)
				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
				: "r0"
		);
 4fe:	0f b6       	in	r0, 0x3f	; 63
 500:	f8 94       	cli
 502:	a8 95       	wdr
 504:	81 b5       	in	r24, 0x21	; 33
 506:	88 61       	ori	r24, 0x18	; 24
 508:	81 bd       	out	0x21, r24	; 33
 50a:	11 bc       	out	0x21, r1	; 33
 50c:	0f be       	out	0x3f, r0	; 63
disableWatchdog():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:126
  if(tmp == bitRead(PINB, 1)){return tmp;}else{return !tmp;}
}

void disableWatchdog(){
  wdt_disable();
}
 50e:	08 95       	ret

00000510 <getButtonState()>:
getButtonState():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:118
  if(adc128>=V1S1) return 1;
  if(adc128<V1S0) return 0;
  return 0;
}

bool getButtonState(){
 510:	0f 93       	push	r16
 512:	1f 93       	push	r17
 514:	cf 93       	push	r28
 516:	df 93       	push	r29
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:119
  bool tmp = bitRead(PINB, 1);
 518:	86 b3       	in	r24, 0x16	; 22
 51a:	c1 e0       	ldi	r28, 0x01	; 1
 51c:	d8 2f       	mov	r29, r24
 51e:	d2 70       	andi	r29, 0x02	; 2
 520:	81 ff       	sbrs	r24, 1
 522:	c0 e0       	ldi	r28, 0x00	; 0
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:120
  delay(10);
 524:	6a e0       	ldi	r22, 0x0A	; 10
 526:	70 e0       	ldi	r23, 0x00	; 0
 528:	80 e0       	ldi	r24, 0x00	; 0
 52a:	90 e0       	ldi	r25, 0x00	; 0
 52c:	db de       	rcall	.-586    	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:121
  if(tmp == bitRead(PINB, 1)){return tmp;}else{return !tmp;}
 52e:	86 b3       	in	r24, 0x16	; 22
 530:	81 fb       	bst	r24, 1
 532:	00 27       	eor	r16, r16
 534:	00 f9       	bld	r16, 0
 536:	10 e0       	ldi	r17, 0x00	; 0
 538:	c0 17       	cp	r28, r16
 53a:	11 06       	cpc	r1, r17
 53c:	19 f0       	breq	.+6      	; 0x544 <getButtonState()+0x34>
 53e:	c1 e0       	ldi	r28, 0x01	; 1
 540:	d1 11       	cpse	r29, r1
 542:	c0 e0       	ldi	r28, 0x00	; 0
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:122
}
 544:	8c 2f       	mov	r24, r28
 546:	df 91       	pop	r29
 548:	cf 91       	pop	r28
 54a:	1f 91       	pop	r17
 54c:	0f 91       	pop	r16
 54e:	08 95       	ret

00000550 <draw_Bat(unsigned char)>:
draw_Bat():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:80
  255,255,254,254,254,254,252,
  255,255,127,127,127,127,63,
  255,127,0,0,0,0,0,
};

void draw_Bat(uint8_t val){
 550:	cf 93       	push	r28
 552:	df 93       	push	r29
 554:	d8 2f       	mov	r29, r24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:81
	if(val==0){oled.bitmap(0,0,13,4,batBot0);} else {oled.bitmap(0,0,13,4,batBot1);}
 556:	4e eb       	ldi	r20, 0xBE	; 190
 558:	50 e0       	ldi	r21, 0x00	; 0
 55a:	88 23       	and	r24, r24
 55c:	11 f0       	breq	.+4      	; 0x562 <draw_Bat(unsigned char)+0x12>
 55e:	4a e8       	ldi	r20, 0x8A	; 138
 560:	50 e0       	ldi	r21, 0x00	; 0
 562:	6d e0       	ldi	r22, 0x0D	; 13
 564:	80 e0       	ldi	r24, 0x00	; 0
 566:	2e df       	rcall	.-420    	; 0x3c4 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:80
  255,255,254,254,254,254,252,
  255,255,127,127,127,127,63,
  255,127,0,0,0,0,0,
};

void draw_Bat(uint8_t val){
 568:	c2 e0       	ldi	r28, 0x02	; 2
 56a:	8c 2f       	mov	r24, r28
 56c:	6a e0       	ldi	r22, 0x0A	; 10
 56e:	c6 d2       	rcall	.+1420   	; 0xafc <__mulqi3>
 570:	87 50       	subi	r24, 0x07	; 7
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:82
	if(val==0){oled.bitmap(0,0,13,4,batBot0);} else {oled.bitmap(0,0,13,4,batBot1);}
	for(uint8_t ix=2;ix<=6;ix++){if(ix<=val){oled.bitmap(13+(ix-2)*10,0,10,4,bat1);}else{oled.bitmap(13+(ix-2)*10,0,10,4,bat0);}}
 572:	42 e6       	ldi	r20, 0x62	; 98
 574:	50 e0       	ldi	r21, 0x00	; 0
 576:	dc 17       	cp	r29, r28
 578:	10 f4       	brcc	.+4      	; 0x57e <draw_Bat(unsigned char)+0x2e>
 57a:	4a e3       	ldi	r20, 0x3A	; 58
 57c:	50 e0       	ldi	r21, 0x00	; 0
 57e:	6a e0       	ldi	r22, 0x0A	; 10
 580:	21 df       	rcall	.-446    	; 0x3c4 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]>
 582:	cf 5f       	subi	r28, 0xFF	; 255
 584:	c7 30       	cpi	r28, 0x07	; 7
 586:	89 f7       	brne	.-30     	; 0x56a <draw_Bat(unsigned char)+0x1a>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:83
	oled.bitmap(13+50,0,7,4,batEnd);
 588:	4e e1       	ldi	r20, 0x1E	; 30
 58a:	50 e0       	ldi	r21, 0x00	; 0
 58c:	67 e0       	ldi	r22, 0x07	; 7
 58e:	8f e3       	ldi	r24, 0x3F	; 63
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:84
}
 590:	df 91       	pop	r29
 592:	cf 91       	pop	r28
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:83
};

void draw_Bat(uint8_t val){
	if(val==0){oled.bitmap(0,0,13,4,batBot0);} else {oled.bitmap(0,0,13,4,batBot1);}
	for(uint8_t ix=2;ix<=6;ix++){if(ix<=val){oled.bitmap(13+(ix-2)*10,0,10,4,bat1);}else{oled.bitmap(13+(ix-2)*10,0,10,4,bat0);}}
	oled.bitmap(13+50,0,7,4,batEnd);
 594:	17 cf       	rjmp	.-466    	; 0x3c4 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]>

00000596 <tinywirem_write(unsigned char)>:
write():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:53
  USI_BufIdx = 0; 
  USI_Buf[USI_BufIdx] = (slaveAddr<<TWI_ADR_BITS) | USI_SEND; 
}

size_t USI_TWI::write(uint8_t data){ // buffers up data to send
  if (USI_BufIdx >= USI_BUF_SIZE-1) return 0;       // dont blow out the buffer
 596:	e0 91 7c 00 	lds	r30, 0x007C	; 0x80007c <USI_TWI::USI_BufIdx>
 59a:	e1 31       	cpi	r30, 0x11	; 17
 59c:	48 f4       	brcc	.+18     	; 0x5b0 <tinywirem_write(unsigned char)+0x1a>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:54
  USI_BufIdx++;                                   // inc for next byte in buffer
 59e:	ef 5f       	subi	r30, 0xFF	; 255
 5a0:	e0 93 7c 00 	sts	0x007C, r30	; 0x80007c <USI_TWI::USI_BufIdx>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:55
  USI_Buf[USI_BufIdx] = data;
 5a4:	f0 e0       	ldi	r31, 0x00	; 0
 5a6:	e6 59       	subi	r30, 0x96	; 150
 5a8:	ff 4f       	sbci	r31, 0xFF	; 255
 5aa:	80 83       	st	Z, r24
tinywirem_write():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:56
  return 1;
 5ac:	81 e0       	ldi	r24, 0x01	; 1
 5ae:	08 95       	ret
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:53
  USI_BufIdx = 0; 
  USI_Buf[USI_BufIdx] = (slaveAddr<<TWI_ADR_BITS) | USI_SEND; 
}

size_t USI_TWI::write(uint8_t data){ // buffers up data to send
  if (USI_BufIdx >= USI_BUF_SIZE-1) return 0;       // dont blow out the buffer
 5b0:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:23
	TinyWireM.beginTransmission(i2c_address);
}

static bool tinywirem_write(uint8_t byte) {
	return TinyWireM.write(byte);
}
 5b2:	08 95       	ret

000005b4 <tinywirem_beginTransmission(unsigned char)>:
beginTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:48
void USI_TWI::begin(){ // initialize I2C lib
  USI_TWI_Master_Initialise();          
}

void USI_TWI::beginTransmission(uint8_t slaveAddr){ // setup address & write bit
  USI_BufIdx = 0; 
 5b4:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <USI_TWI::USI_BufIdx>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:49
  USI_Buf[USI_BufIdx] = (slaveAddr<<TWI_ADR_BITS) | USI_SEND; 
 5b8:	88 0f       	add	r24, r24
 5ba:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__data_end>
tinywirem_beginTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:19
	TinyWireM.begin();
}

static void tinywirem_beginTransmission(uint8_t i2c_address) {
	TinyWireM.beginTransmission(i2c_address);
}
 5be:	08 95       	ret

000005c0 <tinywirem_begin()>:
USI_TWI_Master_Initialise():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:48
/*---------------------------------------------------------------
 USI TWI single master initialization function
---------------------------------------------------------------*/
void USI_TWI_Master_Initialise( void )
{
  PORT_USI |= (1<<PIN_USI_SDA);           // Enable pullup on SDA, to set high as released state.
 5c0:	c0 9a       	sbi	0x18, 0	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:49
  PORT_USI |= (1<<PIN_USI_SCL);           // Enable pullup on SCL, to set high as released state.
 5c2:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:51
  
  DDR_USI  |= (1<<PIN_USI_SCL);           // Enable SCL as output.
 5c4:	ba 9a       	sbi	0x17, 2	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:52
  DDR_USI  |= (1<<PIN_USI_SDA);           // Enable SDA as output.
 5c6:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:54
  
  USIDR    =  0xFF;                       // Preload dataregister with "released level" data.
 5c8:	8f ef       	ldi	r24, 0xFF	; 255
 5ca:	8f b9       	out	0x0f, r24	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:55
  USICR    =  (0<<USISIE)|(0<<USIOIE)|                            // Disable Interrupts.
 5cc:	8a e2       	ldi	r24, 0x2A	; 42
 5ce:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:59
              (1<<USIWM1)|(0<<USIWM0)|                            // Set USI in Two-wire mode.
              (1<<USICS1)|(0<<USICS0)|(1<<USICLK)|                // Software stobe as counter clock source
              (0<<USITC);
  USISR   =   (1<<USISIF)|(1<<USIOIF)|(1<<USIPF)|(1<<USIDC)|      // Clear flags,
 5d0:	80 ef       	ldi	r24, 0xF0	; 240
 5d2:	8e b9       	out	0x0e, r24	; 14
tinywirem_begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:15

#include <TinyWireM.h>  // Version with buffer bugfix: https://github.com/adafruit/TinyWireM

static void tinywirem_begin(void) {
	TinyWireM.begin();
}
 5d4:	08 95       	ret

000005d6 <USI_TWI_Master_Start()>:
USI_TWI_Master_Start():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:291
 Function for generating a TWI Start Condition. 
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Start( void )
{
/* Release SCL to ensure that (repeated) Start can be performed */
  PORT_USI |= (1<<PIN_USI_SCL);                     // Release SCL.
 5d6:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:292
  while( !(PORT_USI & (1<<PIN_USI_SCL)) );          // Verify that SCL becomes high.
 5d8:	c2 9b       	sbis	0x18, 2	; 24
 5da:	fe cf       	rjmp	.-4      	; 0x5d8 <USI_TWI_Master_Start()+0x2>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 5dc:	8d e0       	ldi	r24, 0x0D	; 13
 5de:	8a 95       	dec	r24
 5e0:	f1 f7       	brne	.-4      	; 0x5de <USI_TWI_Master_Start()+0x8>
 5e2:	00 00       	nop
USI_TWI_Master_Start():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:296
  _delay_us(T2_TWI);

/* Generate Start Condition */
  PORT_USI &= ~(1<<PIN_USI_SDA);                    // Force SDA LOW.
 5e4:	c0 98       	cbi	0x18, 0	; 24
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 5e6:	8a e0       	ldi	r24, 0x0A	; 10
 5e8:	8a 95       	dec	r24
 5ea:	f1 f7       	brne	.-4      	; 0x5e8 <USI_TWI_Master_Start()+0x12>
 5ec:	00 c0       	rjmp	.+0      	; 0x5ee <USI_TWI_Master_Start()+0x18>
USI_TWI_Master_Start():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:298
	_delay_us(T4_TWI);                         
  PORT_USI &= ~(1<<PIN_USI_SCL);                    // Pull SCL LOW.
 5ee:	c2 98       	cbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:299
  PORT_USI |= (1<<PIN_USI_SDA);                     // Release SDA.
 5f0:	c0 9a       	sbi	0x18, 0	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:302

#ifdef SIGNAL_VERIFY
  if( !(USISR & (1<<USISIF)) )
 5f2:	77 99       	sbic	0x0e, 7	; 14
 5f4:	05 c0       	rjmp	.+10     	; 0x600 <USI_TWI_Master_Start()+0x2a>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:304
  {
    USI_TWI_state.errorState = USI_TWI_MISSING_START_CON;  
 5f6:	83 e0       	ldi	r24, 0x03	; 3
 5f8:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:305
    return (FALSE);
 5fc:	80 e0       	ldi	r24, 0x00	; 0
 5fe:	08 95       	ret
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:308
  }
#endif
  return (TRUE);
 600:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:309
}
 602:	08 95       	ret

00000604 <USI_TWI_Master_Transfer(unsigned char)>:
USI_TWI_Master_Transfer():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:263
 Data to be sent has to be placed into the USIDR prior to calling
 this function. Data read, will be return'ed from the function.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Transfer( unsigned char temp )
{
  USISR = temp;                                     // Set USISR according to temp.
 604:	8e b9       	out	0x0e, r24	; 14
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:272
           (1<<USICS1)|(0<<USICS0)|(1<<USICLK)|     // Software clock strobe as source.
           (1<<USITC);                              // Toggle Clock Port.
  do
  { 
	_delay_us(T2_TWI);
    USICR = temp;                          // Generate positve SCL edge.
 606:	8b e2       	ldi	r24, 0x2B	; 43
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 608:	9d e0       	ldi	r25, 0x0D	; 13
 60a:	9a 95       	dec	r25
 60c:	f1 f7       	brne	.-4      	; 0x60a <USI_TWI_Master_Transfer(unsigned char)+0x6>
 60e:	00 00       	nop
USI_TWI_Master_Transfer():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:272
 610:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:273
    while( !(PIN_USI & (1<<PIN_USI_SCL)) );// Wait for SCL to go high.
 612:	b2 9b       	sbis	0x16, 2	; 22
 614:	fe cf       	rjmp	.-4      	; 0x612 <USI_TWI_Master_Transfer(unsigned char)+0xe>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 616:	9a e0       	ldi	r25, 0x0A	; 10
 618:	9a 95       	dec	r25
 61a:	f1 f7       	brne	.-4      	; 0x618 <USI_TWI_Master_Transfer(unsigned char)+0x14>
 61c:	00 c0       	rjmp	.+0      	; 0x61e <USI_TWI_Master_Transfer(unsigned char)+0x1a>
USI_TWI_Master_Transfer():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:275
	_delay_us(T4_TWI);
    USICR = temp;                          // Generate negative SCL edge.
 61e:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:276
  }while( !(USISR & (1<<USIOIF)) );        // Check for transfer complete.
 620:	76 9b       	sbis	0x0e, 6	; 14
 622:	f2 cf       	rjmp	.-28     	; 0x608 <USI_TWI_Master_Transfer(unsigned char)+0x4>
_delay_us():
 624:	8d e0       	ldi	r24, 0x0D	; 13
 626:	8a 95       	dec	r24
 628:	f1 f7       	brne	.-4      	; 0x626 <USI_TWI_Master_Transfer(unsigned char)+0x22>
 62a:	00 00       	nop
USI_TWI_Master_Transfer():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:279
  
	_delay_us(T2_TWI);
  temp  = USIDR;                           // Read out data.
 62c:	8f b1       	in	r24, 0x0f	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:280
  USIDR = 0xFF;                            // Release SDA.
 62e:	9f ef       	ldi	r25, 0xFF	; 255
 630:	9f b9       	out	0x0f, r25	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:281
  DDR_USI |= (1<<PIN_USI_SDA);             // Enable SDA as output.
 632:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:284

  return temp;                             // Return the data from the USIDR
}
 634:	08 95       	ret

00000636 <tinywirem_endTransmission()>:
tinywirem_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:25

static bool tinywirem_write(uint8_t byte) {
	return TinyWireM.write(byte);
}

static void tinywirem_endTransmission(void) {
 636:	cf 92       	push	r12
 638:	df 92       	push	r13
 63a:	ef 92       	push	r14
 63c:	ff 92       	push	r15
 63e:	0f 93       	push	r16
 640:	1f 93       	push	r17
 642:	cf 93       	push	r28
 644:	df 93       	push	r29
endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:66
}

uint8_t USI_TWI::endTransmission(uint8_t stop){ // actually sends the buffer
  bool xferOK = false;
  uint8_t errorCode = 0;
  xferOK = USI_TWI_Start_Read_Write(USI_Buf,USI_BufIdx+1); // core func that does the work
 646:	00 91 7c 00 	lds	r16, 0x007C	; 0x80007c <USI_TWI::USI_BufIdx>
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:140
	unsigned char savedMsgSize; 

//This clear must be done before calling this function so that memReadMode can be specified.
//  USI_TWI_state.errorState = 0;				// Clears all mode bits also

  USI_TWI_state.addressMode = TRUE;			// Always true for first byte
 64a:	81 e0       	ldi	r24, 0x01	; 1
 64c:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:173
    USI_TWI_state.errorState = USI_TWI_UE_DATA_COL;
    return (FALSE);
  }
#endif

  if ( !(*msg & (1<<TWI_READ_BIT)) )                // The LSB in the address byte determines if is a masterRead or masterWrite operation.
 650:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <__data_end>
 654:	80 fd       	sbrc	r24, 0
 656:	03 c0       	rjmp	.+6      	; 0x65e <tinywirem_endTransmission()+0x28>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:175
  {
    USI_TWI_state.masterWriteDataMode = TRUE;
 658:	83 e0       	ldi	r24, 0x03	; 3
 65a:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:184
//	{
		savedMsg = msg;
		savedMsgSize = msgSize;
//	}

	if ( !USI_TWI_Master_Start( ))
 65e:	bb df       	rcall	.-138    	; 0x5d6 <USI_TWI_Master_Start()>
 660:	88 23       	and	r24, r24
 662:	11 f1       	breq	.+68     	; 0x6a8 <tinywirem_endTransmission()+0x72>
endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:66
 664:	0f 5f       	subi	r16, 0xFF	; 255
 666:	10 2f       	mov	r17, r16
 668:	ca e6       	ldi	r28, 0x6A	; 106
 66a:	d0 e0       	ldi	r29, 0x00	; 0
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:240
      *(msg++)  = USI_TWI_Master_Transfer( tempUSISR_8bit );

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if( msgSize == 1)                            // If transmission of last byte was performed.
      {
        USIDR = 0xFF;                              // Load NACK to confirm End Of Transmission.
 66c:	dd 24       	eor	r13, r13
 66e:	da 94       	dec	r13
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:216
	  if ((!USI_TWI_state.addressMode) && USI_TWI_state.memReadMode)// means memory start address has been written
	  {
		msg = savedMsg;					// start at slave address again
		*(msg) |= (TRUE<<TWI_READ_BIT);  // set the Read Bit on Slave address
		USI_TWI_state.errorState = 0;
		USI_TWI_state.addressMode = TRUE;	// Now set up for the Read cycle
 670:	cc 24       	eor	r12, r12
 672:	c3 94       	inc	r12
 674:	7e 01       	movw	r14, r28
 676:	8f ef       	ldi	r24, 0xFF	; 255
 678:	e8 1a       	sub	r14, r24
 67a:	f8 0a       	sbc	r15, r24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:193

/*Write address and Read/Write data */
  do
  {
    /* If masterWrite cycle (or inital address tranmission)*/
    if (USI_TWI_state.addressMode || USI_TWI_state.masterWriteDataMode)
 67c:	80 91 84 00 	lds	r24, 0x0084	; 0x800084 <USI_TWI_state>
 680:	83 70       	andi	r24, 0x03	; 3
 682:	09 f4       	brne	.+2      	; 0x686 <tinywirem_endTransmission()+0x50>
 684:	47 c0       	rjmp	.+142    	; 0x714 <tinywirem_endTransmission()+0xde>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:196
    {
      /* Write a byte */
      PORT_USI &= ~(1<<PIN_USI_SCL);                // Pull SCL LOW.
 686:	c2 98       	cbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:197
      USIDR     = *(msg++);                        // Setup data.
 688:	88 81       	ld	r24, Y
 68a:	8f b9       	out	0x0f, r24	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:198
      USI_TWI_Master_Transfer( tempUSISR_8bit );    // Send 8 bits on bus.
 68c:	80 ef       	ldi	r24, 0xF0	; 240
 68e:	ba df       	rcall	.-140    	; 0x604 <USI_TWI_Master_Transfer(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:201
      
      /* Clock and verify (N)ACK from slave */
      DDR_USI  &= ~(1<<PIN_USI_SDA);                // Enable SDA as input.
 690:	b8 98       	cbi	0x17, 0	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:202
      if( USI_TWI_Master_Transfer( tempUSISR_1bit ) & (1<<TWI_NACK_BIT) ) 
 692:	8e ef       	ldi	r24, 0xFE	; 254
 694:	b7 df       	rcall	.-146    	; 0x604 <USI_TWI_Master_Transfer(unsigned char)>
 696:	90 91 84 00 	lds	r25, 0x0084	; 0x800084 <USI_TWI_state>
 69a:	80 ff       	sbrs	r24, 0
 69c:	10 c0       	rjmp	.+32     	; 0x6be <tinywirem_endTransmission()+0x88>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:205
      {
        if ( USI_TWI_state.addressMode )
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 69e:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:204
      
      /* Clock and verify (N)ACK from slave */
      DDR_USI  &= ~(1<<PIN_USI_SDA);                // Enable SDA as input.
      if( USI_TWI_Master_Transfer( tempUSISR_1bit ) & (1<<TWI_NACK_BIT) ) 
      {
        if ( USI_TWI_state.addressMode )
 6a0:	90 ff       	sbrs	r25, 0
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:207
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
 6a2:	82 e0       	ldi	r24, 0x02	; 2
 6a4:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:67
  USI_BufIdx = 0;
 6a8:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <USI_TWI::USI_BufIdx>
tinywirem_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_TinyWireM.h:27
	TinyWireM.endTransmission();
}
 6ac:	df 91       	pop	r29
 6ae:	cf 91       	pop	r28
 6b0:	1f 91       	pop	r17
 6b2:	0f 91       	pop	r16
 6b4:	ff 90       	pop	r15
 6b6:	ef 90       	pop	r14
 6b8:	df 90       	pop	r13
 6ba:	cf 90       	pop	r12
 6bc:	08 95       	ret
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:211
        return (FALSE);
      }
	  
	  if ((!USI_TWI_state.addressMode) && USI_TWI_state.memReadMode)// means memory start address has been written
 6be:	89 2f       	mov	r24, r25
 6c0:	85 70       	andi	r24, 0x05	; 5
 6c2:	84 30       	cpi	r24, 0x04	; 4
 6c4:	61 f4       	brne	.+24     	; 0x6de <tinywirem_endTransmission()+0xa8>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:214
	  {
		msg = savedMsg;					// start at slave address again
		*(msg) |= (TRUE<<TWI_READ_BIT);  // set the Read Bit on Slave address
 6c6:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <__data_end>
 6ca:	81 60       	ori	r24, 0x01	; 1
 6cc:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__data_end>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:216
		USI_TWI_state.errorState = 0;
		USI_TWI_state.addressMode = TRUE;	// Now set up for the Read cycle
 6d0:	c0 92 84 00 	sts	0x0084, r12	; 0x800084 <USI_TWI_state>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:219
		msgSize = savedMsgSize;				// Set byte count correctly
		// NOte that the length should be Slave adrs byte + # bytes to read + 1 (gets decremented below)
		if ( !USI_TWI_Master_Start( ))
 6d4:	80 df       	rcall	.-256    	; 0x5d6 <USI_TWI_Master_Start()>
 6d6:	81 11       	cpse	r24, r1
 6d8:	29 c0       	rjmp	.+82     	; 0x72c <tinywirem_endTransmission()+0xf6>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:221
		{
			USI_TWI_state.errorState = USI_TWI_BAD_MEM_READ;
 6da:	8a e0       	ldi	r24, 0x0A	; 10
 6dc:	e3 cf       	rjmp	.-58     	; 0x6a4 <tinywirem_endTransmission()+0x6e>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:227
			return (FALSE);                           // Send a START condition on the TWI bus.
		}
	  }
	  else
	  {
		USI_TWI_state.addressMode = FALSE;            // Only perform address transmission once.
 6de:	9e 7f       	andi	r25, 0xFE	; 254
 6e0:	90 93 84 00 	sts	0x0084, r25	; 0x800084 <USI_TWI_state>
tinywirem_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:235
    /* Else masterRead cycle*/
    else
    {
      /* Read a data byte */
      DDR_USI   &= ~(1<<PIN_USI_SDA);               // Enable SDA as input.
      *(msg++)  = USI_TWI_Master_Transfer( tempUSISR_8bit );
 6e4:	e7 01       	movw	r28, r14
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:248
      {
        USIDR = 0x00;                              // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer( tempUSISR_1bit );   // Generate ACK/NACK.
    }
  }while( --msgSize) ;                             // Until all data sent/received.
 6e6:	11 50       	subi	r17, 0x01	; 1
 6e8:	29 f6       	brne	.-118    	; 0x674 <tinywirem_endTransmission()+0x3e>
endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/TinyWireM.cpp:67
 6ea:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <USI_TWI::USI_BufIdx>
USI_TWI_Master_Stop():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:316
 Function for generating a TWI Stop Condition. Used to release 
 the TWI bus.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Stop( void )
{
  PORT_USI &= ~(1<<PIN_USI_SDA);           // Pull SDA low.
 6ee:	c0 98       	cbi	0x18, 0	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:317
  PORT_USI |= (1<<PIN_USI_SCL);            // Release SCL.
 6f0:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:318
  while( !(PIN_USI & (1<<PIN_USI_SCL)) );  // Wait for SCL to go high.  
 6f2:	b2 9b       	sbis	0x16, 2	; 22
 6f4:	fe cf       	rjmp	.-4      	; 0x6f2 <tinywirem_endTransmission()+0xbc>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 6f6:	8a e0       	ldi	r24, 0x0A	; 10
 6f8:	8a 95       	dec	r24
 6fa:	f1 f7       	brne	.-4      	; 0x6f8 <tinywirem_endTransmission()+0xc2>
 6fc:	00 c0       	rjmp	.+0      	; 0x6fe <tinywirem_endTransmission()+0xc8>
USI_TWI_Master_Stop():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:320
	_delay_us(T4_TWI);
  PORT_USI |= (1<<PIN_USI_SDA);            // Release SDA.
 6fe:	c0 9a       	sbi	0x18, 0	; 24
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 700:	8d e0       	ldi	r24, 0x0D	; 13
 702:	8a 95       	dec	r24
 704:	f1 f7       	brne	.-4      	; 0x702 <tinywirem_endTransmission()+0xcc>
 706:	00 00       	nop
USI_TWI_Master_Stop():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:324
	_delay_us(T2_TWI);
  
#ifdef SIGNAL_VERIFY
  if( !(USISR & (1<<USIPF)) )
 708:	75 99       	sbic	0x0e, 5	; 14
 70a:	d0 cf       	rjmp	.-96     	; 0x6ac <tinywirem_endTransmission()+0x76>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:326
  {
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;    
 70c:	84 e0       	ldi	r24, 0x04	; 4
 70e:	80 93 84 00 	sts	0x0084, r24	; 0x800084 <USI_TWI_state>
 712:	cc cf       	rjmp	.-104    	; 0x6ac <tinywirem_endTransmission()+0x76>
USI_TWI_Start_Transceiver_With_Data():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:234
    }
    /* Else masterRead cycle*/
    else
    {
      /* Read a data byte */
      DDR_USI   &= ~(1<<PIN_USI_SDA);               // Enable SDA as input.
 714:	b8 98       	cbi	0x17, 0	; 23
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:235
      *(msg++)  = USI_TWI_Master_Transfer( tempUSISR_8bit );
 716:	80 ef       	ldi	r24, 0xF0	; 240
 718:	75 df       	rcall	.-278    	; 0x604 <USI_TWI_Master_Transfer(unsigned char)>
 71a:	88 83       	st	Y, r24
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:238

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if( msgSize == 1)                            // If transmission of last byte was performed.
 71c:	11 30       	cpi	r17, 0x01	; 1
 71e:	21 f4       	brne	.+8      	; 0x728 <tinywirem_endTransmission()+0xf2>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:240
      {
        USIDR = 0xFF;                              // Load NACK to confirm End Of Transmission.
 720:	df b8       	out	0x0f, r13	; 15
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:246
      }
      else
      {
        USIDR = 0x00;                              // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer( tempUSISR_1bit );   // Generate ACK/NACK.
 722:	8e ef       	ldi	r24, 0xFE	; 254
 724:	6f df       	rcall	.-290    	; 0x604 <USI_TWI_Master_Transfer(unsigned char)>
 726:	de cf       	rjmp	.-68     	; 0x6e4 <tinywirem_endTransmission()+0xae>
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:244
      {
        USIDR = 0xFF;                              // Load NACK to confirm End Of Transmission.
      }
      else
      {
        USIDR = 0x00;                              // Load ACK. Set data register bit 7 (output for SDA) low.
 728:	1f b8       	out	0x0f, r1	; 15
 72a:	fb cf       	rjmp	.-10     	; 0x722 <tinywirem_endTransmission()+0xec>
tinywirem_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:217
	  {
		msg = savedMsg;					// start at slave address again
		*(msg) |= (TRUE<<TWI_READ_BIT);  // set the Read Bit on Slave address
		USI_TWI_state.errorState = 0;
		USI_TWI_state.addressMode = TRUE;	// Now set up for the Read cycle
		msgSize = savedMsgSize;				// Set byte count correctly
 72c:	10 2f       	mov	r17, r16
C:\Users\Pavel\Documents\Arduino\libraries\TinyWireM/USI_TWI_Master.cpp:213
        return (FALSE);
      }
	  
	  if ((!USI_TWI_state.addressMode) && USI_TWI_state.memReadMode)// means memory start address has been written
	  {
		msg = savedMsg;					// start at slave address again
 72e:	ca e6       	ldi	r28, 0x6A	; 106
 730:	d0 e0       	ldi	r29, 0x00	; 0
 732:	d9 cf       	rjmp	.-78     	; 0x6e6 <tinywirem_endTransmission()+0xb0>

00000734 <__vector_5>:
__vector_5():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:130
#else

#error Millis() timer not defined!

#endif
{
 734:	1f 92       	push	r1
 736:	0f 92       	push	r0
 738:	0f b6       	in	r0, 0x3f	; 63
 73a:	0f 92       	push	r0
 73c:	11 24       	eor	r1, r1
 73e:	2f 93       	push	r18
 740:	3f 93       	push	r19
 742:	8f 93       	push	r24
 744:	9f 93       	push	r25
 746:	af 93       	push	r26
 748:	bf 93       	push	r27
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:133
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
 74a:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <millis_timer_millis>
 74e:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <millis_timer_millis+0x1>
 752:	a0 91 88 00 	lds	r26, 0x0088	; 0x800088 <millis_timer_millis+0x2>
 756:	b0 91 89 00 	lds	r27, 0x0089	; 0x800089 <millis_timer_millis+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:134
  unsigned char f = millis_timer_fract;
 75a:	30 91 85 00 	lds	r19, 0x0085	; 0x800085 <millis_timer_fract>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:146
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
 75e:	26 e0       	ldi	r18, 0x06	; 6
 760:	23 0f       	add	r18, r19
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:148

  if (f >= FRACT_MAX)
 762:	2d 37       	cpi	r18, 0x7D	; 125
 764:	68 f1       	brcs	.+90     	; 0x7c0 <__vector_5+0x8c>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:150
  {
    f -= FRACT_MAX;
 766:	29 e8       	ldi	r18, 0x89	; 137
 768:	23 0f       	add	r18, r19
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:152
  m += 1;
    m += MILLIS_INC;
 76a:	03 96       	adiw	r24, 0x03	; 3
 76c:	a1 1d       	adc	r26, r1
 76e:	b1 1d       	adc	r27, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:159
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
 770:	20 93 85 00 	sts	0x0085, r18	; 0x800085 <millis_timer_fract>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:160
  millis_timer_millis = m;
 774:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <millis_timer_millis>
 778:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <millis_timer_millis+0x1>
 77c:	a0 93 88 00 	sts	0x0088, r26	; 0x800088 <millis_timer_millis+0x2>
 780:	b0 93 89 00 	sts	0x0089, r27	; 0x800089 <millis_timer_millis+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:161
  millis_timer_overflow_count++;
 784:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <millis_timer_overflow_count>
 788:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <millis_timer_overflow_count+0x1>
 78c:	a0 91 8c 00 	lds	r26, 0x008C	; 0x80008c <millis_timer_overflow_count+0x2>
 790:	b0 91 8d 00 	lds	r27, 0x008D	; 0x80008d <millis_timer_overflow_count+0x3>
 794:	01 96       	adiw	r24, 0x01	; 1
 796:	a1 1d       	adc	r26, r1
 798:	b1 1d       	adc	r27, r1
 79a:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <millis_timer_overflow_count>
 79e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <millis_timer_overflow_count+0x1>
 7a2:	a0 93 8c 00 	sts	0x008C, r26	; 0x80008c <millis_timer_overflow_count+0x2>
 7a6:	b0 93 8d 00 	sts	0x008D, r27	; 0x80008d <millis_timer_overflow_count+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:168

//MICROSECONDS_PER_MILLIS_OVERFLOW=2048
//MILLIS_INC=2
//FRACT_INC=6
//FRACT_MAX=125
}
 7aa:	bf 91       	pop	r27
 7ac:	af 91       	pop	r26
 7ae:	9f 91       	pop	r25
 7b0:	8f 91       	pop	r24
 7b2:	3f 91       	pop	r19
 7b4:	2f 91       	pop	r18
 7b6:	0f 90       	pop	r0
 7b8:	0f be       	out	0x3f, r0	; 63
 7ba:	0f 90       	pop	r0
 7bc:	1f 90       	pop	r1
 7be:	18 95       	reti
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:156
  m += 1;
    m += MILLIS_INC;
  }
  else
  {
    m += MILLIS_INC;
 7c0:	02 96       	adiw	r24, 0x02	; 2
 7c2:	a1 1d       	adc	r26, r1
 7c4:	b1 1d       	adc	r27, r1
 7c6:	d4 cf       	rjmp	.-88     	; 0x770 <__vector_5+0x3c>

000007c8 <__vector_9>:
__vector_9():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:195
  bitClear(PORTB, 3);
  //tmrval1 = TCNT1;
}

//ISR(TIMER1_OVF_vect){
ISR(TIMER1_COMPB_vect){
 7c8:	1f 92       	push	r1
 7ca:	0f 92       	push	r0
 7cc:	0f b6       	in	r0, 0x3f	; 63
 7ce:	0f 92       	push	r0
 7d0:	11 24       	eor	r1, r1
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:197
  //clear pin
  bitSet(PORTB, 3);
 7d2:	c3 9a       	sbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:199
  //tmrval = TCNT1;
}
 7d4:	0f 90       	pop	r0
 7d6:	0f be       	out	0x3f, r0	; 63
 7d8:	0f 90       	pop	r0
 7da:	1f 90       	pop	r1
 7dc:	18 95       	reti

000007de <__vector_3>:
__vector_3():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:188
  WDTCR = (1<<WDE) | (1<<WDP1) | (1<<WDP2); // 1s
  sei();
}


ISR(TIMER1_COMPA_vect){
 7de:	1f 92       	push	r1
 7e0:	0f 92       	push	r0
 7e2:	0f b6       	in	r0, 0x3f	; 63
 7e4:	0f 92       	push	r0
 7e6:	11 24       	eor	r1, r1
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:190
  // set pin
  bitClear(PORTB, 3);
 7e8:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:192
  //tmrval1 = TCNT1;
}
 7ea:	0f 90       	pop	r0
 7ec:	0f be       	out	0x3f, r0	; 63
 7ee:	0f 90       	pop	r0
 7f0:	1f 90       	pop	r1
 7f2:	18 95       	reti

000007f4 <main>:
main():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/main.cpp:6
#include <Arduino.h>

int main(void)
{
  #ifdef TUNED_OSCCAL_VALUE
  OSCCAL = TUNED_OSCCAL_VALUE; //set the oscillator calibration value based on the pins_arduino.h file. If this is not set, it will be optimised away
 7f4:	81 b7       	in	r24, 0x31	; 49
 7f6:	81 bf       	out	0x31, r24	; 49
init():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:802
  #endif
  #endif

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0) && defined(WGM01)
  sbi(TCCR0A, WGM01);
 7f8:	8a b5       	in	r24, 0x2a	; 42
 7fa:	82 60       	ori	r24, 0x02	; 2
 7fc:	8a bd       	out	0x2a, r24	; 42
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:803
  sbi(TCCR0A, WGM00);
 7fe:	8a b5       	in	r24, 0x2a	; 42
 800:	81 60       	ori	r24, 0x01	; 1
 802:	8a bd       	out	0x2a, r24	; 42
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:826
  #endif

  // Millis timer is always processor clock divided by MillisTimer_Prescale_Value (64)
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
   #ifdef TCCR0B
    TCCR0B = (TCCR0B & ~((1<<CS02)|(1<<CS01)|(1<<CS00))) | (MillisTimer_Prescale_Index << CS00);
 804:	83 b7       	in	r24, 0x33	; 51
 806:	88 7f       	andi	r24, 0xF8	; 248
 808:	83 60       	ori	r24, 0x03	; 3
 80a:	83 bf       	out	0x33, r24	; 51
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:838
  TCCR1B = (TCCR1B & ~((1<<CS13)|(1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #elif (TIMER_TO_USE_FOR_MILLIS == 1)
  TCCR1B = (TCCR1B & ~((1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #endif
  // this needs to be called before setup() or some functions won't work there
  sei();
 80c:	78 94       	sei
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:842

  // Enable the overlow interrupt (this is the basic system tic-toc for millis)
  #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  sbi(TIMSK, TOIE0);
 80e:	89 b7       	in	r24, 0x39	; 57
 810:	82 60       	ori	r24, 0x02	; 2
 812:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:504
  TCCR0B |= (ToneTimer_Prescale_Index << CS00);
  #elif defined(__AVR_ATtiny43__)
  TCCR1A = 3; //WGM 10=1, WGM11=1
  TCCR1B = 3; //prescaler of 64
  #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1)
  TCCR1 &= ~((1<<CS13) | (1<<CS12) | (1<<CS11) | (1<<CS10)); //stop the clock to configure
 814:	80 b7       	in	r24, 0x30	; 48
 816:	80 7f       	andi	r24, 0xF0	; 240
 818:	80 bf       	out	0x30, r24	; 48
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:506
  // Use the Tone Timer for fast PWM as phase correct not supported by this timer
  sbi(TCCR1, CTC1);
 81a:	80 b7       	in	r24, 0x30	; 48
 81c:	80 68       	ori	r24, 0x80	; 128
 81e:	80 bf       	out	0x30, r24	; 48
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:508
  //#if !defined(__AVR_ATtiny85__)
  sbi(TCCR1, PWM1A); //for the tiny 85, Timer0 is used instead.
 820:	80 b7       	in	r24, 0x30	; 48
 822:	80 64       	ori	r24, 0x40	; 64
 824:	80 bf       	out	0x30, r24	; 48
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:510
  //#endif
  sbi(GTCCR, PWM1B);
 826:	8c b5       	in	r24, 0x2c	; 44
 828:	80 64       	ori	r24, 0x40	; 64
 82a:	8c bd       	out	0x2c, r24	; 44
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:511
  OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
 82c:	8f ef       	ldi	r24, 0xFF	; 255
 82e:	8d bd       	out	0x2d, r24	; 45
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:512
  TCCR1 |= (ToneTimer_Prescale_Index << CS10);
 830:	80 b7       	in	r24, 0x30	; 48
 832:	87 60       	ori	r24, 0x07	; 7
 834:	80 bf       	out	0x30, r24	; 48
init():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:862

  // Initialize the ADC
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
  #if defined(ADCSRA)
    // set a2d prescale factor
  ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 836:	86 b1       	in	r24, 0x06	; 6
 838:	88 77       	andi	r24, 0x78	; 120
 83a:	86 68       	ori	r24, 0x86	; 134
 83c:	86 b9       	out	0x06, r24	; 6
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/wiring.c:864
    // enable a2d conversions
    sbi(ADCSRA, ADEN);
 83e:	37 9a       	sbi	0x06, 7	; 6
setup():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:130
  wdt_disable();
}

void setup() {
  //stop motor
  bitClear(PORTB, 3);
 840:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:131
  bitSet(DDRB, 3);
 842:	bb 9a       	sbi	0x17, 3	; 23
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:133

  bitClear(DDRB, 1); // Input
 844:	b9 98       	cbi	0x17, 1	; 23
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:134
  bitSet(PORTB, 1); // Enable pullup
 846:	c1 9a       	sbi	0x18, 1	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:136

  disableWatchdog();
 848:	5a de       	rcall	.-844    	; 0x4fe <disableWatchdog()>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:139
  
  // configure ADC
  ADMUX =
 84a:	82 e0       	ldi	r24, 0x02	; 2
 84c:	87 b9       	out	0x07, r24	; 7
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:148
           (0 << REFS0) |     // Sets ref. voltage to VCC
           (0 << MUX3)  |     // use ADC2 for input (PB4)
           (0 << MUX2)  |     // use ADC2 for input (PB4)
           (1 << MUX1)  |     // use ADC2 for input (PB4)
           (0 << MUX0);       // use ADC2 for input (PB4)
 ADCSRA = 
 84e:	87 e8       	ldi	r24, 0x87	; 135
 850:	86 b9       	out	0x06, r24	; 6
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:155
           (1 << ADPS2) |     // set prescaler to 64, bit 2 
           (1 << ADPS1) |     // set prescaler to 64, bit 1 
           (1 << ADPS0);      // set prescaler to 64, bit 0 


  ADCSRA |= (1 << ADSC); // start first conversion
 852:	36 9a       	sbi	0x06, 6	; 6
ssd1306_begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:57
static void (*wireBeginTransmissionFn)(uint8_t i2c_address);
static bool (*wireWriteFn)(uint8_t byte);
static void (*wireEndTransmissionFn)(void);

static void ssd1306_begin(void) {
	wireBeginFn();
 854:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <wireBeginFn>
 858:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <wireBeginFn+0x1>
 85c:	09 95       	icall
begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:157
}

void SSD1306Device::begin(uint8_t init_sequence_length, const uint8_t init_sequence []) {
	ssd1306_begin();

	ssd1306_send_command_start();
 85e:	8b dd       	rcall	.-1258   	; 0x376 <ssd1306_send_command_start()>
 860:	c2 ef       	ldi	r28, 0xF2	; 242
 862:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:159
	for (uint8_t i = 0; i < init_sequence_length; i++) {
		ssd1306_send_command_byte(pgm_read_byte(&init_sequence[i]));
 864:	fe 01       	movw	r30, r28
 866:	14 91       	lpm	r17, Z
ssd1306_send_command_byte():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:83
	ssd1306_send_start(i2c_address);
	ssd1306_send_byte(SSD1306_DATA);
}

static void ssd1306_send_command_byte(uint8_t byte) {
	if (ssd1306_send_byte(byte) == 0) {
 868:	81 2f       	mov	r24, r17
 86a:	6b dd       	rcall	.-1322   	; 0x342 <ssd1306_send_byte(unsigned char)>
 86c:	81 11       	cpse	r24, r1
 86e:	04 c0       	rjmp	.+8      	; 0x878 <main+0x84>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:84
		ssd1306_send_stop();
 870:	63 dd       	rcall	.-1338   	; 0x338 <ssd1306_send_stop()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:85
		ssd1306_send_command_start();
 872:	81 dd       	rcall	.-1278   	; 0x376 <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:86
		ssd1306_send_byte(byte);
 874:	81 2f       	mov	r24, r17
 876:	65 dd       	rcall	.-1334   	; 0x342 <ssd1306_send_byte(unsigned char)>
 878:	21 96       	adiw	r28, 0x01	; 1
begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:158

void SSD1306Device::begin(uint8_t init_sequence_length, const uint8_t init_sequence []) {
	ssd1306_begin();

	ssd1306_send_command_start();
	for (uint8_t i = 0; i < init_sequence_length; i++) {
 87a:	f0 e0       	ldi	r31, 0x00	; 0
 87c:	ca 3f       	cpi	r28, 0xFA	; 250
 87e:	df 07       	cpc	r29, r31
 880:	89 f7       	brne	.-30     	; 0x864 <main+0x70>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:161
		ssd1306_send_command_byte(pgm_read_byte(&init_sequence[i]));
	}
	ssd1306_send_stop();
 882:	5a dd       	rcall	.-1356   	; 0x338 <ssd1306_send_stop()>
clear():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:175
	oledX = x;
	oledY = y;
}

void SSD1306Device::clear(void) {
	fill(0x00);
 884:	d2 dd       	rcall	.-1116   	; 0x42a <SSD1306Device::fill(unsigned char) [clone .constprop.4]>
setup():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:162
  #ifdef ENABLEFONT
  oled.setFont(FONT8X16);
  #endif
  oled.begin();
  oled.clear();
  draw_Bat(0); // prefill bufer with empty battery bitmap
 886:	80 e0       	ldi	r24, 0x00	; 0
 888:	63 de       	rcall	.-826    	; 0x550 <draw_Bat(unsigned char)>
ssd1306_send_command():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:99
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_command(uint8_t command) {
	ssd1306_send_command_start();
 88a:	75 dd       	rcall	.-1302   	; 0x376 <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:100
	ssd1306_send_byte(command);
 88c:	8f ea       	ldi	r24, 0xAF	; 175
 88e:	59 dd       	rcall	.-1358   	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:101
	ssd1306_send_stop();
 890:	53 dd       	rcall	.-1370   	; 0x338 <ssd1306_send_stop()>
switchRenderFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:304
}

// Double Buffering Commands

void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
 892:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <renderingFrame>
 896:	94 e0       	ldi	r25, 0x04	; 4
 898:	89 27       	eor	r24, r25
 89a:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <renderingFrame>
setup():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:165
  oled.on();
  oled.switchRenderFrame();
  delay(50);
 89e:	62 e3       	ldi	r22, 0x32	; 50
 8a0:	70 e0       	ldi	r23, 0x00	; 0
 8a2:	80 e0       	ldi	r24, 0x00	; 0
 8a4:	90 e0       	ldi	r25, 0x00	; 0
 8a6:	1e dd       	rcall	.-1476   	; 0x2e4 <delay>
clear():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:175
	oledX = x;
	oledY = y;
}

void SSD1306Device::clear(void) {
	fill(0x00);
 8a8:	c0 dd       	rcall	.-1152   	; 0x42a <SSD1306Device::fill(unsigned char) [clone .constprop.4]>
setup():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:169
  oled.clear(); //clear invisible frame

  //if switch is ON then show warning
  if(getButtonState()==0){
 8aa:	32 de       	rcall	.-924    	; 0x510 <getButtonState()>
 8ac:	81 11       	cpse	r24, r1
 8ae:	0b c0       	rjmp	.+22     	; 0x8c6 <main+0xd2>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:170
    oled.bitmap(128-32,0,32,4,stateDANGER);
 8b0:	4a e7       	ldi	r20, 0x7A	; 122
 8b2:	51 e0       	ldi	r21, 0x01	; 1
 8b4:	60 e2       	ldi	r22, 0x20	; 32
 8b6:	80 e6       	ldi	r24, 0x60	; 96
 8b8:	85 dd       	rcall	.-1270   	; 0x3c4 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:171
    oled.switchFrame();
 8ba:	eb dd       	rcall	.-1066   	; 0x492 <SSD1306Device::switchFrame() [clone .constprop.6]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:172
    delay(500);
 8bc:	64 ef       	ldi	r22, 0xF4	; 244
 8be:	71 e0       	ldi	r23, 0x01	; 1
 8c0:	80 e0       	ldi	r24, 0x00	; 0
 8c2:	90 e0       	ldi	r25, 0x00	; 0
 8c4:	0f dd       	rcall	.-1506   	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:175
  }
  //wait until button is released
  while(getButtonState()==0){
 8c6:	24 de       	rcall	.-952    	; 0x510 <getButtonState()>
 8c8:	81 11       	cpse	r24, r1
 8ca:	05 c0       	rjmp	.+10     	; 0x8d6 <main+0xe2>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:177
    // button is pressed
    delay(100);
 8cc:	64 e6       	ldi	r22, 0x64	; 100
 8ce:	70 e0       	ldi	r23, 0x00	; 0
 8d0:	80 e0       	ldi	r24, 0x00	; 0
 8d2:	90 e0       	ldi	r25, 0x00	; 0
 8d4:	f7 cf       	rjmp	.-18     	; 0x8c4 <main+0xd0>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:181
  }  

  // enable 1s watchdog with reset
  cli();
 8d6:	f8 94       	cli
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:182
  WDTCR = (1<<WDCE);
 8d8:	80 e1       	ldi	r24, 0x10	; 16
 8da:	81 bd       	out	0x21, r24	; 33
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:183
  WDTCR = (1<<WDE) | (1<<WDP1) | (1<<WDP2); // 1s
 8dc:	8e e0       	ldi	r24, 0x0E	; 14
 8de:	81 bd       	out	0x21, r24	; 33
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:184
  sei();
 8e0:	78 94       	sei
getbatIndicatorVal():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:113
  if(adc128>=V1S6) return 6;
  if(adc128>=V1S5) return 5;
  if(adc128>=V1S4) return 4;
  if(adc128>=V1S3) return 3;
  if(adc128>=V1S2) return 2;
  if(adc128>=V1S1) return 1;
 8e2:	bb 24       	eor	r11, r11
 8e4:	b3 94       	inc	r11
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:217
}

// start motor smoothly
bool startMotor(void){
  cli();
  OCR1A = 95; // value to test
 8e6:	df e5       	ldi	r29, 0x5F	; 95
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:218
  OCR1B = 255; // value to test	
 8e8:	1f ef       	ldi	r17, 0xFF	; 255
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:219
  TCCR1 = (1<<CS13) | (1<<CS11) ; // Fast PWM mode (value 3)
 8ea:	0a e0       	ldi	r16, 0x0A	; 10
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:261
	delay(5);
    bitClear(PORTB,3);  
}

void loop() {  
  wdt_reset();
 8ec:	a8 95       	wdr
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:262
  uint16_t rawadc = readADC();
 8ee:	f1 dd       	rcall	.-1054   	; 0x4d2 <readADC()>
getbatIndicatorVal():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:107
// 3.85v - 66%
// 4.0v - 83%
// 4.2v - 100%

uint8_t getbatIndicatorVal(uint16_t rawadc){
  uint32_t adc128 = (uint32_t)rawadc * 128;
 8f0:	b0 e0       	ldi	r27, 0x00	; 0
 8f2:	a0 e0       	ldi	r26, 0x00	; 0
 8f4:	6c 01       	movw	r12, r24
 8f6:	7d 01       	movw	r14, r26
 8f8:	37 e0       	ldi	r19, 0x07	; 7
 8fa:	cc 0c       	add	r12, r12
 8fc:	dd 1c       	adc	r13, r13
 8fe:	ee 1c       	adc	r14, r14
 900:	ff 1c       	adc	r15, r15
 902:	3a 95       	dec	r19
 904:	d1 f7       	brne	.-12     	; 0x8fa <main+0x106>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:108
  if(adc128>=V1S6) return 6;
 906:	86 e0       	ldi	r24, 0x06	; 6
getbatIndicatorVal():
 908:	21 e4       	ldi	r18, 0x41	; 65
 90a:	c2 16       	cp	r12, r18
 90c:	21 e8       	ldi	r18, 0x81	; 129
 90e:	d2 06       	cpc	r13, r18
 910:	21 e0       	ldi	r18, 0x01	; 1
 912:	e2 06       	cpc	r14, r18
 914:	f1 04       	cpc	r15, r1
 916:	70 f5       	brcc	.+92     	; 0x974 <main+0x180>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:109
  if(adc128>=V1S5) return 5;
 918:	84 e5       	ldi	r24, 0x54	; 84
 91a:	c8 16       	cp	r12, r24
 91c:	83 e7       	ldi	r24, 0x73	; 115
 91e:	d8 06       	cpc	r13, r24
 920:	81 e0       	ldi	r24, 0x01	; 1
 922:	e8 06       	cpc	r14, r24
 924:	f1 04       	cpc	r15, r1
 926:	08 f0       	brcs	.+2      	; 0x92a <main+0x136>
 928:	57 c0       	rjmp	.+174    	; 0x9d8 <main+0x1e4>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:110
  if(adc128>=V1S4) return 4;
 92a:	84 e0       	ldi	r24, 0x04	; 4
getbatIndicatorVal():
 92c:	97 e6       	ldi	r25, 0x67	; 103
 92e:	c9 16       	cp	r12, r25
 930:	95 e6       	ldi	r25, 0x65	; 101
 932:	d9 06       	cpc	r13, r25
 934:	91 e0       	ldi	r25, 0x01	; 1
 936:	e9 06       	cpc	r14, r25
 938:	f1 04       	cpc	r15, r1
 93a:	e0 f4       	brcc	.+56     	; 0x974 <main+0x180>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:111
  if(adc128>=V1S3) return 3;
 93c:	83 e0       	ldi	r24, 0x03	; 3
getbatIndicatorVal():
 93e:	ea e7       	ldi	r30, 0x7A	; 122
 940:	ce 16       	cp	r12, r30
 942:	e7 e5       	ldi	r30, 0x57	; 87
 944:	de 06       	cpc	r13, r30
 946:	e1 e0       	ldi	r30, 0x01	; 1
 948:	ee 06       	cpc	r14, r30
 94a:	f1 04       	cpc	r15, r1
 94c:	98 f4       	brcc	.+38     	; 0x974 <main+0x180>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:112
  if(adc128>=V1S2) return 2;
 94e:	82 e0       	ldi	r24, 0x02	; 2
getbatIndicatorVal():
 950:	f3 e3       	ldi	r31, 0x33	; 51
 952:	cf 16       	cp	r12, r31
 954:	fe e4       	ldi	r31, 0x4E	; 78
 956:	df 06       	cpc	r13, r31
 958:	f1 e0       	ldi	r31, 0x01	; 1
 95a:	ef 06       	cpc	r14, r31
 95c:	f1 04       	cpc	r15, r1
 95e:	50 f4       	brcc	.+20     	; 0x974 <main+0x180>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:113
  if(adc128>=V1S1) return 1;
 960:	81 e0       	ldi	r24, 0x01	; 1
 962:	27 ee       	ldi	r18, 0xE7	; 231
 964:	c2 16       	cp	r12, r18
 966:	24 e4       	ldi	r18, 0x44	; 68
 968:	d2 06       	cpc	r13, r18
 96a:	21 e0       	ldi	r18, 0x01	; 1
 96c:	e2 06       	cpc	r14, r18
 96e:	f1 04       	cpc	r15, r1
 970:	08 f4       	brcc	.+2      	; 0x974 <main+0x180>
 972:	80 e0       	ldi	r24, 0x00	; 0
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:266
  wdt_reset();
  uint16_t rawadc = readADC();
  uint8_t batInd = getbatIndicatorVal(rawadc);
  bool batEmpty = isBatteryEmpty(rawadc);
  // redraw screen only when needed (to avoid unnecesarry i2c traffic)
  if(batInd!=prev_batInd || batEmpty){
 974:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <prev_batInd>
 978:	98 13       	cpse	r25, r24
 97a:	08 c0       	rjmp	.+16     	; 0x98c <main+0x198>
 97c:	9f e7       	ldi	r25, 0x7F	; 127
 97e:	c9 16       	cp	r12, r25
 980:	96 e1       	ldi	r25, 0x16	; 22
 982:	d9 06       	cpc	r13, r25
 984:	91 e0       	ldi	r25, 0x01	; 1
 986:	e9 06       	cpc	r14, r25
 988:	f1 04       	cpc	r15, r1
 98a:	c0 f4       	brcc	.+48     	; 0x9bc <main+0x1c8>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:267
    prev_batInd = batInd;
 98c:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <prev_batInd>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:268
	draw_Bat(batInd);
 990:	df dd       	rcall	.-1090   	; 0x550 <draw_Bat(unsigned char)>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:271
    
    if(batEmpty){
      oled.bitmap(128-32,0,32,4,stateDANGER);
 992:	4a e7       	ldi	r20, 0x7A	; 122
 994:	51 e0       	ldi	r21, 0x01	; 1
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:270
  // redraw screen only when needed (to avoid unnecesarry i2c traffic)
  if(batInd!=prev_batInd || batEmpty){
    prev_batInd = batInd;
	draw_Bat(batInd);
    
    if(batEmpty){
 996:	ef e7       	ldi	r30, 0x7F	; 127
 998:	ce 16       	cp	r12, r30
 99a:	e6 e1       	ldi	r30, 0x16	; 22
 99c:	de 06       	cpc	r13, r30
 99e:	e1 e0       	ldi	r30, 0x01	; 1
 9a0:	ee 06       	cpc	r14, r30
 9a2:	f1 04       	cpc	r15, r1
 9a4:	10 f0       	brcs	.+4      	; 0x9aa <main+0x1b6>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:273
      oled.bitmap(128-32,0,32,4,stateDANGER);
    }else{
      oled.bitmap(128-32,0,32,4,stateOK);
 9a6:	4a ef       	ldi	r20, 0xFA	; 250
 9a8:	50 e0       	ldi	r21, 0x00	; 0
 9aa:	60 e2       	ldi	r22, 0x20	; 32
 9ac:	80 e6       	ldi	r24, 0x60	; 96
 9ae:	0a dd       	rcall	.-1516   	; 0x3c4 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:275
    }
    oled.switchFrame();
 9b0:	70 dd       	rcall	.-1312   	; 0x492 <SSD1306Device::switchFrame() [clone .constprop.6]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:276
    delay(50); // make sure, that page switch doesn't occur too often
 9b2:	62 e3       	ldi	r22, 0x32	; 50
 9b4:	70 e0       	ldi	r23, 0x00	; 0
 9b6:	80 e0       	ldi	r24, 0x00	; 0
 9b8:	90 e0       	ldi	r25, 0x00	; 0
 9ba:	94 dc       	rcall	.-1752   	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:279
  }
  // check button and start/stop motor
  if(getButtonState()==1){
 9bc:	a9 dd       	rcall	.-1198   	; 0x510 <getButtonState()>
 9be:	88 23       	and	r24, r24
 9c0:	69 f0       	breq	.+26     	; 0x9dc <main+0x1e8>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:281
    // button is not pressed
	stopMotor();
 9c2:	7a dd       	rcall	.-1292   	; 0x4b8 <stopMotor()>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:290
	if(run_state!=1){
      batEmpty = startMotor();
	}
  }
  // If battery empty - stop the motor and hang the firmware
  if(batEmpty){
 9c4:	2f e7       	ldi	r18, 0x7F	; 127
 9c6:	c2 16       	cp	r12, r18
 9c8:	26 e1       	ldi	r18, 0x16	; 22
 9ca:	d2 06       	cpc	r13, r18
 9cc:	21 e0       	ldi	r18, 0x01	; 1
 9ce:	e2 06       	cpc	r14, r18
 9d0:	f1 04       	cpc	r15, r1
 9d2:	08 f0       	brcs	.+2      	; 0x9d6 <main+0x1e2>
 9d4:	8b cf       	rjmp	.-234    	; 0x8ec <main+0xf8>
 9d6:	2b c0       	rjmp	.+86     	; 0xa2e <main+0x23a>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:109
// 4.2v - 100%

uint8_t getbatIndicatorVal(uint16_t rawadc){
  uint32_t adc128 = (uint32_t)rawadc * 128;
  if(adc128>=V1S6) return 6;
  if(adc128>=V1S5) return 5;
 9d8:	85 e0       	ldi	r24, 0x05	; 5
 9da:	cc cf       	rjmp	.-104    	; 0x974 <main+0x180>
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:285
    // button is not pressed
	stopMotor();
  } else {
    // button is pressed
    // shuld we initiate start process?
	if(run_state!=1){
 9dc:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <run_state>
 9e0:	81 30       	cpi	r24, 0x01	; 1
 9e2:	81 f3       	breq	.-32     	; 0x9c4 <main+0x1d0>
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:216
	  return res32 /32;
}

// start motor smoothly
bool startMotor(void){
  cli();
 9e4:	f8 94       	cli
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:217
  OCR1A = 95; // value to test
 9e6:	de bd       	out	0x2e, r29	; 46
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:218
  OCR1B = 255; // value to test	
 9e8:	1b bd       	out	0x2b, r17	; 43
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:219
  TCCR1 = (1<<CS13) | (1<<CS11) ; // Fast PWM mode (value 3)
 9ea:	00 bf       	out	0x30, r16	; 48
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:221
  //TCCR0B = (0<<WGM02) | (1<<CS02) | (0<<CS01) | (0<<CS00); // Speed (value 3)
  TIMSK |= (1<<OCIE1A) | (1<<OCIE1B) ;//(1<<TOIE1); // enable compare match and overflow interrupts
 9ec:	89 b7       	in	r24, 0x39	; 57
 9ee:	80 66       	ori	r24, 0x60	; 96
 9f0:	89 bf       	out	0x39, r24	; 57
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:222
  sei();
 9f2:	78 94       	sei
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:223
  delay(30);
 9f4:	6e e1       	ldi	r22, 0x1E	; 30
 9f6:	70 e0       	ldi	r23, 0x00	; 0
 9f8:	80 e0       	ldi	r24, 0x00	; 0
 9fa:	90 e0       	ldi	r25, 0x00	; 0
 9fc:	73 dc       	rcall	.-1818   	; 0x2e4 <delay>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:225
  //now motor starts at 50%. Increase the speed to 100%
  for(uint8_t i=100;i<190;i+=5){
 9fe:	c4 e6       	ldi	r28, 0x64	; 100
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:226
    wdt_reset();
 a00:	a8 95       	wdr
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:227
    OCR1A = i;
 a02:	ce bd       	out	0x2e, r28	; 46
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:228
  	delay(25);
 a04:	69 e1       	ldi	r22, 0x19	; 25
 a06:	70 e0       	ldi	r23, 0x00	; 0
 a08:	80 e0       	ldi	r24, 0x00	; 0
 a0a:	90 e0       	ldi	r25, 0x00	; 0
 a0c:	6b dc       	rcall	.-1834   	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:230
  	// check battery and button
  	uint16_t rawadc = readADC();
 a0e:	61 dd       	rcall	.-1342   	; 0x4d2 <readADC()>
isBatteryEmpty():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:95
		oled.fillLength(0,x1);
	}
}

bool isBatteryEmpty(uint16_t rawadc){
  return ((uint32_t)rawadc*128 >= V1S0 ? LOW : HIGH);
 a10:	b0 e0       	ldi	r27, 0x00	; 0
 a12:	a0 e0       	ldi	r26, 0x00	; 0
 a14:	27 e0       	ldi	r18, 0x07	; 7
 a16:	88 0f       	add	r24, r24
 a18:	99 1f       	adc	r25, r25
 a1a:	aa 1f       	adc	r26, r26
 a1c:	bb 1f       	adc	r27, r27
 a1e:	2a 95       	dec	r18
 a20:	d1 f7       	brne	.-12     	; 0xa16 <main+0x222>
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:232
    OCR1A = i;
  	delay(25);
  	// check battery and button
  	uint16_t rawadc = readADC();
	bool isBemp = isBatteryEmpty(rawadc);
    if(isBemp || getButtonState()==1){
 a22:	8f 37       	cpi	r24, 0x7F	; 127
 a24:	96 41       	sbci	r25, 0x16	; 22
 a26:	a1 40       	sbci	r26, 0x01	; 1
 a28:	b1 05       	cpc	r27, r1
 a2a:	80 f5       	brcc	.+96     	; 0xa8c <main+0x298>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:233
      stopMotor();
 a2c:	45 dd       	rcall	.-1398   	; 0x4b8 <stopMotor()>
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:291
      batEmpty = startMotor();
	}
  }
  // If battery empty - stop the motor and hang the firmware
  if(batEmpty){
    stopMotor();
 a2e:	44 dd       	rcall	.-1400   	; 0x4b8 <stopMotor()>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:292
    disableWatchdog();
 a30:	66 dd       	rcall	.-1332   	; 0x4fe <disableWatchdog()>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:295
#ifndef NOHANG
	while(1==1){
		bitClear(PORTB,3); // just to be 100% sure that motor will not start
 a32:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:296
		draw_Bat(0);
 a34:	80 e0       	ldi	r24, 0x00	; 0
 a36:	8c dd       	rcall	.-1256   	; 0x550 <draw_Bat(unsigned char)>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:297
		oled.bitmap(128-32,0,32,4,stateDANGER);
 a38:	4a e7       	ldi	r20, 0x7A	; 122
 a3a:	51 e0       	ldi	r21, 0x01	; 1
 a3c:	60 e2       	ldi	r22, 0x20	; 32
 a3e:	80 e6       	ldi	r24, 0x60	; 96
 a40:	c1 dc       	rcall	.-1662   	; 0x3c4 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:298
		oled.switchFrame();
 a42:	27 dd       	rcall	.-1458   	; 0x492 <SSD1306Device::switchFrame() [clone .constprop.6]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:299
		delay(300);
 a44:	6c e2       	ldi	r22, 0x2C	; 44
 a46:	71 e0       	ldi	r23, 0x01	; 1
 a48:	80 e0       	ldi	r24, 0x00	; 0
 a4a:	90 e0       	ldi	r25, 0x00	; 0
 a4c:	4b dc       	rcall	.-1898   	; 0x2e4 <delay>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:88
	oled.bitmap(13+50,0,7,4,batEnd);
}

void draw_clear(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y0 + y1; y++) {
 a4e:	c0 e0       	ldi	r28, 0x00	; 0
draw_clear():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:89
		oled.setCursor(x0,y);
 a50:	6c 2f       	mov	r22, r28
 a52:	80 e0       	ldi	r24, 0x00	; 0
 a54:	99 dc       	rcall	.-1742   	; 0x388 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.12]>
fillLength():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:279
void SSD1306Device::fillToEOL(uint8_t fill) {
	fillLength(fill, 128 - oledX);
}

void SSD1306Device::fillLength(uint8_t fill, uint8_t length) {
	oledX += length;
 a56:	80 91 97 00 	lds	r24, 0x0097	; 0x800097 <oledX>
 a5a:	8a 5b       	subi	r24, 0xBA	; 186
 a5c:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <oledX>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:280
	ssd1306_send_data_start();
 a60:	75 dc       	rcall	.-1814   	; 0x34c <ssd1306_send_data_start()>
 a62:	d6 e4       	ldi	r29, 0x46	; 70
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:283
	do
	{
		ssd1306_send_data_byte(fill);
 a64:	80 e0       	ldi	r24, 0x00	; 0
 a66:	7b dc       	rcall	.-1802   	; 0x35e <ssd1306_send_data_byte(unsigned char)>
 a68:	d1 50       	subi	r29, 0x01	; 1
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:285
	}
	while (--length);
 a6a:	e1 f7       	brne	.-8      	; 0xa64 <main+0x270>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:286
	ssd1306_send_stop();
 a6c:	65 dc       	rcall	.-1846   	; 0x338 <ssd1306_send_stop()>
draw_clear():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:88
	oled.bitmap(13+50,0,7,4,batEnd);
}

void draw_clear(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y0 + y1; y++) {
 a6e:	cf 5f       	subi	r28, 0xFF	; 255
 a70:	c4 30       	cpi	r28, 0x04	; 4
 a72:	71 f7       	brne	.-36     	; 0xa50 <main+0x25c>
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:301
		draw_Bat(0);
		oled.bitmap(128-32,0,32,4,stateDANGER);
		oled.switchFrame();
		delay(300);
		draw_clear(0,0,70,4);
		oled.bitmap(128-32,0,32,4,stateDANGER);
 a74:	4a e7       	ldi	r20, 0x7A	; 122
 a76:	51 e0       	ldi	r21, 0x01	; 1
 a78:	60 e2       	ldi	r22, 0x20	; 32
 a7a:	80 e6       	ldi	r24, 0x60	; 96
 a7c:	a3 dc       	rcall	.-1722   	; 0x3c4 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.11]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:302
		oled.switchFrame();
 a7e:	09 dd       	rcall	.-1518   	; 0x492 <SSD1306Device::switchFrame() [clone .constprop.6]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:303
		delay(600);
 a80:	68 e5       	ldi	r22, 0x58	; 88
 a82:	72 e0       	ldi	r23, 0x02	; 2
 a84:	80 e0       	ldi	r24, 0x00	; 0
 a86:	90 e0       	ldi	r25, 0x00	; 0
 a88:	2d dc       	rcall	.-1958   	; 0x2e4 <delay>
 a8a:	d3 cf       	rjmp	.-90     	; 0xa32 <main+0x23e>
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:232
    OCR1A = i;
  	delay(25);
  	// check battery and button
  	uint16_t rawadc = readADC();
	bool isBemp = isBatteryEmpty(rawadc);
    if(isBemp || getButtonState()==1){
 a8c:	41 dd       	rcall	.-1406   	; 0x510 <getButtonState()>
 a8e:	81 11       	cpse	r24, r1
 a90:	cd cf       	rjmp	.-102    	; 0xa2c <main+0x238>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:225
  //TCCR0B = (0<<WGM02) | (1<<CS02) | (0<<CS01) | (0<<CS00); // Speed (value 3)
  TIMSK |= (1<<OCIE1A) | (1<<OCIE1B) ;//(1<<TOIE1); // enable compare match and overflow interrupts
  sei();
  delay(30);
  //now motor starts at 50%. Increase the speed to 100%
  for(uint8_t i=100;i<190;i+=5){
 a92:	cb 5f       	subi	r28, 0xFB	; 251
 a94:	ce 3b       	cpi	r28, 0xBE	; 190
 a96:	09 f0       	breq	.+2      	; 0xa9a <main+0x2a6>
 a98:	b3 cf       	rjmp	.-154    	; 0xa00 <main+0x20c>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:238
      stopMotor();
	    return HIGH; // exit with low bat indication
  	} 
  }
  // at the end run motor at full speed
  cli();
 a9a:	f8 94       	cli
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:239
  TCCR1 = 0; // stop timer
 a9c:	10 be       	out	0x30, r1	; 48
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:240
  sei();
 a9e:	78 94       	sei
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:241
  bitSet(PORTB, 3);
 aa0:	c3 9a       	sbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:242
  delay(5);
 aa2:	65 e0       	ldi	r22, 0x05	; 5
 aa4:	70 e0       	ldi	r23, 0x00	; 0
 aa6:	80 e0       	ldi	r24, 0x00	; 0
 aa8:	90 e0       	ldi	r25, 0x00	; 0
 aaa:	1c dc       	rcall	.-1992   	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:243
  bitSet(PORTB, 3); // make sure motor is on. can be done with resetting interrupts flags.
 aac:	c3 9a       	sbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:244
  run_state=1;
 aae:	b0 92 90 00 	sts	0x0090, r11	; 0x800090 <run_state>
 ab2:	1c cf       	rjmp	.-456    	; 0x8ec <main+0xf8>

00000ab4 <_GLOBAL__sub_I_oled>:
_ZN5PrintC2Ev():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.1\cores\tiny/Print.h:75
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 ab4:	e2 e9       	ldi	r30, 0x92	; 146
 ab6:	f0 e0       	ldi	r31, 0x00	; 0
 ab8:	13 82       	std	Z+3, r1	; 0x03
 aba:	12 82       	std	Z+2, r1	; 0x02
__base_ctor ():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:142
	ssd1306_send_byte(command6);
	ssd1306_send_byte(command7);
	ssd1306_send_stop();
}

SSD1306Device::SSD1306Device(uint8_t ssd1306_i2c_address, void (*wireBeginFunc)(void), void (*wireBeginTransmissionFunc)(uint8_t ssd1306_i2c_address), bool (*wireWriteFunc)(uint8_t byte), void (*wireEndTransmissionFunc)(void)) {
 abc:	86 e6       	ldi	r24, 0x66	; 102
 abe:	90 e0       	ldi	r25, 0x00	; 0
 ac0:	91 83       	std	Z+1, r25	; 0x01
 ac2:	80 83       	st	Z, r24
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:143
	i2c_address = ssd1306_i2c_address;
 ac4:	8c e3       	ldi	r24, 0x3C	; 60
 ac6:	80 93 83 00 	sts	0x0083, r24	; 0x800083 <i2c_address>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:144
	wireBeginFn = wireBeginFunc;
 aca:	80 ee       	ldi	r24, 0xE0	; 224
 acc:	92 e0       	ldi	r25, 0x02	; 2
 ace:	90 93 8f 00 	sts	0x008F, r25	; 0x80008f <wireBeginFn+0x1>
 ad2:	80 93 8e 00 	sts	0x008E, r24	; 0x80008e <wireBeginFn>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:145
	wireBeginTransmissionFn = wireBeginTransmissionFunc;
 ad6:	8a ed       	ldi	r24, 0xDA	; 218
 ad8:	92 e0       	ldi	r25, 0x02	; 2
 ada:	90 93 82 00 	sts	0x0082, r25	; 0x800082 <wireBeginTransmissionFn+0x1>
 ade:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <wireBeginTransmissionFn>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:146
	wireWriteFn = wireWriteFunc;
 ae2:	8b ec       	ldi	r24, 0xCB	; 203
 ae4:	92 e0       	ldi	r25, 0x02	; 2
 ae6:	90 93 7e 00 	sts	0x007E, r25	; 0x80007e <wireWriteFn+0x1>
 aea:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <wireWriteFn>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:147
	wireEndTransmissionFn = wireEndTransmissionFunc;
 aee:	8b e1       	ldi	r24, 0x1B	; 27
 af0:	93 e0       	ldi	r25, 0x03	; 3
 af2:	90 93 80 00 	sts	0x0080, r25	; 0x800080 <wireEndTransmissionFn+0x1>
 af6:	80 93 7f 00 	sts	0x007F, r24	; 0x80007f <wireEndTransmissionFn>
_GLOBAL__sub_I_oled():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:308
		delay(600);
	}
#endif
  }

}
 afa:	08 95       	ret

00000afc <__mulqi3>:
__mulqi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:224
 afc:	00 24       	eor	r0, r0

00000afe <__mulqi3_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:226
 afe:	80 fd       	sbrc	r24, 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:227
 b00:	06 0e       	add	r0, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:228
 b02:	66 0f       	add	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:229
 b04:	11 f0       	breq	.+4      	; 0xb0a <__mulqi3_exit>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:230
 b06:	86 95       	lsr	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:231
 b08:	d1 f7       	brne	.-12     	; 0xafe <__mulqi3_loop>

00000b0a <__mulqi3_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:233
 b0a:	80 2d       	mov	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:234
 b0c:	08 95       	ret

00000b0e <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 b0e:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 b10:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 b12:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 b14:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 b16:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 b18:	09 94       	ijmp

00000b1a <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 b1a:	f8 94       	cli

00000b1c <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 b1c:	ff cf       	rjmp	.-2      	; 0xb1c <__stop_program>
