
C:\Users\Pavel\AppData\Local\Temp\arduino_build_349314/diychainsaw.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	fd c0       	rjmp	.+506    	; 0x1fc <__ctors_end>
   2:	21 c1       	rjmp	.+578    	; 0x246 <__bad_interrupt>
   4:	20 c1       	rjmp	.+576    	; 0x246 <__bad_interrupt>
   6:	b7 c4       	rjmp	.+2414   	; 0x976 <__vector_3>
   8:	1e c1       	rjmp	.+572    	; 0x246 <__bad_interrupt>
   a:	cd c3       	rjmp	.+1946   	; 0x7a6 <__vector_5>
   c:	1c c1       	rjmp	.+568    	; 0x246 <__bad_interrupt>
   e:	1b c1       	rjmp	.+566    	; 0x246 <__bad_interrupt>
  10:	1a c1       	rjmp	.+564    	; 0x246 <__bad_interrupt>
  12:	a6 c4       	rjmp	.+2380   	; 0x960 <__vector_9>
  14:	18 c1       	rjmp	.+560    	; 0x246 <__bad_interrupt>
  16:	17 c1       	rjmp	.+558    	; 0x246 <__bad_interrupt>
  18:	16 c1       	rjmp	.+556    	; 0x246 <__bad_interrupt>
  1a:	89 c4       	rjmp	.+2322   	; 0x92e <__vector_13>
  1c:	0e c4       	rjmp	.+2076   	; 0x83a <__vector_14>

0000001e <__trampolines_end>:
__trampolines_start():
  1e:	ff fe       	.word	0xfeff	; ????
  20:	00 00       	nop
  22:	00 00       	nop
  24:	00 ff       	sbrs	r16, 0
  26:	ff fe       	.word	0xfeff	; ????
  28:	fe fe       	.word	0xfefe	; ????
  2a:	fe fc       	.word	0xfcfe	; ????
  2c:	ff ff       	.word	0xffff	; ????
  2e:	7f 7f       	andi	r23, 0xFF	; 255
  30:	7f 7f       	andi	r23, 0xFF	; 255
  32:	3f ff       	.word	0xff3f	; ????
  34:	7f 00       	.word	0x007f	; ????
  36:	00 00       	nop
	...

0000003a <bat0>:
  3a:	03 03 03 03 03 03 03 03 03 03 00 00 00 00 00 00     ................
	...
  56:	00 00 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0                 ............

00000062 <bat1>:
  62:	fb fb fb fb fb fb fb fb fb 03 ff ff ff ff ff ff     ................
  72:	ff ff ff 00 ff ff ff ff ff ff ff ff ff 00 df df     ................
  82:	df df df df df df df c0                             ........

0000008a <batBot1>:
  8a:	fe ff 03 fb fb fb fb fb fb fb fb fb 03 ff ff 00     ................
  9a:	ff ff ff ff ff ff ff ff ff 00 ff ff 00 ff ff ff     ................
  aa:	ff ff ff ff ff ff 00 7f ff c0 df df df df df df     ................
  ba:	df df df c0                                         ....

000000be <batBot0>:
  be:	fe ff 03 03 03 03 03 03 03 03 03 03 03 ff ff 00     ................
	...
  d6:	00 00 ff ff 00 00 00 00 00 00 00 00 00 00 00 7f     ................
  e6:	ff c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0                 ............

000000f2 <ssd1306_init_sequence>:
  f2:	c8 a1 a8 1f da 02 8d 14                             ........

000000fa <stateOK>:
  fa:	fc fe 07 03 03 03 03 03 03 03 03 03 83 c3 e3 83     ................
 10a:	03 03 03 03 03 03 03 03 03 03 03 03 03 07 fe fc     ................
 11a:	ff ff 00 00 00 00 04 0e 1e 3e 3f 7f 77 e3 e3 c1     .........>?.w...
 12a:	80 00 00 00 00 00 00 00 00 00 00 00 00 00 ff ff     ................
 13a:	ff ff 00 00 00 00 00 00 00 00 00 00 00 00 01 01     ................
 14a:	03 07 0f 0e 1c 38 70 c0 80 00 00 00 00 00 ff ff     .....8p.........
 15a:	3f 7f e0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0 c0     ?...............
 16a:	c0 c0 c0 c0 c0 c0 c0 c0 c1 c5 c4 c0 c0 e0 7f 3f     ...............?

0000017a <stateDANGER>:
 17a:	00 00 80 c0 f0 f0 f8 fc fc 7e 3e 3f 1f 1f 1f 1f     .........~>?....
 18a:	1f 1f 1f 1f 3f be fe fc fc f8 f0 f0 c0 80 00 00     ....?...........
 19a:	f8 fe ff ff ff 0f 03 01 00 00 00 00 00 80 c0 e0     ................
 1aa:	f0 f8 fc fe 7f 3f 1f 0f 07 03 0f ff ff ff fe f8     .....?..........
 1ba:	1f 7f ff ff ff f0 c0 e0 f0 f8 fc fe 7f 3f 1f 0f     .............?..
 1ca:	07 03 01 00 00 00 00 00 80 c0 f0 ff ff ff 7f 1f     ................
 1da:	00 00 01 03 0f 0f 1f 3f 3f 7f 7d fc f8 f8 f8 f8     .......??.}.....
 1ea:	f8 f8 f8 f8 fc 7c 7e 3f 3f 1f 0f 0f 03 01 00 00     .....|~??.......

000001fa <__ctors_start>:
__ctors_start():
 1fa:	2c 06       	cpc	r2, r28

000001fc <__ctors_end>:
__dtors_end():
 1fc:	11 24       	eor	r1, r1
 1fe:	1f be       	out	0x3f, r1	; 63
 200:	cf e5       	ldi	r28, 0x5F	; 95
 202:	d2 e0       	ldi	r29, 0x02	; 2
 204:	de bf       	out	0x3e, r29	; 62
 206:	cd bf       	out	0x3d, r28	; 61

00000208 <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
 208:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
 20a:	aa e6       	ldi	r26, 0x6A	; 106
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
 20c:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
 20e:	01 c0       	rjmp	.+2      	; 0x212 <.do_clear_bss_start>

00000210 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
 210:	1d 92       	st	X+, r1

00000212 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
 212:	ac 3a       	cpi	r26, 0xAC	; 172
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
 214:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
 216:	e1 f7       	brne	.-8      	; 0x210 <.do_clear_bss_loop>

00000218 <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
 218:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
 21a:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
 21c:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
 21e:	ec eb       	ldi	r30, 0xBC	; 188
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
 220:	fc e0       	ldi	r31, 0x0C	; 12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
 222:	02 c0       	rjmp	.+4      	; 0x228 <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
 224:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
 226:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
 228:	aa 36       	cpi	r26, 0x6A	; 106
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
 22a:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
 22c:	d9 f7       	brne	.-10     	; 0x224 <__do_copy_data+0xc>

0000022e <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
 22e:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
 230:	ce ef       	ldi	r28, 0xFE	; 254
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
 232:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
 234:	03 c0       	rjmp	.+6      	; 0x23c <__do_global_ctors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
 236:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
 238:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
 23a:	38 d5       	rcall	.+2672   	; 0xcac <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
 23c:	cd 3f       	cpi	r28, 0xFD	; 253
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
 23e:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
 240:	d1 f7       	brne	.-12     	; 0x236 <__do_global_ctors+0x8>
 242:	a4 d3       	rcall	.+1864   	; 0x98c <main>
 244:	39 c5       	rjmp	.+2674   	; 0xcb8 <_exit>

00000246 <__bad_interrupt>:
__vector_1():
 246:	dc ce       	rjmp	.-584    	; 0x0 <__vectors>

00000248 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/Print.cpp:34

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 248:	cf 92       	push	r12
 24a:	df 92       	push	r13
 24c:	ef 92       	push	r14
 24e:	ff 92       	push	r15
 250:	0f 93       	push	r16
 252:	1f 93       	push	r17
 254:	cf 93       	push	r28
 256:	df 93       	push	r29
 258:	6c 01       	movw	r12, r24
 25a:	eb 01       	movw	r28, r22
 25c:	7b 01       	movw	r14, r22
 25e:	e4 0e       	add	r14, r20
 260:	f5 1e       	adc	r15, r21
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/Print.cpp:35
  size_t n = 0;
 262:	10 e0       	ldi	r17, 0x00	; 0
 264:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/Print.cpp:36
  while (size--) {
 266:	ce 15       	cp	r28, r14
 268:	df 05       	cpc	r29, r15
 26a:	61 f0       	breq	.+24     	; 0x284 <__stack+0x25>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/Print.cpp:37
    n += write(*buffer++);
 26c:	69 91       	ld	r22, Y+
 26e:	d6 01       	movw	r26, r12
 270:	ed 91       	ld	r30, X+
 272:	fc 91       	ld	r31, X
 274:	01 90       	ld	r0, Z+
 276:	f0 81       	ld	r31, Z
 278:	e0 2d       	mov	r30, r0
 27a:	c6 01       	movw	r24, r12
 27c:	09 95       	icall
 27e:	08 0f       	add	r16, r24
 280:	19 1f       	adc	r17, r25
 282:	f1 cf       	rjmp	.-30     	; 0x266 <__stack+0x7>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/Print.cpp:40
  }
  return n;
}
 284:	c8 01       	movw	r24, r16
 286:	df 91       	pop	r29
 288:	cf 91       	pop	r28
 28a:	1f 91       	pop	r17
 28c:	0f 91       	pop	r16
 28e:	ff 90       	pop	r15
 290:	ef 90       	pop	r14
 292:	df 90       	pop	r13
 294:	cf 90       	pop	r12
 296:	08 95       	ret

00000298 <micros>:
micros():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:190
}

unsigned long micros()
{
  unsigned long m;
  uint8_t oldSREG = SREG, t;
 298:	3f b7       	in	r19, 0x3f	; 63
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:192

  cli();
 29a:	f8 94       	cli
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:193
  m = millis_timer_overflow_count;
 29c:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <millis_timer_overflow_count>
 2a0:	90 91 9f 00 	lds	r25, 0x009F	; 0x80009f <millis_timer_overflow_count+0x1>
 2a4:	a0 91 a0 00 	lds	r26, 0x00A0	; 0x8000a0 <millis_timer_overflow_count+0x2>
 2a8:	b0 91 a1 00 	lds	r27, 0x00A1	; 0x8000a1 <millis_timer_overflow_count+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:195
#if defined(TCNT0) && (TIMER_TO_USE_FOR_MILLIS == 0) && !defined(TCW0)
  t = TCNT0;
 2ac:	22 b7       	in	r18, 0x32	; 50
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:210

#if defined(TIFR0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR0 & _BV(TOV0)) && (t < 255))
    m++;
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 0)
  if ((TIFR & _BV(TOV0)) && (t < 255))
 2ae:	08 b6       	in	r0, 0x38	; 56
 2b0:	01 fe       	sbrs	r0, 1
 2b2:	05 c0       	rjmp	.+10     	; 0x2be <micros+0x26>
 2b4:	2f 3f       	cpi	r18, 0xFF	; 255
 2b6:	19 f0       	breq	.+6      	; 0x2be <micros+0x26>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:211
    m++;
 2b8:	01 96       	adiw	r24, 0x01	; 1
 2ba:	a1 1d       	adc	r26, r1
 2bc:	b1 1d       	adc	r27, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:220
#elif defined(TIFR) && (TIMER_TO_USE_FOR_MILLIS == 1)
  if ((TIFR & _BV(TOV1)) && (t < 255))
    m++;
#endif

  SREG = oldSREG;
 2be:	3f bf       	out	0x3f, r19	; 63
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:227

#if F_CPU < 1000000L
  return ((m << 8) + t) * MillisTimer_Prescale_Value * (1000000L/F_CPU);
#else
#if (MillisTimer_Prescale_Value % clockCyclesPerMicrosecond() == 0 ) // Can we just do it the naive way? If so great!
  return ((m << 8) + t) * (MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
 2c0:	ba 2f       	mov	r27, r26
 2c2:	a9 2f       	mov	r26, r25
 2c4:	98 2f       	mov	r25, r24
 2c6:	88 27       	eor	r24, r24
 2c8:	bc 01       	movw	r22, r24
 2ca:	cd 01       	movw	r24, r26
 2cc:	62 0f       	add	r22, r18
 2ce:	71 1d       	adc	r23, r1
 2d0:	81 1d       	adc	r24, r1
 2d2:	91 1d       	adc	r25, r1
 2d4:	43 e0       	ldi	r20, 0x03	; 3
 2d6:	66 0f       	add	r22, r22
 2d8:	77 1f       	adc	r23, r23
 2da:	88 1f       	adc	r24, r24
 2dc:	99 1f       	adc	r25, r25
 2de:	4a 95       	dec	r20
 2e0:	d1 f7       	brne	.-12     	; 0x2d6 <micros+0x3e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:270
  //the high part gets divided by cCPuS then multiplied by the prescaler. Then take the low 8 bits plus the high part modulo-cCPuS to correct for the division, then multiply that by the prescaler value first before dividing by cCPuS, and finally add the two together.
  //return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + ((t+(((m<<8)%clockCyclesPerMicrosecond())) * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond()));
  return ((m << 8 )/clockCyclesPerMicrosecond()* MillisTimer_Prescale_Value) + (t * MillisTimer_Prescale_Value / clockCyclesPerMicrosecond());
#endif
#endif
}
 2e2:	08 95       	ret

000002e4 <delay>:
delay():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:280
  // Empty
}
void yield(void) __attribute__ ((weak, alias("__empty")));

void delay(unsigned long ms)
{
 2e4:	cf 92       	push	r12
 2e6:	df 92       	push	r13
 2e8:	ef 92       	push	r14
 2ea:	ff 92       	push	r15
 2ec:	cf 93       	push	r28
 2ee:	df 93       	push	r29
 2f0:	6b 01       	movw	r12, r22
 2f2:	7c 01       	movw	r14, r24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:282
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();
 2f4:	d1 df       	rcall	.-94     	; 0x298 <micros>
 2f6:	eb 01       	movw	r28, r22
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:286

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
 2f8:	cf df       	rcall	.-98     	; 0x298 <micros>
 2fa:	6c 1b       	sub	r22, r28
 2fc:	7d 0b       	sbc	r23, r29
 2fe:	68 3e       	cpi	r22, 0xE8	; 232
 300:	73 40       	sbci	r23, 0x03	; 3
 302:	a0 f0       	brcs	.+40     	; 0x32c <delay+0x48>
 304:	c1 14       	cp	r12, r1
 306:	d1 04       	cpc	r13, r1
 308:	e1 04       	cpc	r14, r1
 30a:	f1 04       	cpc	r15, r1
 30c:	39 f4       	brne	.+14     	; 0x31c <delay+0x38>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:296
  #else
  uint32_t start = millis();
  while((millis() - start) < ms)  /* NOP */yield();
  return;
  #endif
}
 30e:	df 91       	pop	r29
 310:	cf 91       	pop	r28
 312:	ff 90       	pop	r15
 314:	ef 90       	pop	r14
 316:	df 90       	pop	r13
 318:	cf 90       	pop	r12
 31a:	08 95       	ret
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:287
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
    yield();
    while (((uint16_t)micros() - start) >= 1000 && ms) {
      ms--;
 31c:	81 e0       	ldi	r24, 0x01	; 1
 31e:	c8 1a       	sub	r12, r24
 320:	d1 08       	sbc	r13, r1
 322:	e1 08       	sbc	r14, r1
 324:	f1 08       	sbc	r15, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:288
      start += 1000;
 326:	c8 51       	subi	r28, 0x18	; 24
 328:	dc 4f       	sbci	r29, 0xFC	; 252
 32a:	e6 cf       	rjmp	.-52     	; 0x2f8 <delay+0x14>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:284
void delay(unsigned long ms)
{
  #if (F_CPU>=1000000L)
  uint16_t start = (uint16_t)micros();

  while (ms > 0) {
 32c:	c1 14       	cp	r12, r1
 32e:	d1 04       	cpc	r13, r1
 330:	e1 04       	cpc	r14, r1
 332:	f1 04       	cpc	r15, r1
 334:	09 f7       	brne	.-62     	; 0x2f8 <delay+0x14>
 336:	eb cf       	rjmp	.-42     	; 0x30e <delay+0x2a>

00000338 <ssd1306_send_stop()>:
ssd1306_send_stop():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:70
static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
}

static void ssd1306_send_stop(void) {
	wireEndTransmissionFn();
 338:	e0 91 90 00 	lds	r30, 0x0090	; 0x800090 <wireEndTransmissionFn>
 33c:	f0 91 91 00 	lds	r31, 0x0091	; 0x800091 <wireEndTransmissionFn+0x1>
 340:	09 94       	ijmp

00000342 <ssd1306_send_byte(unsigned char)>:
ssd1306_send_byte():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:66
static void ssd1306_send_start(void) {
	wireBeginTransmissionFn();
}

static bool ssd1306_send_byte(uint8_t byte) {
	return wireWriteFn(byte);
 342:	e0 91 8e 00 	lds	r30, 0x008E	; 0x80008e <wireWriteFn>
 346:	f0 91 8f 00 	lds	r31, 0x008F	; 0x80008f <wireWriteFn+0x1>
 34a:	09 94       	ijmp

0000034c <ssd1306_send_data_start()>:
ssd1306_send_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:62
static void ssd1306_begin(void) {
	wireBeginFn();
}

static void ssd1306_send_start(void) {
	wireBeginTransmissionFn();
 34c:	e0 91 92 00 	lds	r30, 0x0092	; 0x800092 <wireBeginTransmissionFn>
 350:	f0 91 93 00 	lds	r31, 0x0093	; 0x800093 <wireBeginTransmissionFn+0x1>
 354:	09 95       	icall
ssd1306_send_data_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:80
	ssd1306_send_byte(SSD1306_COMMAND);
}

static void ssd1306_send_data_start(void) {
	ssd1306_send_start();
	ssd1306_send_byte(SSD1306_DATA);
 356:	80 e4       	ldi	r24, 0x40	; 64
 358:	f4 cf       	rjmp	.-24     	; 0x342 <ssd1306_send_byte(unsigned char)>

0000035a <ssd1306_send_data_byte(unsigned char)>:
ssd1306_send_data_byte():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:91
		ssd1306_send_command_start();
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_data_byte(uint8_t byte) {
 35a:	cf 93       	push	r28
 35c:	c8 2f       	mov	r28, r24
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:92
	if (ssd1306_send_byte(byte) == 0) {
 35e:	f1 df       	rcall	.-30     	; 0x342 <ssd1306_send_byte(unsigned char)>
 360:	81 11       	cpse	r24, r1
 362:	05 c0       	rjmp	.+10     	; 0x36e <ssd1306_send_data_byte(unsigned char)+0x14>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:93
		ssd1306_send_stop();
 364:	e9 df       	rcall	.-46     	; 0x338 <ssd1306_send_stop()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:94
		ssd1306_send_data_start();
 366:	f2 df       	rcall	.-28     	; 0x34c <ssd1306_send_data_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:95
		ssd1306_send_byte(byte);
 368:	8c 2f       	mov	r24, r28
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:97
	}
}
 36a:	cf 91       	pop	r28
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:95

static void ssd1306_send_data_byte(uint8_t byte) {
	if (ssd1306_send_byte(byte) == 0) {
		ssd1306_send_stop();
		ssd1306_send_data_start();
		ssd1306_send_byte(byte);
 36c:	ea cf       	rjmp	.-44     	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:97
	}
}
 36e:	cf 91       	pop	r28
 370:	08 95       	ret

00000372 <ssd1306_send_command_start()>:
ssd1306_send_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:62
static void ssd1306_begin(void) {
	wireBeginFn();
}

static void ssd1306_send_start(void) {
	wireBeginTransmissionFn();
 372:	e0 91 92 00 	lds	r30, 0x0092	; 0x800092 <wireBeginTransmissionFn>
 376:	f0 91 93 00 	lds	r31, 0x0093	; 0x800093 <wireBeginTransmissionFn+0x1>
 37a:	09 95       	icall
ssd1306_send_command_start():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:75
	wireEndTransmissionFn();
}

static void ssd1306_send_command_start(void) {
	ssd1306_send_start();
	ssd1306_send_byte(SSD1306_COMMAND);
 37c:	80 e0       	ldi	r24, 0x00	; 0
 37e:	e1 cf       	rjmp	.-62     	; 0x342 <ssd1306_send_byte(unsigned char)>

00000380 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.14]>:
setCursor():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:177

void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
 380:	1f 93       	push	r17
 382:	cf 93       	push	r28
 384:	df 93       	push	r29
 386:	c8 2f       	mov	r28, r24
 388:	16 2f       	mov	r17, r22
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:178
	ssd1306_send_command3(renderingFrame | (y & 0x07), 0x10 | ((x & 0xf0) >> 4), x & 0x0f);
 38a:	d6 2f       	mov	r29, r22
 38c:	d7 70       	andi	r29, 0x07	; 7
 38e:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <renderingFrame>
 392:	d8 2b       	or	r29, r24
ssd1306_send_command3():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:113
	ssd1306_send_byte(command2);
	ssd1306_send_stop();
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
 394:	ee df       	rcall	.-36     	; 0x372 <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:114
	ssd1306_send_byte(command1);
 396:	8d 2f       	mov	r24, r29
 398:	d4 df       	rcall	.-88     	; 0x342 <ssd1306_send_byte(unsigned char)>
setCursor():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:178
void SSD1306Device::setFont(const DCfont *font) {
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | (y & 0x07), 0x10 | ((x & 0xf0) >> 4), x & 0x0f);
 39a:	8c 2f       	mov	r24, r28
 39c:	82 95       	swap	r24
 39e:	8f 70       	andi	r24, 0x0F	; 15
ssd1306_send_command3():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:115
}

static void ssd1306_send_command3(uint8_t command1, uint8_t command2, uint8_t command3) {
	ssd1306_send_command_start();
	ssd1306_send_byte(command1);
	ssd1306_send_byte(command2);
 3a0:	80 61       	ori	r24, 0x10	; 16
 3a2:	cf df       	rcall	.-98     	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:116
	ssd1306_send_byte(command3);
 3a4:	8c 2f       	mov	r24, r28
 3a6:	8f 70       	andi	r24, 0x0F	; 15
 3a8:	cc df       	rcall	.-104    	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:117
	ssd1306_send_stop();
 3aa:	c6 df       	rcall	.-116    	; 0x338 <ssd1306_send_stop()>
setCursor():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:179
	oledFont = font;
}

void SSD1306Device::setCursor(uint8_t x, uint8_t y) {
	ssd1306_send_command3(renderingFrame | (y & 0x07), 0x10 | ((x & 0xf0) >> 4), x & 0x0f);
	oledX = x;
 3ac:	c0 93 ab 00 	sts	0x00AB, r28	; 0x8000ab <oledX>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:180
	oledY = y;
 3b0:	10 93 aa 00 	sts	0x00AA, r17	; 0x8000aa <oledY>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:181
}
 3b4:	df 91       	pop	r29
 3b6:	cf 91       	pop	r28
 3b8:	1f 91       	pop	r17
 3ba:	08 95       	ret

000003bc <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]>:
bitmap():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:252
	}
	while (--line);
	return 1;
}

void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
 3bc:	8f 92       	push	r8
 3be:	9f 92       	push	r9
 3c0:	af 92       	push	r10
 3c2:	bf 92       	push	r11
 3c4:	cf 92       	push	r12
 3c6:	df 92       	push	r13
 3c8:	ef 92       	push	r14
 3ca:	ff 92       	push	r15
 3cc:	0f 93       	push	r16
 3ce:	1f 93       	push	r17
 3d0:	cf 93       	push	r28
 3d2:	df 93       	push	r29
 3d4:	d8 2f       	mov	r29, r24
 3d6:	d6 2e       	mov	r13, r22
 3d8:	4a 01       	movw	r8, r20
 3da:	10 e0       	ldi	r17, 0x00	; 0
 3dc:	00 e0       	ldi	r16, 0x00	; 0
 3de:	68 17       	cp	r22, r24
 3e0:	18 f0       	brcs	.+6      	; 0x3e8 <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]+0x2c>
 3e2:	06 2f       	mov	r16, r22
 3e4:	08 1b       	sub	r16, r24
 3e6:	10 e0       	ldi	r17, 0x00	; 0
 3e8:	f1 2c       	mov	r15, r1
 3ea:	e1 2c       	mov	r14, r1
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:254
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y1; y++) {
 3ec:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:255
		setCursor(x0,y);
 3ee:	6c 2f       	mov	r22, r28
 3f0:	8d 2f       	mov	r24, r29
 3f2:	c6 df       	rcall	.-116    	; 0x380 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.14]>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:256
		ssd1306_send_data_start();
 3f4:	ab df       	rcall	.-170    	; 0x34c <ssd1306_send_data_start()>
 3f6:	57 01       	movw	r10, r14
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:257
		for (uint8_t x = x0; x < x1; x++) {
 3f8:	cd 2e       	mov	r12, r29
 3fa:	cd 14       	cp	r12, r13
 3fc:	50 f4       	brcc	.+20     	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:258
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
 3fe:	f4 01       	movw	r30, r8
 400:	ea 0d       	add	r30, r10
 402:	fb 1d       	adc	r31, r11
 404:	84 91       	lpm	r24, Z
 406:	a9 df       	rcall	.-174    	; 0x35a <ssd1306_send_data_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:257
void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y1; y++) {
		setCursor(x0,y);
		ssd1306_send_data_start();
		for (uint8_t x = x0; x < x1; x++) {
 408:	c3 94       	inc	r12
 40a:	8f ef       	ldi	r24, 0xFF	; 255
 40c:	a8 1a       	sub	r10, r24
 40e:	b8 0a       	sbc	r11, r24
 410:	f4 cf       	rjmp	.-24     	; 0x3fa <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]+0x3e>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:260
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
		}
		ssd1306_send_stop();
 412:	92 df       	rcall	.-220    	; 0x338 <ssd1306_send_stop()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:254
	return 1;
}

void SSD1306Device::bitmap(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, const uint8_t bitmap[]) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y1; y++) {
 414:	cf 5f       	subi	r28, 0xFF	; 255
 416:	e0 0e       	add	r14, r16
 418:	f1 1e       	adc	r15, r17
 41a:	c4 30       	cpi	r28, 0x04	; 4
 41c:	41 f7       	brne	.-48     	; 0x3ee <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]+0x32>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:262
		for (uint8_t x = x0; x < x1; x++) {
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
		}
		ssd1306_send_stop();
	}
	setCursor(0, 0);
 41e:	60 e0       	ldi	r22, 0x00	; 0
 420:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:263
}
 422:	df 91       	pop	r29
 424:	cf 91       	pop	r28
 426:	1f 91       	pop	r17
 428:	0f 91       	pop	r16
 42a:	ff 90       	pop	r15
 42c:	ef 90       	pop	r14
 42e:	df 90       	pop	r13
 430:	cf 90       	pop	r12
 432:	bf 90       	pop	r11
 434:	af 90       	pop	r10
 436:	9f 90       	pop	r9
 438:	8f 90       	pop	r8
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:262
		for (uint8_t x = x0; x < x1; x++) {
			ssd1306_send_data_byte(pgm_read_byte(&bitmap[j++]));
		}
		ssd1306_send_stop();
	}
	setCursor(0, 0);
 43a:	a2 cf       	rjmp	.-188    	; 0x380 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.14]>

0000043c <SSD1306Device::fill(unsigned char) [clone .constprop.4]>:
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:187

void SSD1306Device::clear(void) {
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
 43c:	0f 93       	push	r16
 43e:	1f 93       	push	r17
 440:	cf 93       	push	r28
 442:	df 93       	push	r29
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:188
	for (uint8_t m = 0; m < oledPages; m++) {
 444:	c0 e0       	ldi	r28, 0x00	; 0
fillToEOL():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:270
void SSD1306Device::clearToEOL(void) {
	fillToEOL(0x00);
}

void SSD1306Device::fillToEOL(uint8_t fill) {
	fillLength(fill, 128 - oledX);
 446:	10 e8       	ldi	r17, 0x80	; 128
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:189
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < oledPages; m++) {
		setCursor(0, m);
 448:	6c 2f       	mov	r22, r28
 44a:	80 e0       	ldi	r24, 0x00	; 0
 44c:	99 df       	rcall	.-206    	; 0x380 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.14]>
fillToEOL():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:270
void SSD1306Device::clearToEOL(void) {
	fillToEOL(0x00);
}

void SSD1306Device::fillToEOL(uint8_t fill) {
	fillLength(fill, 128 - oledX);
 44e:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <oledX>
 452:	01 2f       	mov	r16, r17
 454:	08 1b       	sub	r16, r24
fillLength():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:274
}

void SSD1306Device::fillLength(uint8_t fill, uint8_t length) {
	if (length == 0) return;
 456:	51 f0       	breq	.+20     	; 0x46c <SSD1306Device::fill(unsigned char) [clone .constprop.4]+0x30>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:275
	oledX += length;
 458:	10 93 ab 00 	sts	0x00AB, r17	; 0x8000ab <oledX>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:276
	ssd1306_send_data_start();
 45c:	77 df       	rcall	.-274    	; 0x34c <ssd1306_send_data_start()>
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:290
void SSD1306Device::sendData(const uint8_t data) {
	ssd1306_send_data_byte(data);
}

void SSD1306Device::repeatData(uint8_t data, uint8_t length) {
	for (uint8_t x = 0; x < length; x++) {
 45e:	d0 e0       	ldi	r29, 0x00	; 0
repeatData():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:291
		ssd1306_send_data_byte(data);
 460:	80 e0       	ldi	r24, 0x00	; 0
 462:	7b df       	rcall	.-266    	; 0x35a <ssd1306_send_data_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:290
void SSD1306Device::sendData(const uint8_t data) {
	ssd1306_send_data_byte(data);
}

void SSD1306Device::repeatData(uint8_t data, uint8_t length) {
	for (uint8_t x = 0; x < length; x++) {
 464:	df 5f       	subi	r29, 0xFF	; 255
 466:	0d 13       	cpse	r16, r29
 468:	fb cf       	rjmp	.-10     	; 0x460 <SSD1306Device::fill(unsigned char) [clone .constprop.4]+0x24>
fillLength():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:278
void SSD1306Device::fillLength(uint8_t fill, uint8_t length) {
	if (length == 0) return;
	oledX += length;
	ssd1306_send_data_start();
	repeatData(fill, length);
	ssd1306_send_stop();
 46a:	66 df       	rcall	.-308    	; 0x338 <ssd1306_send_stop()>
fill():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:188
void SSD1306Device::clear(void) {
	fill(0x00);
}

void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < oledPages; m++) {
 46c:	cf 5f       	subi	r28, 0xFF	; 255
 46e:	c4 30       	cpi	r28, 0x04	; 4
 470:	59 f7       	brne	.-42     	; 0x448 <SSD1306Device::fill(unsigned char) [clone .constprop.4]+0xc>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:192
		setCursor(0, m);
		fillToEOL(fill);
	}
	setCursor(0, 0);
 472:	60 e0       	ldi	r22, 0x00	; 0
 474:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:193
}
 476:	df 91       	pop	r29
 478:	cf 91       	pop	r28
 47a:	1f 91       	pop	r17
 47c:	0f 91       	pop	r16
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:192
void SSD1306Device::fill(uint8_t fill) {
	for (uint8_t m = 0; m < oledPages; m++) {
		setCursor(0, m);
		fillToEOL(fill);
	}
	setCursor(0, 0);
 47e:	80 cf       	rjmp	.-256    	; 0x380 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.14]>

00000480 <SSD1306Device::newLine(unsigned char)>:
newLine():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:196
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
 480:	80 91 aa 00 	lds	r24, 0x00AA	; 0x8000aa <oledY>
 484:	86 0f       	add	r24, r22
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:197
	if (oledY > oledPages - fontHeight) {
 486:	24 e0       	ldi	r18, 0x04	; 4
 488:	30 e0       	ldi	r19, 0x00	; 0
 48a:	26 1b       	sub	r18, r22
 48c:	31 09       	sbc	r19, r1
 48e:	82 17       	cp	r24, r18
 490:	13 06       	cpc	r1, r19
 492:	09 f0       	breq	.+2      	; 0x496 <SSD1306Device::newLine(unsigned char)+0x16>
 494:	34 f4       	brge	.+12     	; 0x4a2 <SSD1306Device::newLine(unsigned char)+0x22>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:198
		oledY = oledPages - fontHeight;
 496:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <oledY>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:200
	}
	setCursor(0, oledY);
 49a:	60 91 aa 00 	lds	r22, 0x00AA	; 0x8000aa <oledY>
 49e:	80 e0       	ldi	r24, 0x00	; 0
 4a0:	6f cf       	rjmp	.-290    	; 0x380 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.14]>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:198
}

void SSD1306Device::newLine(uint8_t fontHeight) {
	oledY+=fontHeight;
	if (oledY > oledPages - fontHeight) {
		oledY = oledPages - fontHeight;
 4a2:	84 e0       	ldi	r24, 0x04	; 4
 4a4:	86 1b       	sub	r24, r22
 4a6:	f7 cf       	rjmp	.-18     	; 0x496 <SSD1306Device::newLine(unsigned char)+0x16>

000004a8 <SSD1306Device::write(unsigned char)>:
write():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:250
			}
		}
	}
	while (--line);
	return 1;
}
 4a8:	81 e0       	ldi	r24, 0x01	; 1
 4aa:	90 e0       	ldi	r25, 0x00	; 0
 4ac:	08 95       	ret

000004ae <SSD1306Device::switchFrame() [clone .constprop.6]>:
switchFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:314
void SSD1306Device::switchDisplayFrame(void) {
	drawingFrame ^= 0x20;
	ssd1306_send_command(drawingFrame);
}

void SSD1306Device::switchFrame(void) {
 4ae:	cf 93       	push	r28
switchDisplayFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:310
void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
}

void SSD1306Device::switchDisplayFrame(void) {
	drawingFrame ^= 0x20;
 4b0:	c0 91 60 00 	lds	r28, 0x0060	; 0x800060 <__data_start>
 4b4:	80 e2       	ldi	r24, 0x20	; 32
 4b6:	c8 27       	eor	r28, r24
 4b8:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__data_start>
ssd1306_send_command():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:100
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_command(uint8_t command) {
	ssd1306_send_command_start();
 4bc:	5a df       	rcall	.-332    	; 0x372 <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:101
	ssd1306_send_byte(command);
 4be:	8c 2f       	mov	r24, r28
 4c0:	40 df       	rcall	.-384    	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:102
	ssd1306_send_stop();
 4c2:	3a df       	rcall	.-396    	; 0x338 <ssd1306_send_stop()>
switchRenderFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:306
}

// Double Buffering Commands

void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
 4c4:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <renderingFrame>
 4c8:	94 e0       	ldi	r25, 0x04	; 4
 4ca:	89 27       	eor	r24, r25
 4cc:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <renderingFrame>
switchFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:317
}

void SSD1306Device::switchFrame(void) {
	switchDisplayFrame();
	switchRenderFrame();
}
 4d0:	cf 91       	pop	r28
 4d2:	08 95       	ret

000004d4 <stopMotor()>:
stopMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:254
  return LOW;
}

void stopMotor(){
    // make sure that motor is off
    run_state=0;
 4d4:	10 92 a4 00 	sts	0x00A4, r1	; 0x8000a4 <run_state>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:256
    // stop timer
	cli();
 4d8:	f8 94       	cli
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:257
    TCCR1 = 0;
 4da:	10 be       	out	0x30, r1	; 48
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:258
	sei();
 4dc:	78 94       	sei
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:259
    bitClear(PORTB,3);
 4de:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:260
	delay(5);
 4e0:	65 e0       	ldi	r22, 0x05	; 5
 4e2:	70 e0       	ldi	r23, 0x00	; 0
 4e4:	80 e0       	ldi	r24, 0x00	; 0
 4e6:	90 e0       	ldi	r25, 0x00	; 0
 4e8:	fd de       	rcall	.-518    	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:261
    bitClear(PORTB,3);  
 4ea:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:262
}
 4ec:	08 95       	ret

000004ee <readADC()>:
readADC():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:202
  bitSet(PORTB, 3);
  //tmrval = TCNT1;
}

uint16_t readADC(void){
	while (bit_is_set(ADCSRA,ADSC)); // wait for any previous conversion
 4ee:	36 99       	sbic	0x06, 6	; 6
 4f0:	fe cf       	rjmp	.-4      	; 0x4ee <readADC()>
 4f2:	20 e2       	ldi	r18, 0x20	; 32
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:203
	uint16_t res32=0;
 4f4:	90 e0       	ldi	r25, 0x00	; 0
 4f6:	80 e0       	ldi	r24, 0x00	; 0
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:205
	for(uint8_t i=0;i<32;i++){
	  ADCSRA |= (1 << ADSC); // start new conversion
 4f8:	36 9a       	sbi	0x06, 6	; 6
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:206
	  while (bit_is_set(ADCSRA,ADSC)); // wait for current conversion to complete
 4fa:	36 99       	sbic	0x06, 6	; 6
 4fc:	fe cf       	rjmp	.-4      	; 0x4fa <readADC()+0xc>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:207
	  uint8_t low  = ADCL; // must read ADCL first
 4fe:	34 b1       	in	r19, 0x04	; 4
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:208
	  uint8_t high = ADCH;
 500:	45 b1       	in	r20, 0x05	; 5
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:209
    res32+=(uint16_t)((high<<8) | low);
 502:	54 2f       	mov	r21, r20
 504:	43 2f       	mov	r20, r19
 506:	84 0f       	add	r24, r20
 508:	95 1f       	adc	r25, r21
 50a:	21 50       	subi	r18, 0x01	; 1
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:204
}

uint16_t readADC(void){
	while (bit_is_set(ADCSRA,ADSC)); // wait for any previous conversion
	uint16_t res32=0;
	for(uint8_t i=0;i<32;i++){
 50c:	a9 f7       	brne	.-22     	; 0x4f8 <readADC()+0xa>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:212
	  uint8_t low  = ADCL; // must read ADCL first
	  uint8_t high = ADCH;
    res32+=(uint16_t)((high<<8) | low);
	}
	  return res32 /32;
}
 50e:	25 e0       	ldi	r18, 0x05	; 5
 510:	96 95       	lsr	r25
 512:	87 95       	ror	r24
 514:	2a 95       	dec	r18
 516:	e1 f7       	brne	.-8      	; 0x510 <readADC()+0x22>
 518:	08 95       	ret

0000051a <disableWatchdog()>:
wdt_disable():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\avr/wdt.h:510
				"out __SREG__,__tmp_reg__"   "\n\t"
				: [TEMPREG] "=d" (temp_reg)
				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
				: "r0"
		);
 51a:	0f b6       	in	r0, 0x3f	; 63
 51c:	f8 94       	cli
 51e:	a8 95       	wdr
 520:	81 b5       	in	r24, 0x21	; 33
 522:	88 61       	ori	r24, 0x18	; 24
 524:	81 bd       	out	0x21, r24	; 33
 526:	11 bc       	out	0x21, r1	; 33
 528:	0f be       	out	0x3f, r0	; 63
disableWatchdog():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:126
  if(tmp == bitRead(PINB, 1)){return tmp;}else{return !tmp;}
}

void disableWatchdog(){
  wdt_disable();
}
 52a:	08 95       	ret

0000052c <getButtonState()>:
getButtonState():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:118
  if(adc128>=V1S1) return 1;
  if(adc128<V1S0) return 0;
  return 0;
}

bool getButtonState(){
 52c:	0f 93       	push	r16
 52e:	1f 93       	push	r17
 530:	cf 93       	push	r28
 532:	df 93       	push	r29
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:119
  bool tmp = bitRead(PINB, 1);
 534:	86 b3       	in	r24, 0x16	; 22
 536:	c1 e0       	ldi	r28, 0x01	; 1
 538:	d8 2f       	mov	r29, r24
 53a:	d2 70       	andi	r29, 0x02	; 2
 53c:	81 ff       	sbrs	r24, 1
 53e:	c0 e0       	ldi	r28, 0x00	; 0
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:120
  delay(10);
 540:	6a e0       	ldi	r22, 0x0A	; 10
 542:	70 e0       	ldi	r23, 0x00	; 0
 544:	80 e0       	ldi	r24, 0x00	; 0
 546:	90 e0       	ldi	r25, 0x00	; 0
 548:	cd de       	rcall	.-614    	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:121
  if(tmp == bitRead(PINB, 1)){return tmp;}else{return !tmp;}
 54a:	86 b3       	in	r24, 0x16	; 22
 54c:	81 fb       	bst	r24, 1
 54e:	00 27       	eor	r16, r16
 550:	00 f9       	bld	r16, 0
 552:	10 e0       	ldi	r17, 0x00	; 0
 554:	c0 17       	cp	r28, r16
 556:	11 06       	cpc	r1, r17
 558:	19 f0       	breq	.+6      	; 0x560 <getButtonState()+0x34>
 55a:	c1 e0       	ldi	r28, 0x01	; 1
 55c:	d1 11       	cpse	r29, r1
 55e:	c0 e0       	ldi	r28, 0x00	; 0
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:122
}
 560:	8c 2f       	mov	r24, r28
 562:	df 91       	pop	r29
 564:	cf 91       	pop	r28
 566:	1f 91       	pop	r17
 568:	0f 91       	pop	r16
 56a:	08 95       	ret

0000056c <draw_Bat(unsigned char)>:
draw_Bat():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:80
  255,255,254,254,254,254,252,
  255,255,127,127,127,127,63,
  255,127,0,0,0,0,0,
};

void draw_Bat(uint8_t val){
 56c:	cf 93       	push	r28
 56e:	df 93       	push	r29
 570:	d8 2f       	mov	r29, r24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:81
	if(val==0){oled.bitmap(0,0,13,4,batBot0);} else {oled.bitmap(0,0,13,4,batBot1);}
 572:	4e eb       	ldi	r20, 0xBE	; 190
 574:	50 e0       	ldi	r21, 0x00	; 0
 576:	88 23       	and	r24, r24
 578:	11 f0       	breq	.+4      	; 0x57e <draw_Bat(unsigned char)+0x12>
 57a:	4a e8       	ldi	r20, 0x8A	; 138
 57c:	50 e0       	ldi	r21, 0x00	; 0
 57e:	6d e0       	ldi	r22, 0x0D	; 13
 580:	80 e0       	ldi	r24, 0x00	; 0
 582:	1c df       	rcall	.-456    	; 0x3bc <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:80
  255,255,254,254,254,254,252,
  255,255,127,127,127,127,63,
  255,127,0,0,0,0,0,
};

void draw_Bat(uint8_t val){
 584:	c2 e0       	ldi	r28, 0x02	; 2
 586:	8c 2f       	mov	r24, r28
 588:	6a e0       	ldi	r22, 0x0A	; 10
 58a:	87 d3       	rcall	.+1806   	; 0xc9a <__mulqi3>
 58c:	87 50       	subi	r24, 0x07	; 7
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:82
	if(val==0){oled.bitmap(0,0,13,4,batBot0);} else {oled.bitmap(0,0,13,4,batBot1);}
	for(uint8_t ix=2;ix<=6;ix++){if(ix<=val){oled.bitmap(13+(ix-2)*10,0,10,4,bat1);}else{oled.bitmap(13+(ix-2)*10,0,10,4,bat0);}}
 58e:	42 e6       	ldi	r20, 0x62	; 98
 590:	50 e0       	ldi	r21, 0x00	; 0
 592:	dc 17       	cp	r29, r28
 594:	10 f4       	brcc	.+4      	; 0x59a <draw_Bat(unsigned char)+0x2e>
 596:	4a e3       	ldi	r20, 0x3A	; 58
 598:	50 e0       	ldi	r21, 0x00	; 0
 59a:	6a e0       	ldi	r22, 0x0A	; 10
 59c:	0f df       	rcall	.-482    	; 0x3bc <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]>
 59e:	cf 5f       	subi	r28, 0xFF	; 255
 5a0:	c7 30       	cpi	r28, 0x07	; 7
 5a2:	89 f7       	brne	.-30     	; 0x586 <draw_Bat(unsigned char)+0x1a>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:83
	oled.bitmap(13+50,0,7,4,batEnd);
 5a4:	4e e1       	ldi	r20, 0x1E	; 30
 5a6:	50 e0       	ldi	r21, 0x00	; 0
 5a8:	67 e0       	ldi	r22, 0x07	; 7
 5aa:	8f e3       	ldi	r24, 0x3F	; 63
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:84
}
 5ac:	df 91       	pop	r29
 5ae:	cf 91       	pop	r28
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:83
};

void draw_Bat(uint8_t val){
	if(val==0){oled.bitmap(0,0,13,4,batBot0);} else {oled.bitmap(0,0,13,4,batBot1);}
	for(uint8_t ix=2;ix<=6;ix++){if(ix<=val){oled.bitmap(13+(ix-2)*10,0,10,4,bat1);}else{oled.bitmap(13+(ix-2)*10,0,10,4,bat0);}}
	oled.bitmap(13+50,0,7,4,batEnd);
 5b0:	05 cf       	rjmp	.-502    	; 0x3bc <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]>

000005b2 <wire_write(unsigned char)>:
write():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:498

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
 5b2:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <TwoWire::transmitting>
 5b6:	99 23       	and	r25, r25
 5b8:	99 f0       	breq	.+38     	; 0x5e0 <wire_write(unsigned char)+0x2e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:500
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
 5ba:	90 91 8d 00 	lds	r25, 0x008D	; 0x80008d <TwoWire::BufferLength>
 5be:	90 32       	cpi	r25, 0x20	; 32
 5c0:	38 f5       	brcc	.+78     	; 0x610 <wire_write(unsigned char)+0x5e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:504
      return 0;
    }
    // put byte in tx buffer
    Buffer[BufferIndex] = data;
 5c2:	90 91 8c 00 	lds	r25, 0x008C	; 0x80008c <TwoWire::BufferIndex>
 5c6:	e9 2f       	mov	r30, r25
 5c8:	f0 e0       	ldi	r31, 0x00	; 0
 5ca:	e6 59       	subi	r30, 0x96	; 150
 5cc:	ff 4f       	sbci	r31, 0xFF	; 255
 5ce:	80 83       	st	Z, r24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:505
    ++BufferIndex;
 5d0:	81 e0       	ldi	r24, 0x01	; 1
 5d2:	89 0f       	add	r24, r25
 5d4:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <TwoWire::BufferIndex>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:507
    // update amount in buffer
    BufferLength = BufferIndex;
 5d8:	80 93 8d 00 	sts	0x008D, r24	; 0x80008d <TwoWire::BufferLength>
wire_write():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:516
      return 0;
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
 5dc:	81 e0       	ldi	r24, 0x01	; 1
 5de:	08 95       	ret
USI_TWI_Space_In_Transmission_Buffer():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 5e0:	20 91 97 00 	lds	r18, 0x0097	; 0x800097 <TWI_TxHead>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 5e4:	90 91 96 00 	lds	r25, 0x0096	; 0x800096 <TWI_TxTail>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 5e8:	2f 5f       	subi	r18, 0xFF	; 255
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 5ea:	92 1b       	sub	r25, r18
 5ec:	9f 70       	andi	r25, 0x0F	; 15
write():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:510
    ++BufferIndex;
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
 5ee:	81 f0       	breq	.+32     	; 0x610 <wire_write(unsigned char)+0x5e>
USI_TWI_Transmit_Byte():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:100
// Puts data in the transmission buffer, Waits if buffer is full.
void USI_TWI_Transmit_Byte(unsigned char data)
{
  unsigned char tmphead;

  tmphead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate buffer index.
 5f0:	90 91 97 00 	lds	r25, 0x0097	; 0x800097 <TWI_TxHead>
 5f4:	9f 5f       	subi	r25, 0xFF	; 255
 5f6:	9f 70       	andi	r25, 0x0F	; 15
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:101
  while (tmphead == TWI_TxTail)
 5f8:	20 91 96 00 	lds	r18, 0x0096	; 0x800096 <TWI_TxTail>
 5fc:	92 17       	cp	r25, r18
 5fe:	e1 f3       	breq	.-8      	; 0x5f8 <wire_write(unsigned char)+0x46>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:103
    ;                         // Wait for free space in buffer.
  TWI_TxBuf[tmphead] = data;    // Store data in buffer.
 600:	e9 2f       	mov	r30, r25
 602:	f0 e0       	ldi	r31, 0x00	; 0
 604:	e6 58       	subi	r30, 0x86	; 134
 606:	ff 4f       	sbci	r31, 0xFF	; 255
 608:	80 83       	st	Z, r24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:104
  TWI_TxHead         = tmphead; // Store new index.
 60a:	90 93 97 00 	sts	0x0097, r25	; 0x800097 <TWI_TxHead>
 60e:	e6 cf       	rjmp	.-52     	; 0x5dc <wire_write(unsigned char)+0x2a>
wire_write():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:501
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
      return 0;
 610:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_Wire.h:41
	return true;
}

static bool wire_write(uint8_t byte) {
	return Wire.write(byte);
}
 612:	08 95       	ret

00000614 <wire_beginTransmission()>:
beginTransmission():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:453
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
 614:	81 e0       	ldi	r24, 0x01	; 1
 616:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <TwoWire::transmitting>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:455
  // set address of targeted slave and write mode
  Buffer[0] = (address << TWI_ADR_BITS) | (0 << TWI_READ_BIT);
 61a:	98 e7       	ldi	r25, 0x78	; 120
 61c:	90 93 6a 00 	sts	0x006A, r25	; 0x80006a <__data_end>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:457
  // reset tx buffer iterator vars
  BufferIndex = 1; // reserved by slave address
 620:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <TwoWire::BufferIndex>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:458
  BufferLength = BufferIndex;
 624:	80 93 8d 00 	sts	0x008D, r24	; 0x80008d <TwoWire::BufferLength>
wire_beginTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_Wire.h:37
}

static bool wire_beginTransmission(void) {
	Wire.beginTransmission(SSD1306);
	return true;
}
 628:	08 95       	ret

0000062a <USI_TWI_Master_Transfer>:
USI_TWI_Master_Transfer():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:226
 Data to be sent has to be placed into the USIDR prior to calling
 this function. Data read, will be return'ed from the function.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Transfer(unsigned char temp)
{
  USISR = temp;                                          // Set USISR according to temp.
 62a:	8e b9       	out	0x0e, r24	; 14
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:234
         (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
         (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software clock strobe as source.
         (1 << USITC);                                   // Toggle Clock Port.
  do {
    DELAY_T2TWI;
    USICR = temp; // Generate positive SCL edge.
 62c:	8b e2       	ldi	r24, 0x2B	; 43
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 62e:	9e e0       	ldi	r25, 0x0E	; 14
 630:	9a 95       	dec	r25
 632:	f1 f7       	brne	.-4      	; 0x630 <USI_TWI_Master_Transfer+0x6>
USI_TWI_Master_Transfer():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:234
 634:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:235
    while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 636:	b2 9b       	sbis	0x16, 2	; 22
 638:	fe cf       	rjmp	.-4      	; 0x636 <USI_TWI_Master_Transfer+0xc>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 63a:	96 e0       	ldi	r25, 0x06	; 6
 63c:	9a 95       	dec	r25
 63e:	f1 f7       	brne	.-4      	; 0x63c <USI_TWI_Master_Transfer+0x12>
 640:	00 c0       	rjmp	.+0      	; 0x642 <USI_TWI_Master_Transfer+0x18>
USI_TWI_Master_Transfer():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:238
      ; // Wait for SCL to go high.
    DELAY_T4TWI;
    USICR = temp;                   // Generate negative SCL edge.
 642:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:239
  } while (!(USISR & (1 << USIOIF))); // Check for transfer complete.
 644:	76 9b       	sbis	0x0e, 6	; 14
 646:	f3 cf       	rjmp	.-26     	; 0x62e <USI_TWI_Master_Transfer+0x4>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 648:	8e e0       	ldi	r24, 0x0E	; 14
 64a:	8a 95       	dec	r24
 64c:	f1 f7       	brne	.-4      	; 0x64a <USI_TWI_Master_Transfer+0x20>
USI_TWI_Master_Transfer():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:242

  DELAY_T2TWI;
  temp  = USIDR;                 // Read out data.
 64e:	8f b1       	in	r24, 0x0f	; 15
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:243
  USIDR = 0xFF;                  // Release SDA.
 650:	9f ef       	ldi	r25, 0xFF	; 255
 652:	9f b9       	out	0x0f, r25	; 15
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:244
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
 654:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:247

  return temp; // Return the data from the USIDR
}
 656:	08 95       	ret

00000658 <wire_endTransmission()>:
wire_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_Wire.h:43

static bool wire_write(uint8_t byte) {
	return Wire.write(byte);
}

static uint8_t wire_endTransmission(void) {
 658:	0f 93       	push	r16
 65a:	1f 93       	push	r17
 65c:	cf 93       	push	r28
 65e:	df 93       	push	r29
endTransmission():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:467
  beginTransmission((uint8_t)address);
}

uint8_t TwoWire::endTransmission(uint8_t sendStop) {
  // transmit buffer (blocking)
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer,
 660:	c0 91 8d 00 	lds	r28, 0x008D	; 0x80008d <TwoWire::BufferLength>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:115
  unsigned char tempUSISR_1bit = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC)
                                 |                 // Prepare register value to: Clear flags, and
                                 (0xE << USICNT0); // set USI to shift 1 bit i.e. count 2 clock edges.

  USI_TWI_state.errorState  = 0;
  USI_TWI_state.addressMode = TRUE;
 664:	81 e0       	ldi	r24, 0x01	; 1
 666:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <USI_TWI_state>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:145
    USI_TWI_state.errorState = USI_TWI_UE_DATA_COL;
    return (FALSE);
  }
#endif

  if (!(*msg
 66a:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <__data_end>
 66e:	80 fd       	sbrc	r24, 0
 670:	03 c0       	rjmp	.+6      	; 0x678 <wire_endTransmission()+0x20>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:148
        & (1 << TWI_READ_BIT))) // The LSB in the address byte determines if is a masterRead or masterWrite operation.
  {
    USI_TWI_state.masterWriteDataMode = TRUE;
 672:	83 e0       	ldi	r24, 0x03	; 3
 674:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <USI_TWI_state>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:152
  }

  /* Release SCL to ensure that (repeated) Start can be performed */
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Release SCL.
 678:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:153
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 67a:	b2 9b       	sbis	0x16, 2	; 22
 67c:	fe cf       	rjmp	.-4      	; 0x67a <wire_endTransmission()+0x22>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 67e:	86 e0       	ldi	r24, 0x06	; 6
 680:	8a 95       	dec	r24
 682:	f1 f7       	brne	.-4      	; 0x680 <wire_endTransmission()+0x28>
 684:	00 c0       	rjmp	.+0      	; 0x686 <wire_endTransmission()+0x2e>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:162
#else
  DELAY_T2TWI; // Delay for T2TWI if TWI_STANDARD_MODE
#endif

  /* Generate Start Condition */
  PORT_USI &= ~(1 << PIN_USI_SDA); // Force SDA LOW.
 686:	c0 98       	cbi	0x18, 0	; 24
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 688:	e6 e0       	ldi	r30, 0x06	; 6
 68a:	ea 95       	dec	r30
 68c:	f1 f7       	brne	.-4      	; 0x68a <wire_endTransmission()+0x32>
 68e:	00 c0       	rjmp	.+0      	; 0x690 <wire_endTransmission()+0x38>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:164
  DELAY_T4TWI;
  PORT_USI_CL &= ~(1 << PIN_USI_SCL); // Pull SCL LOW.
 690:	c2 98       	cbi	0x18, 2	; 24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:165
  PORT_USI |= (1 << PIN_USI_SDA);  // Release SDA.
 692:	c0 9a       	sbi	0x18, 0	; 24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:168

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USISIF))) {
 694:	77 99       	sbic	0x0e, 7	; 14
 696:	1c c0       	rjmp	.+56     	; 0x6d0 <wire_endTransmission()+0x78>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:169
    USI_TWI_state.errorState = USI_TWI_MISSING_START_CON;
 698:	87 e0       	ldi	r24, 0x07	; 7
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:187

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
        if (USI_TWI_state.addressMode)
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 69a:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <USI_TWI_state>
wire_endTransmission():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:190
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
        return (FALSE);
 69e:	80 e0       	ldi	r24, 0x00	; 0
endTransmission():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:471
                                                         BufferLength,
                                                         sendStop);
  // reset tx buffer iterator vars
  BufferIndex = 0;
 6a0:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <TwoWire::BufferIndex>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:472
  BufferLength = 0;
 6a4:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <TwoWire::BufferLength>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:474
  // indicate that we are done transmitting
  transmitting = 0;
 6a8:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <TwoWire::transmitting>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:476
  // check for error
  if (ret == FALSE) {
 6ac:	81 11       	cpse	r24, r1
 6ae:	5c c0       	rjmp	.+184    	; 0x768 <wire_endTransmission()+0x110>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:477
    switch (USI_TWI_Get_State_Info()) {
 6b0:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <USI_TWI_state>
 6b4:	85 30       	cpi	r24, 0x05	; 5
 6b6:	09 f4       	brne	.+2      	; 0x6ba <wire_endTransmission()+0x62>
 6b8:	53 c0       	rjmp	.+166    	; 0x760 <wire_endTransmission()+0x108>
 6ba:	86 30       	cpi	r24, 0x06	; 6
 6bc:	09 f4       	brne	.+2      	; 0x6c0 <wire_endTransmission()+0x68>
 6be:	56 c0       	rjmp	.+172    	; 0x76c <wire_endTransmission()+0x114>
 6c0:	81 30       	cpi	r24, 0x01	; 1
 6c2:	09 f0       	breq	.+2      	; 0x6c6 <wire_endTransmission()+0x6e>
 6c4:	4f c0       	rjmp	.+158    	; 0x764 <wire_endTransmission()+0x10c>
wire_endTransmission():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_Wire.h:45
	return Wire.endTransmission();
}
 6c6:	df 91       	pop	r29
 6c8:	cf 91       	pop	r28
 6ca:	1f 91       	pop	r17
 6cc:	0f 91       	pop	r16
 6ce:	08 95       	ret
 6d0:	0a e6       	ldi	r16, 0x6A	; 106
 6d2:	10 e0       	ldi	r17, 0x00	; 0
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:203
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 6d4:	df ef       	ldi	r29, 0xFF	; 255
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:177
#endif

  /*Write address and Read/Write data */
  do {
    /* If masterWrite cycle (or initial address transmission)*/
    if (USI_TWI_state.addressMode || USI_TWI_state.masterWriteDataMode) {
 6d6:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <USI_TWI_state>
 6da:	83 70       	andi	r24, 0x03	; 3
 6dc:	a1 f1       	breq	.+104    	; 0x746 <wire_endTransmission()+0xee>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:179
      /* Write a byte */
      PORT_USI_CL &= ~(1 << PIN_USI_SCL);         // Pull SCL LOW.
 6de:	c2 98       	cbi	0x18, 2	; 24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:180
      USIDR = *(msg++);                        // Setup data.
 6e0:	f8 01       	movw	r30, r16
 6e2:	80 81       	ld	r24, Z
 6e4:	8f b9       	out	0x0f, r24	; 15
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:181
      USI_TWI_Master_Transfer(tempUSISR_8bit); // Send 8 bits on bus.
 6e6:	80 ef       	ldi	r24, 0xF0	; 240
 6e8:	a0 df       	rcall	.-192    	; 0x62a <USI_TWI_Master_Transfer>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:184

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 6ea:	b8 98       	cbi	0x17, 0	; 23
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:185
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
 6ec:	8e ef       	ldi	r24, 0xFE	; 254
 6ee:	9d df       	rcall	.-198    	; 0x62a <USI_TWI_Master_Transfer>
 6f0:	80 ff       	sbrs	r24, 0
 6f2:	0c c0       	rjmp	.+24     	; 0x70c <wire_endTransmission()+0xb4>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:186
        if (USI_TWI_state.addressMode)
 6f4:	90 91 8a 00 	lds	r25, 0x008A	; 0x80008a <USI_TWI_state>
 6f8:	89 2f       	mov	r24, r25
 6fa:	81 70       	andi	r24, 0x01	; 1
 6fc:	90 ff       	sbrs	r25, 0
 6fe:	02 c0       	rjmp	.+4      	; 0x704 <wire_endTransmission()+0xac>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:187
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 700:	86 e0       	ldi	r24, 0x06	; 6
 702:	cb cf       	rjmp	.-106    	; 0x69a <wire_endTransmission()+0x42>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:189
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
 704:	95 e0       	ldi	r25, 0x05	; 5
 706:	90 93 8a 00 	sts	0x008A, r25	; 0x80008a <USI_TWI_state>
 70a:	ca cf       	rjmp	.-108    	; 0x6a0 <wire_endTransmission()+0x48>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:192
        return (FALSE);
      }
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
 70c:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <USI_TWI_state>
 710:	8e 7f       	andi	r24, 0xFE	; 254
 712:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <USI_TWI_state>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:209
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
    }
  } while (--msgSize); // Until all data sent/received.
 716:	c1 50       	subi	r28, 0x01	; 1
 718:	0f 5f       	subi	r16, 0xFF	; 255
 71a:	1f 4f       	sbci	r17, 0xFF	; 255
 71c:	c1 11       	cpse	r28, r1
 71e:	db cf       	rjmp	.-74     	; 0x6d6 <wire_endTransmission()+0x7e>
USI_TWI_Master_Stop():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:255
 Function for generating a TWI Stop Condition. Used to release
 the TWI bus.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Stop(void)
{
  PORT_USI &= ~(1 << PIN_USI_SDA); // Pull SDA low.
 720:	c0 98       	cbi	0x18, 0	; 24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:256
  PORT_USI_CL |= (1 << PIN_USI_SCL);  // Release SCL.
 722:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:257
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 724:	b2 9b       	sbis	0x16, 2	; 22
 726:	fe cf       	rjmp	.-4      	; 0x724 <wire_endTransmission()+0xcc>
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 728:	f6 e0       	ldi	r31, 0x06	; 6
 72a:	fa 95       	dec	r31
 72c:	f1 f7       	brne	.-4      	; 0x72a <wire_endTransmission()+0xd2>
 72e:	00 c0       	rjmp	.+0      	; 0x730 <wire_endTransmission()+0xd8>
USI_TWI_Master_Stop():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:260
    ; // Wait for SCL to go high.
  DELAY_T4TWI;
  PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
 730:	c0 9a       	sbi	0x18, 0	; 24
_delay_us():
c:\users\pavel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino5\avr\include\util/delay.h:276
 732:	8e e0       	ldi	r24, 0x0E	; 14
 734:	8a 95       	dec	r24
 736:	f1 f7       	brne	.-4      	; 0x734 <wire_endTransmission()+0xdc>
USI_TWI_Master_Stop():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:264
  DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USIPF))) {
 738:	75 99       	sbic	0x0e, 5	; 14
 73a:	03 c0       	rjmp	.+6      	; 0x742 <wire_endTransmission()+0xea>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:265
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
 73c:	88 e0       	ldi	r24, 0x08	; 8
 73e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <USI_TWI_state>
wire_endTransmission():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:216
  if (stop) {
    USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
  }

  /* Transmission successfully completed*/
  return (TRUE);
 742:	81 e0       	ldi	r24, 0x01	; 1
 744:	ad cf       	rjmp	.-166    	; 0x6a0 <wire_endTransmission()+0x48>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:197
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
    }
    /* Else masterRead cycle*/
    else {
      /* Read a data byte */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 746:	b8 98       	cbi	0x17, 0	; 23
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:198
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);
 748:	80 ef       	ldi	r24, 0xF0	; 240
 74a:	6f df       	rcall	.-290    	; 0x62a <USI_TWI_Master_Transfer>
 74c:	f8 01       	movw	r30, r16
 74e:	80 83       	st	Z, r24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:201

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
 750:	c1 30       	cpi	r28, 0x01	; 1
 752:	21 f4       	brne	.+8      	; 0x75c <wire_endTransmission()+0x104>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:203
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 754:	df b9       	out	0x0f, r29	; 15
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:207
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
 756:	8e ef       	ldi	r24, 0xFE	; 254
 758:	68 df       	rcall	.-304    	; 0x62a <USI_TWI_Master_Transfer>
 75a:	dd cf       	rjmp	.-70     	; 0x716 <wire_endTransmission()+0xbe>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:205
      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
 75c:	1f b8       	out	0x0f, r1	; 15
 75e:	fb cf       	rjmp	.-10     	; 0x756 <wire_endTransmission()+0xfe>
wire_endTransmission():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:483
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
    case USI_TWI_NO_ACK_ON_ADDRESS:
      return 2; //received NACK on transmit of address
    case USI_TWI_NO_ACK_ON_DATA:
      return 3; //received NACK on transmit of data
 760:	83 e0       	ldi	r24, 0x03	; 3
 762:	b1 cf       	rjmp	.-158    	; 0x6c6 <wire_endTransmission()+0x6e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:485
    }
    return 4; //other error
 764:	84 e0       	ldi	r24, 0x04	; 4
 766:	af cf       	rjmp	.-162    	; 0x6c6 <wire_endTransmission()+0x6e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:487
  }
  return 0; //success
 768:	80 e0       	ldi	r24, 0x00	; 0
 76a:	ad cf       	rjmp	.-166    	; 0x6c6 <wire_endTransmission()+0x6e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:481
  if (ret == FALSE) {
    switch (USI_TWI_Get_State_Info()) {
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
    case USI_TWI_NO_ACK_ON_ADDRESS:
      return 2; //received NACK on transmit of address
 76c:	82 e0       	ldi	r24, 0x02	; 2
 76e:	ab cf       	rjmp	.-170    	; 0x6c6 <wire_endTransmission()+0x6e>

00000770 <wire_begin()>:
begin():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:362
}

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void) {
  BufferIndex = 0;
 770:	10 92 8c 00 	sts	0x008C, r1	; 0x80008c <TwoWire::BufferIndex>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:363
  BufferLength = 0;
 774:	10 92 8d 00 	sts	0x008D, r1	; 0x80008d <TwoWire::BufferLength>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src/Wire.cpp:365

  transmitting = 0;
 778:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <TwoWire::transmitting>
USI_TWI_Master_Initialise():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:56
/*---------------------------------------------------------------
 USI TWI single master initialization function
---------------------------------------------------------------*/
void USI_TWI_Master_Initialise(void)
{
  PORT_USI |= (1 << PIN_USI_SDA); // Enable pullup on SDA, to set high as released state.
 77c:	c0 9a       	sbi	0x18, 0	; 24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:57
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Enable pullup on SCL, to set high as released state.
 77e:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:59

  DDR_USI_CL |= (1 << PIN_USI_SCL); // Enable SCL as output.
 780:	ba 9a       	sbi	0x17, 2	; 23
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:60
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
 782:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:62

  USIDR = 0xFF;                                           // Preload dataregister with "released level" data.
 784:	8f ef       	ldi	r24, 0xFF	; 255
 786:	8f b9       	out	0x0f, r24	; 15
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:63
  USICR = (0 << USISIE) | (0 << USIOIE) |                 // Disable Interrupts.
 788:	8a e2       	ldi	r24, 0x2A	; 42
 78a:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:67
          (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
          (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software stobe as counter clock source
          (0 << USITC);
  USISR = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags,
 78c:	80 ef       	ldi	r24, 0xF0	; 240
 78e:	8e b9       	out	0x0e, r24	; 14
check():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_Wire.h:20
static uint8_t wire_endTransmission(void);

#ifndef TINY4KOLED_QUICK_BEGIN
inline static bool check (void) {
	const uint8_t noError = 0x00;
	wire_beginTransmission();
 790:	41 df       	rcall	.-382    	; 0x614 <wire_beginTransmission()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_Wire.h:21
	return (wire_endTransmission()==noError);
 792:	62 df       	rcall	.-316    	; 0x658 <wire_endTransmission()>
wire_begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_Wire.h:28
#endif

static void wire_begin(void) {
	Wire.begin();
#ifndef TINY4KOLED_QUICK_BEGIN
	while (!check()) {
 794:	88 23       	and	r24, r24
 796:	31 f0       	breq	.+12     	; 0x7a4 <wire_begin()+0x34>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_Wire.h:29
		delay(10);
 798:	6a e0       	ldi	r22, 0x0A	; 10
 79a:	70 e0       	ldi	r23, 0x00	; 0
 79c:	80 e0       	ldi	r24, 0x00	; 0
 79e:	90 e0       	ldi	r25, 0x00	; 0
 7a0:	a1 dd       	rcall	.-1214   	; 0x2e4 <delay>
 7a2:	f6 cf       	rjmp	.-20     	; 0x790 <wire_begin()+0x20>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED_Wire.h:32
	}
#endif
}
 7a4:	08 95       	ret

000007a6 <__vector_5>:
__vector_5():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:133
#else

#error Millis() timer not defined!

#endif
{
 7a6:	1f 92       	push	r1
 7a8:	0f 92       	push	r0
 7aa:	0f b6       	in	r0, 0x3f	; 63
 7ac:	0f 92       	push	r0
 7ae:	11 24       	eor	r1, r1
 7b0:	2f 93       	push	r18
 7b2:	3f 93       	push	r19
 7b4:	8f 93       	push	r24
 7b6:	9f 93       	push	r25
 7b8:	af 93       	push	r26
 7ba:	bf 93       	push	r27
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:136
  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access)
  unsigned long m = millis_timer_millis;
 7bc:	80 91 9a 00 	lds	r24, 0x009A	; 0x80009a <millis_timer_millis>
 7c0:	90 91 9b 00 	lds	r25, 0x009B	; 0x80009b <millis_timer_millis+0x1>
 7c4:	a0 91 9c 00 	lds	r26, 0x009C	; 0x80009c <millis_timer_millis+0x2>
 7c8:	b0 91 9d 00 	lds	r27, 0x009D	; 0x80009d <millis_timer_millis+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:137
  unsigned char f = millis_timer_fract;
 7cc:	30 91 99 00 	lds	r19, 0x0099	; 0x800099 <millis_timer_fract>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:149
    f -= FRACT_MAX;
    m += 1;
  }
...rmv */

  f += FRACT_INC;
 7d0:	26 e0       	ldi	r18, 0x06	; 6
 7d2:	23 0f       	add	r18, r19
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:151

  if (f >= FRACT_MAX)
 7d4:	2d 37       	cpi	r18, 0x7D	; 125
 7d6:	68 f1       	brcs	.+90     	; 0x832 <__vector_5+0x8c>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:153
  {
    f -= FRACT_MAX;
 7d8:	29 e8       	ldi	r18, 0x89	; 137
 7da:	23 0f       	add	r18, r19
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:155
  m += 1;
    m += MILLIS_INC;
 7dc:	03 96       	adiw	r24, 0x03	; 3
 7de:	a1 1d       	adc	r26, r1
 7e0:	b1 1d       	adc	r27, r1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:162
  else
  {
    m += MILLIS_INC;
  }

  millis_timer_fract = f;
 7e2:	20 93 99 00 	sts	0x0099, r18	; 0x800099 <millis_timer_fract>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:163
  millis_timer_millis = m;
 7e6:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <millis_timer_millis>
 7ea:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <millis_timer_millis+0x1>
 7ee:	a0 93 9c 00 	sts	0x009C, r26	; 0x80009c <millis_timer_millis+0x2>
 7f2:	b0 93 9d 00 	sts	0x009D, r27	; 0x80009d <millis_timer_millis+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:164
  millis_timer_overflow_count++;
 7f6:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <millis_timer_overflow_count>
 7fa:	90 91 9f 00 	lds	r25, 0x009F	; 0x80009f <millis_timer_overflow_count+0x1>
 7fe:	a0 91 a0 00 	lds	r26, 0x00A0	; 0x8000a0 <millis_timer_overflow_count+0x2>
 802:	b0 91 a1 00 	lds	r27, 0x00A1	; 0x8000a1 <millis_timer_overflow_count+0x3>
 806:	01 96       	adiw	r24, 0x01	; 1
 808:	a1 1d       	adc	r26, r1
 80a:	b1 1d       	adc	r27, r1
 80c:	80 93 9e 00 	sts	0x009E, r24	; 0x80009e <millis_timer_overflow_count>
 810:	90 93 9f 00 	sts	0x009F, r25	; 0x80009f <millis_timer_overflow_count+0x1>
 814:	a0 93 a0 00 	sts	0x00A0, r26	; 0x8000a0 <millis_timer_overflow_count+0x2>
 818:	b0 93 a1 00 	sts	0x00A1, r27	; 0x8000a1 <millis_timer_overflow_count+0x3>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:171

//MICROSECONDS_PER_MILLIS_OVERFLOW=2048
//MILLIS_INC=2
//FRACT_INC=6
//FRACT_MAX=125
}
 81c:	bf 91       	pop	r27
 81e:	af 91       	pop	r26
 820:	9f 91       	pop	r25
 822:	8f 91       	pop	r24
 824:	3f 91       	pop	r19
 826:	2f 91       	pop	r18
 828:	0f 90       	pop	r0
 82a:	0f be       	out	0x3f, r0	; 63
 82c:	0f 90       	pop	r0
 82e:	1f 90       	pop	r1
 830:	18 95       	reti
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:159
  m += 1;
    m += MILLIS_INC;
  }
  else
  {
    m += MILLIS_INC;
 832:	02 96       	adiw	r24, 0x02	; 2
 834:	a1 1d       	adc	r26, r1
 836:	b1 1d       	adc	r27, r1
 838:	d4 cf       	rjmp	.-88     	; 0x7e2 <__vector_5+0x3c>

0000083a <__vector_14>:
__vector_14():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:212
ISR(USI_OVERFLOW_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_OVERFLOW_VECTOR
__interrupt void USI_Counter_Overflow_ISR(void)
#endif
{
 83a:	1f 92       	push	r1
 83c:	0f 92       	push	r0
 83e:	0f b6       	in	r0, 0x3f	; 63
 840:	0f 92       	push	r0
 842:	11 24       	eor	r1, r1
 844:	2f 93       	push	r18
 846:	8f 93       	push	r24
 848:	9f 93       	push	r25
 84a:	ef 93       	push	r30
 84c:	ff 93       	push	r31
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:217
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 84e:	80 91 98 00 	lds	r24, 0x0098	; 0x800098 <USI_TWI_Overflow_State>
 852:	82 30       	cpi	r24, 0x02	; 2
 854:	09 f4       	brne	.+2      	; 0x858 <__vector_14+0x1e>
 856:	5e c0       	rjmp	.+188    	; 0x914 <__vector_14+0xda>
 858:	78 f4       	brcc	.+30     	; 0x878 <__vector_14+0x3e>
 85a:	88 23       	and	r24, r24
 85c:	49 f1       	breq	.+82     	; 0x8b0 <__vector_14+0x76>
 85e:	81 30       	cpi	r24, 0x01	; 1
 860:	09 f4       	brne	.+2      	; 0x864 <__vector_14+0x2a>
 862:	3e c0       	rjmp	.+124    	; 0x8e0 <__vector_14+0xa6>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:310
    {
      SET_USI_TO_SEND_NACK();
    }
    break;
  }
}
 864:	ff 91       	pop	r31
 866:	ef 91       	pop	r30
 868:	9f 91       	pop	r25
 86a:	8f 91       	pop	r24
 86c:	2f 91       	pop	r18
 86e:	0f 90       	pop	r0
 870:	0f be       	out	0x3f, r0	; 63
 872:	0f 90       	pop	r0
 874:	1f 90       	pop	r1
 876:	18 95       	reti
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:217
{
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 878:	84 30       	cpi	r24, 0x04	; 4
 87a:	09 f4       	brne	.+2      	; 0x87e <__vector_14+0x44>
 87c:	51 c0       	rjmp	.+162    	; 0x920 <__vector_14+0xe6>
 87e:	48 f1       	brcs	.+82     	; 0x8d2 <__vector_14+0x98>
 880:	85 30       	cpi	r24, 0x05	; 5
 882:	81 f7       	brne	.-32     	; 0x864 <__vector_14+0x2a>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:297
    break;

  // Copy data from USIDR and send ACK. Next USI_SLAVE_REQUEST_DATA
  case USI_SLAVE_GET_DATA_AND_SEND_ACK:
    // Put data into Buffer
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 884:	84 e0       	ldi	r24, 0x04	; 4
 886:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <USI_TWI_Overflow_State>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:298
    tmpUSIDR              = USIDR; // Not necessary, but prevents warnings
 88a:	9f b1       	in	r25, 0x0f	; 15
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:299
    tmpRxHead = (TWI_RxHead + 1) & TWI_RX_BUFFER_MASK;
 88c:	80 91 95 00 	lds	r24, 0x0095	; 0x800095 <TWI_RxHead>
 890:	8f 5f       	subi	r24, 0xFF	; 255
 892:	8f 70       	andi	r24, 0x0F	; 15
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:300
    if (TWI_RxTail != tmpRxHead) {
 894:	20 91 94 00 	lds	r18, 0x0094	; 0x800094 <TWI_RxTail>
 898:	28 17       	cp	r18, r24
 89a:	09 f4       	brne	.+2      	; 0x89e <__vector_14+0x64>
 89c:	46 c0       	rjmp	.+140    	; 0x92a <__vector_14+0xf0>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:301
      TWI_RxHead            = tmpRxHead;
 89e:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <TWI_RxHead>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
 8a2:	e0 91 95 00 	lds	r30, 0x0095	; 0x800095 <TWI_RxHead>
 8a6:	f0 e0       	ldi	r31, 0x00	; 0
 8a8:	e6 59       	subi	r30, 0x96	; 150
 8aa:	ff 4f       	sbci	r31, 0xFF	; 255
 8ac:	90 83       	st	Z, r25
 8ae:	0b c0       	rjmp	.+22     	; 0x8c6 <__vector_14+0x8c>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:221

  switch (USI_TWI_Overflow_State) {
  // ---------- Address mode ----------
  // Check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK, else reset USI.
  case USI_SLAVE_CHECK_ADDRESS:
    if ((USIDR == 0) || ((USIDR >> 1) == TWI_slaveAddress)) {
 8b0:	8f b1       	in	r24, 0x0f	; 15
 8b2:	88 23       	and	r24, r24
 8b4:	19 f0       	breq	.+6      	; 0x8bc <__vector_14+0x82>
 8b6:	8f b1       	in	r24, 0x0f	; 15
 8b8:	86 95       	lsr	r24
 8ba:	71 f4       	brne	.+28     	; 0x8d8 <__vector_14+0x9e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:222
      if (USIDR & 0x01) {
 8bc:	78 9b       	sbis	0x0f, 0	; 15
 8be:	07 c0       	rjmp	.+14     	; 0x8ce <__vector_14+0x94>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:229
          // reset tx buffer and call callback
          tmpTxTail = TWI_TxHead;
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
 8c0:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:231
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 8c2:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <USI_TWI_Overflow_State>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:233
      }
      SET_USI_TO_SEND_ACK();
 8c6:	1f b8       	out	0x0f, r1	; 15
 8c8:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 8ca:	8e e7       	ldi	r24, 0x7E	; 126
 8cc:	21 c0       	rjmp	.+66     	; 0x910 <__vector_14+0xd6>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:231
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 8ce:	84 e0       	ldi	r24, 0x04	; 4
 8d0:	f8 cf       	rjmp	.-16     	; 0x8c2 <__vector_14+0x88>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:242
    break;

  // ----- Master write data mode ------
  // Check reply and goto USI_SLAVE_SEND_DATA if OK, else reset USI.
  case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
    if (USIDR) // If NACK, the master does not want more data.
 8d2:	8f b1       	in	r24, 0x0f	; 15
 8d4:	88 23       	and	r24, r24
 8d6:	21 f0       	breq	.+8      	; 0x8e0 <__vector_14+0xa6>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:259
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 8d8:	b8 98       	cbi	0x17, 0	; 23
 8da:	88 ea       	ldi	r24, 0xA8	; 168
 8dc:	8d b9       	out	0x0d, r24	; 13
 8de:	17 c0       	rjmp	.+46     	; 0x90e <__vector_14+0xd4>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:253

  // Copy data from buffer to USIDR and set USI to shift byte. Next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
  case USI_SLAVE_SEND_DATA:

    // Get data from Buffer
    tmpTxTail = TWI_TxTail; // Not necessary, but prevents warnings
 8e0:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <TWI_TxTail>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:254
    if (TWI_TxHead != tmpTxTail) {
 8e4:	90 91 97 00 	lds	r25, 0x0097	; 0x800097 <TWI_TxHead>
 8e8:	98 17       	cp	r25, r24
 8ea:	b1 f3       	breq	.-20     	; 0x8d8 <__vector_14+0x9e>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:255
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
 8ec:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <TWI_TxTail>
 8f0:	8f 5f       	subi	r24, 0xFF	; 255
 8f2:	8f 70       	andi	r24, 0x0F	; 15
 8f4:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <TWI_TxTail>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:256
      USIDR      = TWI_TxBuf[TWI_TxTail];
 8f8:	e0 91 96 00 	lds	r30, 0x0096	; 0x800096 <TWI_TxTail>
 8fc:	f0 e0       	ldi	r31, 0x00	; 0
 8fe:	e6 58       	subi	r30, 0x86	; 134
 900:	ff 4f       	sbci	r31, 0xFF	; 255
 902:	80 81       	ld	r24, Z
 904:	8f b9       	out	0x0f, r24	; 15
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:262
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
      return;
    }
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 906:	82 e0       	ldi	r24, 0x02	; 2
 908:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <USI_TWI_Overflow_State>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:263
    SET_USI_TO_SEND_DATA();
 90c:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:276

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
    SET_USI_TO_READ_DATA();
 90e:	80 e7       	ldi	r24, 0x70	; 112
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 910:	8e b9       	out	0x0e, r24	; 14
 912:	a8 cf       	rjmp	.-176    	; 0x864 <__vector_14+0x2a>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:268
    SET_USI_TO_SEND_DATA();
    break;

  // Set USI to sample reply from master. Next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
  case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 914:	83 e0       	ldi	r24, 0x03	; 3
 916:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <USI_TWI_Overflow_State>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:269
    SET_USI_TO_READ_ACK();
 91a:	b8 98       	cbi	0x17, 0	; 23
 91c:	1f b8       	out	0x0f, r1	; 15
 91e:	d5 cf       	rjmp	.-86     	; 0x8ca <__vector_14+0x90>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:275
    break;

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 920:	85 e0       	ldi	r24, 0x05	; 5
 922:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <USI_TWI_Overflow_State>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:276
    SET_USI_TO_READ_DATA();
 926:	b8 98       	cbi	0x17, 0	; 23
 928:	f2 cf       	rjmp	.-28     	; 0x90e <__vector_14+0xd4>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 92a:	b8 98       	cbi	0x17, 0	; 23
 92c:	ce cf       	rjmp	.-100    	; 0x8ca <__vector_14+0x90>

0000092e <__vector_13>:
__vector_13():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:165
ISR(USI_START_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_START_VECTOR
__interrupt void USI_Start_Condition_ISR(void)
#endif
{
 92e:	1f 92       	push	r1
 930:	0f 92       	push	r0
 932:	0f b6       	in	r0, 0x3f	; 63
 934:	0f 92       	push	r0
 936:	11 24       	eor	r1, r1
 938:	8f 93       	push	r24
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:178
      // reset rx buffer
      TWI_RxTail = tmpRxHead;
    }
  }

  USI_TWI_Overflow_State = USI_SLAVE_CHECK_ADDRESS;
 93a:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <USI_TWI_Overflow_State>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:179
  DDR_USI &= ~(1 << PORT_USI_SDA); // Set SDA as input
 93e:	b8 98       	cbi	0x17, 0	; 23
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:180
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
 940:	b2 9b       	sbis	0x16, 2	; 22
 942:	04 c0       	rjmp	.+8      	; 0x94c <__vector_13+0x1e>
 944:	b0 9b       	sbis	0x16, 0	; 22
 946:	fc cf       	rjmp	.-8      	; 0x940 <__vector_13+0x12>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:185
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 948:	88 ea       	ldi	r24, 0xA8	; 168
 94a:	01 c0       	rjmp	.+2      	; 0x94e <__vector_13+0x20>
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 94c:	88 ef       	ldi	r24, 0xF8	; 248
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:185
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 94e:	8d b9       	out	0x0d, r24	; 13
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:198
            | // Enable Overflow and Start Condition Interrupt. (Keep StartCondInt to detect RESTART)
            (1 << USIWM1) | (1 << USIWM0) |                 // Set USI in Two-wire mode.
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  }
  USISR = (1 << USI_START_COND_INT) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags
 950:	80 ef       	ldi	r24, 0xF0	; 240
 952:	8e b9       	out	0x0e, r24	; 14
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:200
          (0x0 << USICNT0); // Set USI to sample 8 bits i.e. count 16 external pin toggles.
}
 954:	8f 91       	pop	r24
 956:	0f 90       	pop	r0
 958:	0f be       	out	0x3f, r0	; 63
 95a:	0f 90       	pop	r0
 95c:	1f 90       	pop	r1
 95e:	18 95       	reti

00000960 <__vector_9>:
__vector_9():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:195
  bitClear(PORTB, 3);
  //tmrval1 = TCNT1;
}

//ISR(TIMER1_OVF_vect){
ISR(TIMER1_COMPB_vect){
 960:	1f 92       	push	r1
 962:	0f 92       	push	r0
 964:	0f b6       	in	r0, 0x3f	; 63
 966:	0f 92       	push	r0
 968:	11 24       	eor	r1, r1
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:197
  //clear pin
  bitSet(PORTB, 3);
 96a:	c3 9a       	sbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:199
  //tmrval = TCNT1;
}
 96c:	0f 90       	pop	r0
 96e:	0f be       	out	0x3f, r0	; 63
 970:	0f 90       	pop	r0
 972:	1f 90       	pop	r1
 974:	18 95       	reti

00000976 <__vector_3>:
__vector_3():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:188
  WDTCR = (1<<WDE) | (1<<WDP1) | (1<<WDP2); // 1s
  sei();
}


ISR(TIMER1_COMPA_vect){
 976:	1f 92       	push	r1
 978:	0f 92       	push	r0
 97a:	0f b6       	in	r0, 0x3f	; 63
 97c:	0f 92       	push	r0
 97e:	11 24       	eor	r1, r1
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:190
  // set pin
  bitClear(PORTB, 3);
 980:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:192
  //tmrval1 = TCNT1;
}
 982:	0f 90       	pop	r0
 984:	0f be       	out	0x3f, r0	; 63
 986:	0f 90       	pop	r0
 988:	1f 90       	pop	r1
 98a:	18 95       	reti

0000098c <main>:
main():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/main.cpp:6
#include <Arduino.h>

int main(void)
{
  #ifdef TUNED_OSCCAL_VALUE
  OSCCAL = TUNED_OSCCAL_VALUE; //set the oscillator calibration value based on the pins_arduino.h file. If this is not set, it will be optimised away
 98c:	81 b7       	in	r24, 0x31	; 49
 98e:	81 bf       	out	0x31, r24	; 49
init():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:699
    } else {
      OSCCAL += 5;
    }
  }
  #endif
  sei();
 990:	78 94       	sei
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:831
  #endif
  #endif

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0) && defined(WGM01)
  sbi(TCCR0A, WGM01);
 992:	8a b5       	in	r24, 0x2a	; 42
 994:	82 60       	ori	r24, 0x02	; 2
 996:	8a bd       	out	0x2a, r24	; 42
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:832
  sbi(TCCR0A, WGM00);
 998:	8a b5       	in	r24, 0x2a	; 42
 99a:	81 60       	ori	r24, 0x01	; 1
 99c:	8a bd       	out	0x2a, r24	; 42
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:855
  #endif

  // Millis timer is always processor clock divided by MillisTimer_Prescale_Value (64)
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
   #ifdef TCCR0B
    TCCR0B = (TCCR0B & ~((1<<CS02)|(1<<CS01)|(1<<CS00))) | (MillisTimer_Prescale_Index << CS00);
 99e:	83 b7       	in	r24, 0x33	; 51
 9a0:	88 7f       	andi	r24, 0xF8	; 248
 9a2:	83 60       	ori	r24, 0x03	; 3
 9a4:	83 bf       	out	0x33, r24	; 51
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:867
  TCCR1B = (TCCR1B & ~((1<<CS13)|(1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #elif (TIMER_TO_USE_FOR_MILLIS == 1)
  TCCR1B = (TCCR1B & ~((1<<CS12)|(1<<CS11)|(1<<CS10))) | (MillisTimer_Prescale_Index << CS10);
  #endif
  // this needs to be called before setup() or some functions won't work there
  sei();
 9a6:	78 94       	sei
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:872

  #ifndef DISABLEMILLIS
  // Enable the overlow interrupt (this is the basic system tic-toc for millis)
  #if defined(TIMSK) && defined(TOIE0) && (TIMER_TO_USE_FOR_MILLIS == 0)
  sbi(TIMSK, TOIE0);
 9a8:	89 b7       	in	r24, 0x39	; 57
 9aa:	82 60       	ori	r24, 0x02	; 2
 9ac:	89 bf       	out	0x39, r24	; 57
initToneTimerInternal():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:507
  TCCR0B |= (ToneTimer_Prescale_Index << CS00);
  #elif defined(__AVR_ATtiny43__)
  TCCR1A = 3; //WGM 10=1, WGM11=1
  TCCR1B = 3; //prescaler of 64
  #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1)
  TCCR1 &= ~((1<<CS13) | (1<<CS12) | (1<<CS11) | (1<<CS10)); //stop the clock to configure
 9ae:	80 b7       	in	r24, 0x30	; 48
 9b0:	80 7f       	andi	r24, 0xF0	; 240
 9b2:	80 bf       	out	0x30, r24	; 48
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:509
  // Use the Tone Timer for fast PWM as phase correct not supported by this timer
  sbi(TCCR1, CTC1);
 9b4:	80 b7       	in	r24, 0x30	; 48
 9b6:	80 68       	ori	r24, 0x80	; 128
 9b8:	80 bf       	out	0x30, r24	; 48
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:511
  //#if !defined(__AVR_ATtiny85__)
  sbi(TCCR1, PWM1A); //for the tiny 85, Timer0 is used instead.
 9ba:	80 b7       	in	r24, 0x30	; 48
 9bc:	80 64       	ori	r24, 0x40	; 64
 9be:	80 bf       	out	0x30, r24	; 48
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:513
  //#endif
  sbi(GTCCR, PWM1B);
 9c0:	8c b5       	in	r24, 0x2c	; 44
 9c2:	80 64       	ori	r24, 0x40	; 64
 9c4:	8c bd       	out	0x2c, r24	; 44
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:514
  OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
 9c6:	8f ef       	ldi	r24, 0xFF	; 255
 9c8:	8d bd       	out	0x2d, r24	; 45
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:515
  TCCR1 |= (ToneTimer_Prescale_Index << CS10);
 9ca:	80 b7       	in	r24, 0x30	; 48
 9cc:	87 60       	ori	r24, 0x07	; 7
 9ce:	80 bf       	out	0x30, r24	; 48
init():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:893

  // Initialize the ADC
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
  #if defined(ADCSRA)
    // set a2d prescale factor
  ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 9d0:	86 b1       	in	r24, 0x06	; 6
 9d2:	88 77       	andi	r24, 0x78	; 120
 9d4:	86 68       	ori	r24, 0x86	; 134
 9d6:	86 b9       	out	0x06, r24	; 6
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/wiring.c:895
    // enable a2d conversions
    sbi(ADCSRA, ADEN);
 9d8:	37 9a       	sbi	0x06, 7	; 6
setup():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:130
  wdt_disable();
}

void setup() {
  //stop motor
  bitClear(PORTB, 3);
 9da:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:131
  bitSet(DDRB, 3);
 9dc:	bb 9a       	sbi	0x17, 3	; 23
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:133

  bitClear(DDRB, 1); // Input
 9de:	b9 98       	cbi	0x17, 1	; 23
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:134
  bitSet(PORTB, 1); // Enable pullup
 9e0:	c1 9a       	sbi	0x18, 1	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:136

  disableWatchdog();
 9e2:	9b dd       	rcall	.-1226   	; 0x51a <disableWatchdog()>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:139
  
  // configure ADC
  ADMUX =
 9e4:	82 e0       	ldi	r24, 0x02	; 2
 9e6:	87 b9       	out	0x07, r24	; 7
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:148
           (0 << REFS0) |     // Sets ref. voltage to VCC
           (0 << MUX3)  |     // use ADC2 for input (PB4)
           (0 << MUX2)  |     // use ADC2 for input (PB4)
           (1 << MUX1)  |     // use ADC2 for input (PB4)
           (0 << MUX0);       // use ADC2 for input (PB4)
 ADCSRA = 
 9e8:	87 e8       	ldi	r24, 0x87	; 135
 9ea:	86 b9       	out	0x06, r24	; 6
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:155
           (1 << ADPS2) |     // set prescaler to 64, bit 2 
           (1 << ADPS1) |     // set prescaler to 64, bit 1 
           (1 << ADPS0);      // set prescaler to 64, bit 0 


  ADCSRA |= (1 << ADSC); // start first conversion
 9ec:	36 9a       	sbi	0x06, 6	; 6
ssd1306_begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:58
static bool (*wireBeginTransmissionFn)(void);
static bool (*wireWriteFn)(uint8_t byte);
static uint8_t (*wireEndTransmissionFn)(void);

static void ssd1306_begin(void) {
	wireBeginFn();
 9ee:	e0 91 a2 00 	lds	r30, 0x00A2	; 0x8000a2 <wireBeginFn>
 9f2:	f0 91 a3 00 	lds	r31, 0x00A3	; 0x8000a3 <wireBeginFn+0x1>
 9f6:	09 95       	icall
begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:157
}

void SSD1306Device::begin(uint8_t init_sequence_length, const uint8_t init_sequence []) {
	ssd1306_begin();

	ssd1306_send_command_start();
 9f8:	bc dc       	rcall	.-1672   	; 0x372 <ssd1306_send_command_start()>
 9fa:	c2 ef       	ldi	r28, 0xF2	; 242
 9fc:	d0 e0       	ldi	r29, 0x00	; 0
 9fe:	4a ef       	ldi	r20, 0xFA	; 250
 a00:	e4 2e       	mov	r14, r20
 a02:	40 e0       	ldi	r20, 0x00	; 0
 a04:	f4 2e       	mov	r15, r20
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:159
	for (uint8_t i = 0; i < init_sequence_length; i++) {
		ssd1306_send_command_byte(pgm_read_byte(&init_sequence[i]));
 a06:	fe 01       	movw	r30, r28
 a08:	14 91       	lpm	r17, Z
ssd1306_send_command_byte():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:84
	ssd1306_send_start();
	ssd1306_send_byte(SSD1306_DATA);
}

static void ssd1306_send_command_byte(uint8_t byte) {
	if (ssd1306_send_byte(byte) == 0) {
 a0a:	81 2f       	mov	r24, r17
 a0c:	9a dc       	rcall	.-1740   	; 0x342 <ssd1306_send_byte(unsigned char)>
 a0e:	81 11       	cpse	r24, r1
 a10:	04 c0       	rjmp	.+8      	; 0xa1a <main+0x8e>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:85
		ssd1306_send_stop();
 a12:	92 dc       	rcall	.-1756   	; 0x338 <ssd1306_send_stop()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:86
		ssd1306_send_command_start();
 a14:	ae dc       	rcall	.-1700   	; 0x372 <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:87
		ssd1306_send_byte(byte);
 a16:	81 2f       	mov	r24, r17
 a18:	94 dc       	rcall	.-1752   	; 0x342 <ssd1306_send_byte(unsigned char)>
 a1a:	21 96       	adiw	r28, 0x01	; 1
begin():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:158

void SSD1306Device::begin(uint8_t init_sequence_length, const uint8_t init_sequence []) {
	ssd1306_begin();

	ssd1306_send_command_start();
	for (uint8_t i = 0; i < init_sequence_length; i++) {
 a1c:	ec 16       	cp	r14, r28
 a1e:	fd 06       	cpc	r15, r29
 a20:	91 f7       	brne	.-28     	; 0xa06 <main+0x7a>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:161
		ssd1306_send_command_byte(pgm_read_byte(&init_sequence[i]));
	}
	ssd1306_send_stop();
 a22:	8a dc       	rcall	.-1772   	; 0x338 <ssd1306_send_stop()>
clear():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:184
	oledX = x;
	oledY = y;
}

void SSD1306Device::clear(void) {
	fill(0x00);
 a24:	0b dd       	rcall	.-1514   	; 0x43c <SSD1306Device::fill(unsigned char) [clone .constprop.4]>
setup():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:162
  #ifdef ENABLEFONT
  oled.setFont(FONT8X16);
  #endif
  oled.begin();
  oled.clear();
  draw_Bat(0); // prefill bufer with empty battery bitmap
 a26:	80 e0       	ldi	r24, 0x00	; 0
 a28:	a1 dd       	rcall	.-1214   	; 0x56c <draw_Bat(unsigned char)>
ssd1306_send_command():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:100
		ssd1306_send_byte(byte);
	}
}

static void ssd1306_send_command(uint8_t command) {
	ssd1306_send_command_start();
 a2a:	a3 dc       	rcall	.-1722   	; 0x372 <ssd1306_send_command_start()>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:101
	ssd1306_send_byte(command);
 a2c:	8f ea       	ldi	r24, 0xAF	; 175
 a2e:	89 dc       	rcall	.-1774   	; 0x342 <ssd1306_send_byte(unsigned char)>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:102
	ssd1306_send_stop();
 a30:	83 dc       	rcall	.-1786   	; 0x338 <ssd1306_send_stop()>
switchRenderFrame():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:306
}

// Double Buffering Commands

void SSD1306Device::switchRenderFrame(void) {
	renderingFrame ^= 0x04;
 a32:	80 91 61 00 	lds	r24, 0x0061	; 0x800061 <renderingFrame>
 a36:	94 e0       	ldi	r25, 0x04	; 4
 a38:	89 27       	eor	r24, r25
 a3a:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <renderingFrame>
setup():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:165
  oled.on();
  oled.switchRenderFrame();
  delay(50);
 a3e:	62 e3       	ldi	r22, 0x32	; 50
 a40:	70 e0       	ldi	r23, 0x00	; 0
 a42:	80 e0       	ldi	r24, 0x00	; 0
 a44:	90 e0       	ldi	r25, 0x00	; 0
 a46:	4e dc       	rcall	.-1892   	; 0x2e4 <delay>
clear():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:184
	oledX = x;
	oledY = y;
}

void SSD1306Device::clear(void) {
	fill(0x00);
 a48:	f9 dc       	rcall	.-1550   	; 0x43c <SSD1306Device::fill(unsigned char) [clone .constprop.4]>
setup():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:169
  oled.clear(); //clear invisible frame

  //if switch is ON then show warning
  if(getButtonState()==0){
 a4a:	70 dd       	rcall	.-1312   	; 0x52c <getButtonState()>
 a4c:	81 11       	cpse	r24, r1
 a4e:	0b c0       	rjmp	.+22     	; 0xa66 <main+0xda>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:170
    oled.bitmap(128-32,0,32,4,stateDANGER);
 a50:	4a e7       	ldi	r20, 0x7A	; 122
 a52:	51 e0       	ldi	r21, 0x01	; 1
 a54:	60 e2       	ldi	r22, 0x20	; 32
 a56:	80 e6       	ldi	r24, 0x60	; 96
 a58:	b1 dc       	rcall	.-1694   	; 0x3bc <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:171
    oled.switchFrame();
 a5a:	29 dd       	rcall	.-1454   	; 0x4ae <SSD1306Device::switchFrame() [clone .constprop.6]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:172
    delay(500);
 a5c:	64 ef       	ldi	r22, 0xF4	; 244
 a5e:	71 e0       	ldi	r23, 0x01	; 1
 a60:	80 e0       	ldi	r24, 0x00	; 0
 a62:	90 e0       	ldi	r25, 0x00	; 0
 a64:	3f dc       	rcall	.-1922   	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:175
  }
  //wait until button is released
  while(getButtonState()==0){
 a66:	62 dd       	rcall	.-1340   	; 0x52c <getButtonState()>
 a68:	81 11       	cpse	r24, r1
 a6a:	05 c0       	rjmp	.+10     	; 0xa76 <main+0xea>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:177
    // button is pressed
    delay(100);
 a6c:	64 e6       	ldi	r22, 0x64	; 100
 a6e:	70 e0       	ldi	r23, 0x00	; 0
 a70:	80 e0       	ldi	r24, 0x00	; 0
 a72:	90 e0       	ldi	r25, 0x00	; 0
 a74:	f7 cf       	rjmp	.-18     	; 0xa64 <main+0xd8>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:181
  }  

  // enable 1s watchdog with reset
  cli();
 a76:	f8 94       	cli
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:182
  WDTCR = (1<<WDCE);
 a78:	80 e1       	ldi	r24, 0x10	; 16
 a7a:	81 bd       	out	0x21, r24	; 33
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:183
  WDTCR = (1<<WDE) | (1<<WDP1) | (1<<WDP2); // 1s
 a7c:	8e e0       	ldi	r24, 0x0E	; 14
 a7e:	81 bd       	out	0x21, r24	; 33
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:184
  sei();
 a80:	78 94       	sei
getbatIndicatorVal():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:113
  if(adc128>=V1S6) return 6;
  if(adc128>=V1S5) return 5;
  if(adc128>=V1S4) return 4;
  if(adc128>=V1S3) return 3;
  if(adc128>=V1S2) return 2;
  if(adc128>=V1S1) return 1;
 a82:	bb 24       	eor	r11, r11
 a84:	b3 94       	inc	r11
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:217
}

// start motor smoothly
bool startMotor(void){
  cli();
  OCR1A = 95; // value to test
 a86:	df e5       	ldi	r29, 0x5F	; 95
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:218
  OCR1B = 255; // value to test	
 a88:	1f ef       	ldi	r17, 0xFF	; 255
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:219
  TCCR1 = (1<<CS13) | (1<<CS11) ; // Fast PWM mode (value 3)
 a8a:	0a e0       	ldi	r16, 0x0A	; 10
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:265
	delay(5);
    bitClear(PORTB,3);  
}

void loop() {  
  wdt_reset();
 a8c:	a8 95       	wdr
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:266
  uint16_t rawadc = readADC();
 a8e:	2f dd       	rcall	.-1442   	; 0x4ee <readADC()>
getbatIndicatorVal():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:107
// 3.85v - 66%
// 4.0v - 83%
// 4.2v - 100%

uint8_t getbatIndicatorVal(uint16_t rawadc){
  uint32_t adc128 = (uint32_t)rawadc * 128;
 a90:	b0 e0       	ldi	r27, 0x00	; 0
 a92:	a0 e0       	ldi	r26, 0x00	; 0
 a94:	6c 01       	movw	r12, r24
 a96:	7d 01       	movw	r14, r26
 a98:	37 e0       	ldi	r19, 0x07	; 7
 a9a:	cc 0c       	add	r12, r12
 a9c:	dd 1c       	adc	r13, r13
 a9e:	ee 1c       	adc	r14, r14
 aa0:	ff 1c       	adc	r15, r15
 aa2:	3a 95       	dec	r19
 aa4:	d1 f7       	brne	.-12     	; 0xa9a <main+0x10e>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:108
  if(adc128>=V1S6) return 6;
 aa6:	86 e0       	ldi	r24, 0x06	; 6
getbatIndicatorVal():
 aa8:	f1 e4       	ldi	r31, 0x41	; 65
 aaa:	cf 16       	cp	r12, r31
 aac:	f1 e8       	ldi	r31, 0x81	; 129
 aae:	df 06       	cpc	r13, r31
 ab0:	f1 e0       	ldi	r31, 0x01	; 1
 ab2:	ef 06       	cpc	r14, r31
 ab4:	f1 04       	cpc	r15, r1
 ab6:	70 f5       	brcc	.+92     	; 0xb14 <main+0x188>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:109
  if(adc128>=V1S5) return 5;
 ab8:	85 e0       	ldi	r24, 0x05	; 5
getbatIndicatorVal():
 aba:	24 e5       	ldi	r18, 0x54	; 84
 abc:	c2 16       	cp	r12, r18
 abe:	23 e7       	ldi	r18, 0x73	; 115
 ac0:	d2 06       	cpc	r13, r18
 ac2:	21 e0       	ldi	r18, 0x01	; 1
 ac4:	e2 06       	cpc	r14, r18
 ac6:	f1 04       	cpc	r15, r1
 ac8:	28 f5       	brcc	.+74     	; 0xb14 <main+0x188>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:110
  if(adc128>=V1S4) return 4;
 aca:	87 e6       	ldi	r24, 0x67	; 103
 acc:	c8 16       	cp	r12, r24
 ace:	85 e6       	ldi	r24, 0x65	; 101
 ad0:	d8 06       	cpc	r13, r24
 ad2:	81 e0       	ldi	r24, 0x01	; 1
 ad4:	e8 06       	cpc	r14, r24
 ad6:	f1 04       	cpc	r15, r1
 ad8:	08 f0       	brcs	.+2      	; 0xadc <main+0x150>
 ada:	4e c0       	rjmp	.+156    	; 0xb78 <main+0x1ec>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:111
  if(adc128>=V1S3) return 3;
 adc:	83 e0       	ldi	r24, 0x03	; 3
getbatIndicatorVal():
 ade:	9a e7       	ldi	r25, 0x7A	; 122
 ae0:	c9 16       	cp	r12, r25
 ae2:	97 e5       	ldi	r25, 0x57	; 87
 ae4:	d9 06       	cpc	r13, r25
 ae6:	91 e0       	ldi	r25, 0x01	; 1
 ae8:	e9 06       	cpc	r14, r25
 aea:	f1 04       	cpc	r15, r1
 aec:	98 f4       	brcc	.+38     	; 0xb14 <main+0x188>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:112
  if(adc128>=V1S2) return 2;
 aee:	82 e0       	ldi	r24, 0x02	; 2
getbatIndicatorVal():
 af0:	e3 e3       	ldi	r30, 0x33	; 51
 af2:	ce 16       	cp	r12, r30
 af4:	ee e4       	ldi	r30, 0x4E	; 78
 af6:	de 06       	cpc	r13, r30
 af8:	e1 e0       	ldi	r30, 0x01	; 1
 afa:	ee 06       	cpc	r14, r30
 afc:	f1 04       	cpc	r15, r1
 afe:	50 f4       	brcc	.+20     	; 0xb14 <main+0x188>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:113
  if(adc128>=V1S1) return 1;
 b00:	81 e0       	ldi	r24, 0x01	; 1
 b02:	f7 ee       	ldi	r31, 0xE7	; 231
 b04:	cf 16       	cp	r12, r31
 b06:	f4 e4       	ldi	r31, 0x44	; 68
 b08:	df 06       	cpc	r13, r31
 b0a:	f1 e0       	ldi	r31, 0x01	; 1
 b0c:	ef 06       	cpc	r14, r31
 b0e:	f1 04       	cpc	r15, r1
 b10:	08 f4       	brcc	.+2      	; 0xb14 <main+0x188>
 b12:	80 e0       	ldi	r24, 0x00	; 0
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:270
  wdt_reset();
  uint16_t rawadc = readADC();
  uint8_t batInd = getbatIndicatorVal(rawadc);
  bool batEmpty = isBatteryEmpty(rawadc);
  // redraw screen only when needed (to avoid unnecesarry i2c traffic)
  if(batInd!=prev_batInd || batEmpty){
 b14:	90 91 a5 00 	lds	r25, 0x00A5	; 0x8000a5 <prev_batInd>
 b18:	98 13       	cpse	r25, r24
 b1a:	08 c0       	rjmp	.+16     	; 0xb2c <main+0x1a0>
 b1c:	2f e7       	ldi	r18, 0x7F	; 127
 b1e:	c2 16       	cp	r12, r18
 b20:	26 e1       	ldi	r18, 0x16	; 22
 b22:	d2 06       	cpc	r13, r18
 b24:	21 e0       	ldi	r18, 0x01	; 1
 b26:	e2 06       	cpc	r14, r18
 b28:	f1 04       	cpc	r15, r1
 b2a:	c0 f4       	brcc	.+48     	; 0xb5c <main+0x1d0>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:271
    prev_batInd = batInd;
 b2c:	80 93 a5 00 	sts	0x00A5, r24	; 0x8000a5 <prev_batInd>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:272
	draw_Bat(batInd);
 b30:	1d dd       	rcall	.-1478   	; 0x56c <draw_Bat(unsigned char)>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:275
    
    if(batEmpty){
      oled.bitmap(128-32,0,32,4,stateDANGER);
 b32:	4a e7       	ldi	r20, 0x7A	; 122
 b34:	51 e0       	ldi	r21, 0x01	; 1
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:274
  // redraw screen only when needed (to avoid unnecesarry i2c traffic)
  if(batInd!=prev_batInd || batEmpty){
    prev_batInd = batInd;
	draw_Bat(batInd);
    
    if(batEmpty){
 b36:	8f e7       	ldi	r24, 0x7F	; 127
 b38:	c8 16       	cp	r12, r24
 b3a:	86 e1       	ldi	r24, 0x16	; 22
 b3c:	d8 06       	cpc	r13, r24
 b3e:	81 e0       	ldi	r24, 0x01	; 1
 b40:	e8 06       	cpc	r14, r24
 b42:	f1 04       	cpc	r15, r1
 b44:	10 f0       	brcs	.+4      	; 0xb4a <main+0x1be>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:277
      oled.bitmap(128-32,0,32,4,stateDANGER);
    }else{
      oled.bitmap(128-32,0,32,4,stateOK);
 b46:	4a ef       	ldi	r20, 0xFA	; 250
 b48:	50 e0       	ldi	r21, 0x00	; 0
 b4a:	60 e2       	ldi	r22, 0x20	; 32
 b4c:	80 e6       	ldi	r24, 0x60	; 96
 b4e:	36 dc       	rcall	.-1940   	; 0x3bc <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:279
    }
    oled.switchFrame();
 b50:	ae dc       	rcall	.-1700   	; 0x4ae <SSD1306Device::switchFrame() [clone .constprop.6]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:280
    delay(50); // make sure, that page switch doesn't occur too often
 b52:	62 e3       	ldi	r22, 0x32	; 50
 b54:	70 e0       	ldi	r23, 0x00	; 0
 b56:	80 e0       	ldi	r24, 0x00	; 0
 b58:	90 e0       	ldi	r25, 0x00	; 0
 b5a:	c4 db       	rcall	.-2168   	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:283
  }
  // check button and start/stop motor
  if(getButtonState()==1){
 b5c:	e7 dc       	rcall	.-1586   	; 0x52c <getButtonState()>
 b5e:	88 23       	and	r24, r24
 b60:	69 f0       	breq	.+26     	; 0xb7c <main+0x1f0>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:285
    // button is not pressed
	stopMotor();
 b62:	b8 dc       	rcall	.-1680   	; 0x4d4 <stopMotor()>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:294
	if(run_state!=1){
      batEmpty = startMotor();
	}
  }
  // If battery empty - stop the motor and hang the firmware
  if(batEmpty){
 b64:	ff e7       	ldi	r31, 0x7F	; 127
 b66:	cf 16       	cp	r12, r31
 b68:	f6 e1       	ldi	r31, 0x16	; 22
 b6a:	df 06       	cpc	r13, r31
 b6c:	f1 e0       	ldi	r31, 0x01	; 1
 b6e:	ef 06       	cpc	r14, r31
 b70:	f1 04       	cpc	r15, r1
 b72:	08 f0       	brcs	.+2      	; 0xb76 <main+0x1ea>
 b74:	8b cf       	rjmp	.-234    	; 0xa8c <main+0x100>
 b76:	2b c0       	rjmp	.+86     	; 0xbce <main+0x242>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:110

uint8_t getbatIndicatorVal(uint16_t rawadc){
  uint32_t adc128 = (uint32_t)rawadc * 128;
  if(adc128>=V1S6) return 6;
  if(adc128>=V1S5) return 5;
  if(adc128>=V1S4) return 4;
 b78:	84 e0       	ldi	r24, 0x04	; 4
 b7a:	cc cf       	rjmp	.-104    	; 0xb14 <main+0x188>
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:289
    // button is not pressed
	stopMotor();
  } else {
    // button is pressed
    // shuld we initiate start process?
	if(run_state!=1){
 b7c:	80 91 a4 00 	lds	r24, 0x00A4	; 0x8000a4 <run_state>
 b80:	81 30       	cpi	r24, 0x01	; 1
 b82:	81 f3       	breq	.-32     	; 0xb64 <main+0x1d8>
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:216
	  return res32 /32;
}

// start motor smoothly
bool startMotor(void){
  cli();
 b84:	f8 94       	cli
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:217
  OCR1A = 95; // value to test
 b86:	de bd       	out	0x2e, r29	; 46
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:218
  OCR1B = 255; // value to test	
 b88:	1b bd       	out	0x2b, r17	; 43
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:219
  TCCR1 = (1<<CS13) | (1<<CS11) ; // Fast PWM mode (value 3)
 b8a:	00 bf       	out	0x30, r16	; 48
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:221
  //TCCR0B = (0<<WGM02) | (1<<CS02) | (0<<CS01) | (0<<CS00); // Speed (value 3)
  TIMSK |= (1<<OCIE1A) | (1<<OCIE1B) ;//(1<<TOIE1); // enable compare match and overflow interrupts
 b8c:	89 b7       	in	r24, 0x39	; 57
 b8e:	80 66       	ori	r24, 0x60	; 96
 b90:	89 bf       	out	0x39, r24	; 57
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:222
  sei();
 b92:	78 94       	sei
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:223
  delay(30);
 b94:	6e e1       	ldi	r22, 0x1E	; 30
 b96:	70 e0       	ldi	r23, 0x00	; 0
 b98:	80 e0       	ldi	r24, 0x00	; 0
 b9a:	90 e0       	ldi	r25, 0x00	; 0
 b9c:	a3 db       	rcall	.-2234   	; 0x2e4 <delay>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:225
  //now motor starts at 50%. Increase the speed to 100%
  for(uint8_t i=100;i<190;i+=5){
 b9e:	c4 e6       	ldi	r28, 0x64	; 100
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:226
    wdt_reset();
 ba0:	a8 95       	wdr
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:227
    OCR1A = i;
 ba2:	ce bd       	out	0x2e, r28	; 46
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:228
  	delay(25);
 ba4:	69 e1       	ldi	r22, 0x19	; 25
 ba6:	70 e0       	ldi	r23, 0x00	; 0
 ba8:	80 e0       	ldi	r24, 0x00	; 0
 baa:	90 e0       	ldi	r25, 0x00	; 0
 bac:	9b db       	rcall	.-2250   	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:230
  	// check battery and button
  	uint16_t rawadc = readADC();
 bae:	9f dc       	rcall	.-1730   	; 0x4ee <readADC()>
isBatteryEmpty():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:95
		oled.fillLength(0,x1);
	}
}

bool isBatteryEmpty(uint16_t rawadc){
  return ((uint32_t)rawadc*128 >= V1S0 ? LOW : HIGH);
 bb0:	b0 e0       	ldi	r27, 0x00	; 0
 bb2:	a0 e0       	ldi	r26, 0x00	; 0
 bb4:	27 e0       	ldi	r18, 0x07	; 7
 bb6:	88 0f       	add	r24, r24
 bb8:	99 1f       	adc	r25, r25
 bba:	aa 1f       	adc	r26, r26
 bbc:	bb 1f       	adc	r27, r27
 bbe:	2a 95       	dec	r18
 bc0:	d1 f7       	brne	.-12     	; 0xbb6 <main+0x22a>
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:231
    wdt_reset();
    OCR1A = i;
  	delay(25);
  	// check battery and button
  	uint16_t rawadc = readADC();
    if(isBatteryEmpty(rawadc)){
 bc2:	8f 37       	cpi	r24, 0x7F	; 127
 bc4:	96 41       	sbci	r25, 0x16	; 22
 bc6:	a1 40       	sbci	r26, 0x01	; 1
 bc8:	b1 05       	cpc	r27, r1
 bca:	80 f5       	brcc	.+96     	; 0xc2c <main+0x2a0>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:232
		stopMotor();
 bcc:	83 dc       	rcall	.-1786   	; 0x4d4 <stopMotor()>
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:295
      batEmpty = startMotor();
	}
  }
  // If battery empty - stop the motor and hang the firmware
  if(batEmpty){
    stopMotor();
 bce:	82 dc       	rcall	.-1788   	; 0x4d4 <stopMotor()>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:296
    disableWatchdog();
 bd0:	a4 dc       	rcall	.-1720   	; 0x51a <disableWatchdog()>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:299
#ifndef NOHANG
	while(1==1){
		bitClear(PORTB,3); // just to be 100% sure that motor will not start
 bd2:	c3 98       	cbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:300
		draw_Bat(0);
 bd4:	80 e0       	ldi	r24, 0x00	; 0
 bd6:	ca dc       	rcall	.-1644   	; 0x56c <draw_Bat(unsigned char)>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:301
		oled.bitmap(128-32,0,32,4,stateDANGER);
 bd8:	4a e7       	ldi	r20, 0x7A	; 122
 bda:	51 e0       	ldi	r21, 0x01	; 1
 bdc:	60 e2       	ldi	r22, 0x20	; 32
 bde:	80 e6       	ldi	r24, 0x60	; 96
 be0:	ed db       	rcall	.-2086   	; 0x3bc <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:302
		oled.switchFrame();
 be2:	65 dc       	rcall	.-1846   	; 0x4ae <SSD1306Device::switchFrame() [clone .constprop.6]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:303
		delay(300);
 be4:	6c e2       	ldi	r22, 0x2C	; 44
 be6:	71 e0       	ldi	r23, 0x01	; 1
 be8:	80 e0       	ldi	r24, 0x00	; 0
 bea:	90 e0       	ldi	r25, 0x00	; 0
 bec:	7b db       	rcall	.-2314   	; 0x2e4 <delay>
main():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:88
	oled.bitmap(13+50,0,7,4,batEnd);
}

void draw_clear(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y0 + y1; y++) {
 bee:	c0 e0       	ldi	r28, 0x00	; 0
draw_clear():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:89
		oled.setCursor(x0,y);
 bf0:	6c 2f       	mov	r22, r28
 bf2:	80 e0       	ldi	r24, 0x00	; 0
 bf4:	c5 db       	rcall	.-2166   	; 0x380 <SSD1306Device::setCursor(unsigned char, unsigned char) [clone .constprop.14]>
fillLength():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:275
	fillLength(fill, 128 - oledX);
}

void SSD1306Device::fillLength(uint8_t fill, uint8_t length) {
	if (length == 0) return;
	oledX += length;
 bf6:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <oledX>
 bfa:	8a 5b       	subi	r24, 0xBA	; 186
 bfc:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <oledX>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:276
	ssd1306_send_data_start();
 c00:	a5 db       	rcall	.-2230   	; 0x34c <ssd1306_send_data_start()>
 c02:	d6 e4       	ldi	r29, 0x46	; 70
repeatData():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:291
	ssd1306_send_data_byte(data);
}

void SSD1306Device::repeatData(uint8_t data, uint8_t length) {
	for (uint8_t x = 0; x < length; x++) {
		ssd1306_send_data_byte(data);
 c04:	80 e0       	ldi	r24, 0x00	; 0
 c06:	a9 db       	rcall	.-2222   	; 0x35a <ssd1306_send_data_byte(unsigned char)>
 c08:	d1 50       	subi	r29, 0x01	; 1
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:290
void SSD1306Device::sendData(const uint8_t data) {
	ssd1306_send_data_byte(data);
}

void SSD1306Device::repeatData(uint8_t data, uint8_t length) {
	for (uint8_t x = 0; x < length; x++) {
 c0a:	e1 f7       	brne	.-8      	; 0xc04 <main+0x278>
fillLength():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:278
void SSD1306Device::fillLength(uint8_t fill, uint8_t length) {
	if (length == 0) return;
	oledX += length;
	ssd1306_send_data_start();
	repeatData(fill, length);
	ssd1306_send_stop();
 c0c:	95 db       	rcall	.-2262   	; 0x338 <ssd1306_send_stop()>
draw_clear():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:88
	oled.bitmap(13+50,0,7,4,batEnd);
}

void draw_clear(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1) {
	uint16_t j = 0;
 	for (uint8_t y = y0; y < y0 + y1; y++) {
 c0e:	cf 5f       	subi	r28, 0xFF	; 255
 c10:	c4 30       	cpi	r28, 0x04	; 4
 c12:	71 f7       	brne	.-36     	; 0xbf0 <main+0x264>
loop():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:305
		draw_Bat(0);
		oled.bitmap(128-32,0,32,4,stateDANGER);
		oled.switchFrame();
		delay(300);
		draw_clear(0,0,70,4);
		oled.bitmap(128-32,0,32,4,stateDANGER);
 c14:	4a e7       	ldi	r20, 0x7A	; 122
 c16:	51 e0       	ldi	r21, 0x01	; 1
 c18:	60 e2       	ldi	r22, 0x20	; 32
 c1a:	80 e6       	ldi	r24, 0x60	; 96
 c1c:	cf db       	rcall	.-2146   	; 0x3bc <SSD1306Device::bitmap(unsigned char, unsigned char, unsigned char, unsigned char, unsigned char const*) [clone .constprop.13]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:306
		oled.switchFrame();
 c1e:	47 dc       	rcall	.-1906   	; 0x4ae <SSD1306Device::switchFrame() [clone .constprop.6]>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:307
		delay(600);
 c20:	68 e5       	ldi	r22, 0x58	; 88
 c22:	72 e0       	ldi	r23, 0x02	; 2
 c24:	80 e0       	ldi	r24, 0x00	; 0
 c26:	90 e0       	ldi	r25, 0x00	; 0
 c28:	5d db       	rcall	.-2374   	; 0x2e4 <delay>
 c2a:	d3 cf       	rjmp	.-90     	; 0xbd2 <main+0x246>
startMotor():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:235
  	uint16_t rawadc = readADC();
    if(isBatteryEmpty(rawadc)){
		stopMotor();
	    return HIGH; // exit with low bat indication
  	}
	if(getButtonState()==1){
 c2c:	7f dc       	rcall	.-1794   	; 0x52c <getButtonState()>
 c2e:	88 23       	and	r24, r24
 c30:	11 f0       	breq	.+4      	; 0xc36 <main+0x2aa>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:237
		//button is released while starting motor
		stopMotor();
 c32:	50 dc       	rcall	.-1888   	; 0x4d4 <stopMotor()>
 c34:	2b cf       	rjmp	.-426    	; 0xa8c <main+0x100>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:225
  //TCCR0B = (0<<WGM02) | (1<<CS02) | (0<<CS01) | (0<<CS00); // Speed (value 3)
  TIMSK |= (1<<OCIE1A) | (1<<OCIE1B) ;//(1<<TOIE1); // enable compare match and overflow interrupts
  sei();
  delay(30);
  //now motor starts at 50%. Increase the speed to 100%
  for(uint8_t i=100;i<190;i+=5){
 c36:	cb 5f       	subi	r28, 0xFB	; 251
 c38:	ce 3b       	cpi	r28, 0xBE	; 190
 c3a:	09 f0       	breq	.+2      	; 0xc3e <main+0x2b2>
 c3c:	b1 cf       	rjmp	.-158    	; 0xba0 <main+0x214>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:242
		stopMotor();
	    return LOW; // exit
	}
  }
  // at the end run motor at full speed
  cli();
 c3e:	f8 94       	cli
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:243
  TCCR1 = 0; // stop timer
 c40:	10 be       	out	0x30, r1	; 48
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:244
  sei();
 c42:	78 94       	sei
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:245
  bitSet(PORTB, 3);
 c44:	c3 9a       	sbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:246
  delay(5);
 c46:	65 e0       	ldi	r22, 0x05	; 5
 c48:	70 e0       	ldi	r23, 0x00	; 0
 c4a:	80 e0       	ldi	r24, 0x00	; 0
 c4c:	90 e0       	ldi	r25, 0x00	; 0
 c4e:	4a db       	rcall	.-2412   	; 0x2e4 <delay>
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:247
  bitSet(PORTB, 3); // make sure motor is on. can be done with resetting interrupts flags.
 c50:	c3 9a       	sbi	0x18, 3	; 24
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:248
  run_state=1;
 c52:	b0 92 a4 00 	sts	0x00A4, r11	; 0x8000a4 <run_state>
 c56:	1a cf       	rjmp	.-460    	; 0xa8c <main+0x100>

00000c58 <_GLOBAL__sub_I_oled>:
_ZN5PrintC2Ev():
C:\Users\Pavel\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.3.3\cores\tiny/Print.h:75
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 c58:	e6 ea       	ldi	r30, 0xA6	; 166
 c5a:	f0 e0       	ldi	r31, 0x00	; 0
 c5c:	13 82       	std	Z+3, r1	; 0x03
 c5e:	12 82       	std	Z+2, r1	; 0x02
__base_ctor ():
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:143
	ssd1306_send_byte(command6);
	ssd1306_send_byte(command7);
	ssd1306_send_stop();
}

SSD1306Device::SSD1306Device(void (*wireBeginFunc)(void), bool (*wireBeginTransmissionFunc)(void), bool (*wireWriteFunc)(uint8_t byte), uint8_t (*wireEndTransmissionFunc)(void)) {
 c60:	86 e6       	ldi	r24, 0x66	; 102
 c62:	90 e0       	ldi	r25, 0x00	; 0
 c64:	91 83       	std	Z+1, r25	; 0x01
 c66:	80 83       	st	Z, r24
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:144
	wireBeginFn = wireBeginFunc;
 c68:	88 eb       	ldi	r24, 0xB8	; 184
 c6a:	93 e0       	ldi	r25, 0x03	; 3
 c6c:	90 93 a3 00 	sts	0x00A3, r25	; 0x8000a3 <wireBeginFn+0x1>
 c70:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <wireBeginFn>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:145
	wireBeginTransmissionFn = wireBeginTransmissionFunc;
 c74:	8a e0       	ldi	r24, 0x0A	; 10
 c76:	93 e0       	ldi	r25, 0x03	; 3
 c78:	90 93 93 00 	sts	0x0093, r25	; 0x800093 <wireBeginTransmissionFn+0x1>
 c7c:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <wireBeginTransmissionFn>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:146
	wireWriteFn = wireWriteFunc;
 c80:	89 ed       	ldi	r24, 0xD9	; 217
 c82:	92 e0       	ldi	r25, 0x02	; 2
 c84:	90 93 8f 00 	sts	0x008F, r25	; 0x80008f <wireWriteFn+0x1>
 c88:	80 93 8e 00 	sts	0x008E, r24	; 0x80008e <wireWriteFn>
C:\Users\Pavel\Documents\Arduino\libraries\Tiny4kOLED\src/Tiny4kOLED.cpp:147
	wireEndTransmissionFn = wireEndTransmissionFunc;
 c8c:	8c e2       	ldi	r24, 0x2C	; 44
 c8e:	93 e0       	ldi	r25, 0x03	; 3
 c90:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <wireEndTransmissionFn+0x1>
 c94:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <wireEndTransmissionFn>
_GLOBAL__sub_I_oled():
C:\src\Tennp\Git\ChainSawDIY\Firmware\diychainsaw/diychainsaw.ino:312
		delay(600);
	}
#endif
  }

}
 c98:	08 95       	ret

00000c9a <__mulqi3>:
__mulqi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:224
 c9a:	00 24       	eor	r0, r0

00000c9c <__mulqi3_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:226
 c9c:	80 fd       	sbrc	r24, 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:227
 c9e:	06 0e       	add	r0, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:228
 ca0:	66 0f       	add	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:229
 ca2:	11 f0       	breq	.+4      	; 0xca8 <__mulqi3_exit>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:230
 ca4:	86 95       	lsr	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:231
 ca6:	d1 f7       	brne	.-12     	; 0xc9c <__mulqi3_loop>

00000ca8 <__mulqi3_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:233
 ca8:	80 2d       	mov	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:234
 caa:	08 95       	ret

00000cac <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 cac:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 cae:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 cb0:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 cb2:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 cb4:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 cb6:	09 94       	ijmp

00000cb8 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 cb8:	f8 94       	cli

00000cba <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 cba:	ff cf       	rjmp	.-2      	; 0xcba <__stop_program>
